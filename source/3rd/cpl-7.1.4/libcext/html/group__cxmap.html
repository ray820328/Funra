<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Standard Library Extensions: Maps</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C Standard Library Extensions
   &#160;<span id="projectnumber">1.2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Maps</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga760f439b10c78131f1e2bfdba44edfd5"><td class="memItemLeft" align="right" valign="top">typedef cx_tree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a></td></tr>
<tr class="memdesc:ga760f439b10c78131f1e2bfdba44edfd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map datatype.  <a href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">More...</a><br /></td></tr>
<tr class="separator:ga760f439b10c78131f1e2bfdba44edfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5294a05a8562fc04f1ba110a2e0717b"><td class="memItemLeft" align="right" valign="top">typedef cx_tree_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a></td></tr>
<tr class="memdesc:gac5294a05a8562fc04f1ba110a2e0717b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map iterator datatype.  <a href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">More...</a><br /></td></tr>
<tr class="separator:gac5294a05a8562fc04f1ba110a2e0717b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e29bf978d1e595c8fedc6772e2ea907"><td class="memItemLeft" align="right" valign="top">typedef cx_tree_const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga9e29bf978d1e595c8fedc6772e2ea907">cx_map_const_iterator</a></td></tr>
<tr class="memdesc:ga9e29bf978d1e595c8fedc6772e2ea907"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map constant iterator datatype.  <a href="group__cxmap.html#ga9e29bf978d1e595c8fedc6772e2ea907">More...</a><br /></td></tr>
<tr class="separator:ga9e29bf978d1e595c8fedc6772e2ea907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee0926cc0122c3a915929dc8d436198"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__cxtree.html#ga0fba28796f9eaa709022e98cbb4f7d0e">cx_tree_compare_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga9ee0926cc0122c3a915929dc8d436198">cx_map_compare_func</a></td></tr>
<tr class="memdesc:ga9ee0926cc0122c3a915929dc8d436198"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map's key comparison operator function.  <a href="group__cxmap.html#ga9ee0926cc0122c3a915929dc8d436198">More...</a><br /></td></tr>
<tr class="separator:ga9ee0926cc0122c3a915929dc8d436198"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga156f4653538a24d512874a23213a2e1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga156f4653538a24d512874a23213a2e1f">cx_map_begin</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map)</td></tr>
<tr class="memdesc:ga156f4653538a24d512874a23213a2e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first pair in a map.  <a href="group__cxmap.html#ga156f4653538a24d512874a23213a2e1f">More...</a><br /></td></tr>
<tr class="separator:ga156f4653538a24d512874a23213a2e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5dd15139b587d10b5cb7a15128b880e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#gae5dd15139b587d10b5cb7a15128b880e">cx_map_end</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map)</td></tr>
<tr class="memdesc:gae5dd15139b587d10b5cb7a15128b880e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the position after the last pair in the map.  <a href="group__cxmap.html#gae5dd15139b587d10b5cb7a15128b880e">More...</a><br /></td></tr>
<tr class="separator:gae5dd15139b587d10b5cb7a15128b880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f33e89b70fefdb79b99467aba18587d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga0f33e89b70fefdb79b99467aba18587d">cx_map_next</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, <a class="el" href="group__cxmap.html#ga9e29bf978d1e595c8fedc6772e2ea907">cx_map_const_iterator</a> position)</td></tr>
<tr class="memdesc:ga0f33e89b70fefdb79b99467aba18587d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the next pair in the map.  <a href="group__cxmap.html#ga0f33e89b70fefdb79b99467aba18587d">More...</a><br /></td></tr>
<tr class="separator:ga0f33e89b70fefdb79b99467aba18587d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f6382072295b03f41686716486bb4d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga6f6382072295b03f41686716486bb4d3">cx_map_previous</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, <a class="el" href="group__cxmap.html#ga9e29bf978d1e595c8fedc6772e2ea907">cx_map_const_iterator</a> position)</td></tr>
<tr class="memdesc:ga6f6382072295b03f41686716486bb4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the previous pair in the map.  <a href="group__cxmap.html#ga6f6382072295b03f41686716486bb4d3">More...</a><br /></td></tr>
<tr class="separator:ga6f6382072295b03f41686716486bb4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe98264e8e9db4c0cfeba4561db37035"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#gafe98264e8e9db4c0cfeba4561db37035">cx_map_clear</a> (<a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map)</td></tr>
<tr class="memdesc:gafe98264e8e9db4c0cfeba4561db37035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all pairs from a map.  <a href="group__cxmap.html#gafe98264e8e9db4c0cfeba4561db37035">More...</a><br /></td></tr>
<tr class="separator:gafe98264e8e9db4c0cfeba4561db37035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5d5b06a038b9746538291395432627"><td class="memItemLeft" align="right" valign="top">cxbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#gacd5d5b06a038b9746538291395432627">cx_map_empty</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map)</td></tr>
<tr class="memdesc:gacd5d5b06a038b9746538291395432627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a map is empty.  <a href="group__cxmap.html#gacd5d5b06a038b9746538291395432627">More...</a><br /></td></tr>
<tr class="separator:gacd5d5b06a038b9746538291395432627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e539ee5ac510a3000d9984ce72d21f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga6e539ee5ac510a3000d9984ce72d21f8">cx_map_new</a> (<a class="el" href="group__cxmap.html#ga9ee0926cc0122c3a915929dc8d436198">cx_map_compare_func</a> compare, cx_free_func key_destroy, cx_free_func value_destroy)</td></tr>
<tr class="memdesc:ga6e539ee5ac510a3000d9984ce72d21f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new map without any elements.  <a href="group__cxmap.html#ga6e539ee5ac510a3000d9984ce72d21f8">More...</a><br /></td></tr>
<tr class="separator:ga6e539ee5ac510a3000d9984ce72d21f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94d7565c5fe50fec961d4f3f4fdbd241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga94d7565c5fe50fec961d4f3f4fdbd241">cx_map_delete</a> (<a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map)</td></tr>
<tr class="memdesc:ga94d7565c5fe50fec961d4f3f4fdbd241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a map and all its elements.  <a href="group__cxmap.html#ga94d7565c5fe50fec961d4f3f4fdbd241">More...</a><br /></td></tr>
<tr class="separator:ga94d7565c5fe50fec961d4f3f4fdbd241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga307c8c94ef5f053f32fd3e2ba91d74c0"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga307c8c94ef5f053f32fd3e2ba91d74c0">cx_map_size</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map)</td></tr>
<tr class="memdesc:ga307c8c94ef5f053f32fd3e2ba91d74c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual number of pairs in the map.  <a href="group__cxmap.html#ga307c8c94ef5f053f32fd3e2ba91d74c0">More...</a><br /></td></tr>
<tr class="separator:ga307c8c94ef5f053f32fd3e2ba91d74c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81cb88ef79b84e82c362b09a78319fbe"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga81cb88ef79b84e82c362b09a78319fbe">cx_map_max_size</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map)</td></tr>
<tr class="memdesc:ga81cb88ef79b84e82c362b09a78319fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of pairs possible.  <a href="group__cxmap.html#ga81cb88ef79b84e82c362b09a78319fbe">More...</a><br /></td></tr>
<tr class="separator:ga81cb88ef79b84e82c362b09a78319fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8fbf9375ffab6b66ef27cbee11a015"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmap.html#ga9ee0926cc0122c3a915929dc8d436198">cx_map_compare_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga4d8fbf9375ffab6b66ef27cbee11a015">cx_map_key_comp</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map)</td></tr>
<tr class="memdesc:ga4d8fbf9375ffab6b66ef27cbee11a015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a map's key comparison function.  <a href="group__cxmap.html#ga4d8fbf9375ffab6b66ef27cbee11a015">More...</a><br /></td></tr>
<tr class="separator:ga4d8fbf9375ffab6b66ef27cbee11a015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac480f53fd51f8e04b79ec92d1fe8e586"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#gac480f53fd51f8e04b79ec92d1fe8e586">cx_map_swap</a> (<a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map1, <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map2)</td></tr>
<tr class="memdesc:gac480f53fd51f8e04b79ec92d1fe8e586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of two maps.  <a href="group__cxmap.html#gac480f53fd51f8e04b79ec92d1fe8e586">More...</a><br /></td></tr>
<tr class="separator:gac480f53fd51f8e04b79ec92d1fe8e586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80e8807a9c18e074bcac96a6477afb55"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga80e8807a9c18e074bcac96a6477afb55">cx_map_assign</a> (<a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, <a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> position, cxcptr data)</td></tr>
<tr class="memdesc:ga80e8807a9c18e074bcac96a6477afb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign data to an iterator position.  <a href="group__cxmap.html#ga80e8807a9c18e074bcac96a6477afb55">More...</a><br /></td></tr>
<tr class="separator:ga80e8807a9c18e074bcac96a6477afb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb1c59ace3e10f9588616d0b9ea7fbfc"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#gaeb1c59ace3e10f9588616d0b9ea7fbfc">cx_map_put</a> (<a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, cxcptr key, cxcptr data)</td></tr>
<tr class="memdesc:gaeb1c59ace3e10f9588616d0b9ea7fbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a pair matching the given key.  <a href="group__cxmap.html#gaeb1c59ace3e10f9588616d0b9ea7fbfc">More...</a><br /></td></tr>
<tr class="separator:gaeb1c59ace3e10f9588616d0b9ea7fbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac55eccdca3ef107f4b76f5a7a57fca0"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#gaac55eccdca3ef107f4b76f5a7a57fca0">cx_map_get_key</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, <a class="el" href="group__cxmap.html#ga9e29bf978d1e595c8fedc6772e2ea907">cx_map_const_iterator</a> position)</td></tr>
<tr class="memdesc:gaac55eccdca3ef107f4b76f5a7a57fca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the key from a given iterator position.  <a href="group__cxmap.html#gaac55eccdca3ef107f4b76f5a7a57fca0">More...</a><br /></td></tr>
<tr class="separator:gaac55eccdca3ef107f4b76f5a7a57fca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6088581b6b73fd905bc37abffab2edf"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#gad6088581b6b73fd905bc37abffab2edf">cx_map_get_value</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, <a class="el" href="group__cxmap.html#ga9e29bf978d1e595c8fedc6772e2ea907">cx_map_const_iterator</a> position)</td></tr>
<tr class="memdesc:gad6088581b6b73fd905bc37abffab2edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data from a given iterator position.  <a href="group__cxmap.html#gad6088581b6b73fd905bc37abffab2edf">More...</a><br /></td></tr>
<tr class="separator:gad6088581b6b73fd905bc37abffab2edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc8172e04dcf5589b00f1c6cc49207c"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga6dc8172e04dcf5589b00f1c6cc49207c">cx_map_get</a> (<a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, cxcptr key)</td></tr>
<tr class="memdesc:ga6dc8172e04dcf5589b00f1c6cc49207c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data for a given key.  <a href="group__cxmap.html#ga6dc8172e04dcf5589b00f1c6cc49207c">More...</a><br /></td></tr>
<tr class="separator:ga6dc8172e04dcf5589b00f1c6cc49207c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacefcf33145d47dcb9439c23b07be5fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#gaacefcf33145d47dcb9439c23b07be5fa">cx_map_find</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, cxcptr key)</td></tr>
<tr class="memdesc:gaacefcf33145d47dcb9439c23b07be5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate an element in the map.  <a href="group__cxmap.html#gaacefcf33145d47dcb9439c23b07be5fa">More...</a><br /></td></tr>
<tr class="separator:gaacefcf33145d47dcb9439c23b07be5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75110aefe5bdddd1b3ab03d752d8e22b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga75110aefe5bdddd1b3ab03d752d8e22b">cx_map_lower_bound</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, cxcptr key)</td></tr>
<tr class="memdesc:ga75110aefe5bdddd1b3ab03d752d8e22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of a subsequence matching a given key.  <a href="group__cxmap.html#ga75110aefe5bdddd1b3ab03d752d8e22b">More...</a><br /></td></tr>
<tr class="separator:ga75110aefe5bdddd1b3ab03d752d8e22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3cf57d1d4fc024a1d87dbae9807c209"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#gaa3cf57d1d4fc024a1d87dbae9807c209">cx_map_upper_bound</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, cxcptr key)</td></tr>
<tr class="memdesc:gaa3cf57d1d4fc024a1d87dbae9807c209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of a subsequence matching a given key.  <a href="group__cxmap.html#gaa3cf57d1d4fc024a1d87dbae9807c209">More...</a><br /></td></tr>
<tr class="separator:gaa3cf57d1d4fc024a1d87dbae9807c209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61e396d53f3fe4f3a28f906e59e02dfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga61e396d53f3fe4f3a28f906e59e02dfb">cx_map_equal_range</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, cxcptr key, <a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> *begin, <a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> *end)</td></tr>
<tr class="memdesc:ga61e396d53f3fe4f3a28f906e59e02dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a subsequence matching a given key.  <a href="group__cxmap.html#ga61e396d53f3fe4f3a28f906e59e02dfb">More...</a><br /></td></tr>
<tr class="separator:ga61e396d53f3fe4f3a28f906e59e02dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11cb14ad033e85525ded6dc92d093499"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga11cb14ad033e85525ded6dc92d093499">cx_map_count</a> (const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, cxcptr key)</td></tr>
<tr class="memdesc:ga11cb14ad033e85525ded6dc92d093499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements matching a key.  <a href="group__cxmap.html#ga11cb14ad033e85525ded6dc92d093499">More...</a><br /></td></tr>
<tr class="separator:ga11cb14ad033e85525ded6dc92d093499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf6b77fe3fc775b2fc29bc435e6130b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#gaaf6b77fe3fc775b2fc29bc435e6130b0">cx_map_insert</a> (<a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, cxcptr key, cxcptr data)</td></tr>
<tr class="memdesc:gaaf6b77fe3fc775b2fc29bc435e6130b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to insert data into a map.  <a href="group__cxmap.html#gaaf6b77fe3fc775b2fc29bc435e6130b0">More...</a><br /></td></tr>
<tr class="separator:gaaf6b77fe3fc775b2fc29bc435e6130b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5fb17aeafdff4b2cd5a660b06e80fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga3b5fb17aeafdff4b2cd5a660b06e80fe">cx_map_erase_position</a> (<a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, <a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> position)</td></tr>
<tr class="memdesc:ga3b5fb17aeafdff4b2cd5a660b06e80fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element from a map.  <a href="group__cxmap.html#ga3b5fb17aeafdff4b2cd5a660b06e80fe">More...</a><br /></td></tr>
<tr class="separator:ga3b5fb17aeafdff4b2cd5a660b06e80fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga284d85c6de2206aaf7ff60a6667ce084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#ga284d85c6de2206aaf7ff60a6667ce084">cx_map_erase_range</a> (<a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, <a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> begin, <a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> end)</td></tr>
<tr class="memdesc:ga284d85c6de2206aaf7ff60a6667ce084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a range of elements from a map.  <a href="group__cxmap.html#ga284d85c6de2206aaf7ff60a6667ce084">More...</a><br /></td></tr>
<tr class="separator:ga284d85c6de2206aaf7ff60a6667ce084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a58e7a005280bdd0ba8a67b2c46c89"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmap.html#gae9a58e7a005280bdd0ba8a67b2c46c89">cx_map_erase</a> (<a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *map, cxcptr key)</td></tr>
<tr class="memdesc:gae9a58e7a005280bdd0ba8a67b2c46c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element from a map according to the provided key.  <a href="group__cxmap.html#gae9a58e7a005280bdd0ba8a67b2c46c89">More...</a><br /></td></tr>
<tr class="separator:gae9a58e7a005280bdd0ba8a67b2c46c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The module implements a map data type, i.e. a container managing key/value pairs as elements. Their elements are automatically sorted according to a sorting criterion used for the key. The container is optimized for lookup operations. Maps are restriced to unique keys, i.e. a key can only appear once in a map.</p>
<dl class="section user"><dt>Synopsis:</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cxmap.h&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga760f439b10c78131f1e2bfdba44edfd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga760f439b10c78131f1e2bfdba44edfd5">&#9670;&nbsp;</a></span>cx_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef cx_tree <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The map datatype. </p>
<p>The internal representation of a map is a balanced binary tree. For this reason cx_map is just an alias for cx_tree. </p>

</div>
</div>
<a id="ga9ee0926cc0122c3a915929dc8d436198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee0926cc0122c3a915929dc8d436198">&#9670;&nbsp;</a></span>cx_map_compare_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__cxtree.html#ga0fba28796f9eaa709022e98cbb4f7d0e">cx_tree_compare_func</a> <a class="el" href="group__cxmap.html#ga9ee0926cc0122c3a915929dc8d436198">cx_map_compare_func</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The map's key comparison operator function. </p>
<p>This type of function is used internally by a map when key comparisons are necessary. It must return <code>TRUE</code> if the comparison of its first argument with the second argument succeeds, and <code>FALSE</code> otherwise. It is actually an alias for cx_tree_compare_func.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxtree.html#ga0fba28796f9eaa709022e98cbb4f7d0e" title="The tree&#39;s key comparison operator function.">cx_tree_compare_func</a> </dd></dl>

</div>
</div>
<a id="ga9e29bf978d1e595c8fedc6772e2ea907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e29bf978d1e595c8fedc6772e2ea907">&#9670;&nbsp;</a></span>cx_map_const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef cx_tree_const_iterator <a class="el" href="group__cxmap.html#ga9e29bf978d1e595c8fedc6772e2ea907">cx_map_const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The map constant iterator datatype. </p>
<p>The map constant iterator is just an alias for the cx_tree_const_iterator datatype. </p>

</div>
</div>
<a id="gac5294a05a8562fc04f1ba110a2e0717b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5294a05a8562fc04f1ba110a2e0717b">&#9670;&nbsp;</a></span>cx_map_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef cx_tree_iterator <a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The map iterator datatype. </p>
<p>The map iterator is just an alias for the cx_tree_iterator datatype. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga80e8807a9c18e074bcac96a6477afb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80e8807a9c18e074bcac96a6477afb55">&#9670;&nbsp;</a></span>cx_map_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_map_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign data to an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">position</td><td>Iterator positions where the data will be stored. </td></tr>
    <tr><td class="paramname">data</td><td>Data to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the previously stored data object.</dd></dl>
<p>The function assigns a data object reference <em>data</em> to the iterator position <em>position</em> of the map <em>map</em>. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga5e47b9013eaeb6fe294e02d54a1e8cdf">cx_tree_assign()</a>.</p>

</div>
</div>
<a id="ga156f4653538a24d512874a23213a2e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga156f4653538a24d512874a23213a2e1f">&#9670;&nbsp;</a></span>cx_map_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> cx_map_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator to the first pair in a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The map to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the first pair or <b><a class="el" href="group__cxmap.html#gae5dd15139b587d10b5cb7a15128b880e" title="Get an iterator for the position after the last pair in the map.">cx_map_end()</a></b> if the map is empty.</dd></dl>
<p>The function returns a handle for the first pair in the map <em>map</em>. The returned iterator cannot be used directly to access the value field of the key/value pair, but only through the appropriate methods. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga6038e74547e7e3ac3280c519914b60a3">cx_tree_begin()</a>.</p>

</div>
</div>
<a id="gafe98264e8e9db4c0cfeba4561db37035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe98264e8e9db4c0cfeba4561db37035">&#9670;&nbsp;</a></span>cx_map_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_map_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all pairs from a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Map to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The map <em>map</em> is cleared, i.e. all pairs are removed from the map. Keys and values are destroyed using the key and value destructors set up during map creation. After calling this function the map is empty. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga377e4c1587471733983f04707f8e619e">cx_tree_clear()</a>.</p>

</div>
</div>
<a id="ga11cb14ad033e85525ded6dc92d093499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11cb14ad033e85525ded6dc92d093499">&#9670;&nbsp;</a></span>cx_map_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_map_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of elements matching a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the (key, value) pair(s) to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements with the specified key.</dd></dl>
<p>Counts all elements of the map <em>map</em> matching the key <em>key</em>. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e">cx_tree_end()</a>, and <a class="el" href="group__cxtree.html#gaa36076ac9467d17c8655a9a94a5f7a44">cx_tree_find()</a>.</p>

</div>
</div>
<a id="ga94d7565c5fe50fec961d4f3f4fdbd241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94d7565c5fe50fec961d4f3f4fdbd241">&#9670;&nbsp;</a></span>cx_map_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_map_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a map and all its elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The map to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The map <em>map</em> is deallocated. All data values and keys are deallocated using the map's key and value destructor. If no key and/or value destructor was set when the <em>map</em> was created the keys and the stored data values are left untouched. In this case the key and value deallocation is the responsibility of the user.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxmap.html#ga6e539ee5ac510a3000d9984ce72d21f8" title="Create a new map without any elements.">cx_map_new()</a> </dd></dl>

<p class="reference">References <a class="el" href="group__cxtree.html#ga5e30a6c27e8e423d35a0818f264337fe">cx_tree_delete()</a>.</p>

</div>
</div>
<a id="gacd5d5b06a038b9746538291395432627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5d5b06a038b9746538291395432627">&#9670;&nbsp;</a></span>cx_map_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxbool cx_map_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a map is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <code>TRUE</code> if the map is empty, and <code>FALSE</code> otherwise.</dd></dl>
<p>The function checks if the map contains any pairs. Calling this function is equivalent to the statement: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> (<a class="code" href="group__cxmap.html#ga307c8c94ef5f053f32fd3e2ba91d74c0">cx_map_size</a>(map) == 0);</div>
</div><!-- fragment --> 
<p class="reference">References <a class="el" href="group__cxtree.html#ga148c828066a5d05e95acd4ec3a525bc8">cx_tree_empty()</a>.</p>

</div>
</div>
<a id="gae5dd15139b587d10b5cb7a15128b880e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5dd15139b587d10b5cb7a15128b880e">&#9670;&nbsp;</a></span>cx_map_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> cx_map_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the position after the last pair in the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The map to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the end of the map.</dd></dl>
<p>The function returns an iterator for the position one past the last pair in the map <em>map</em>. The iteration is done in ascending order according to the keys. The returned iterator cannot be used directly to access the value field of the key/value pair, but only through the appropriate methods. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e">cx_tree_end()</a>.</p>

</div>
</div>
<a id="ga61e396d53f3fe4f3a28f906e59e02dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61e396d53f3fe4f3a28f906e59e02dfb">&#9670;&nbsp;</a></span>cx_map_equal_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_map_equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a subsequence matching a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the (key, value) pair(s) to be located. </td></tr>
    <tr><td class="paramname">begin</td><td>First element with key <em>key</em>. </td></tr>
    <tr><td class="paramname">end</td><td>Last element with key <em>key</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function returns the beginning and the end of a subsequence of map elements with the key <em>key</em> through through the <em>begin</em> and <em>end</em> arguments. After calling this function <em>begin</em> possibly points to the first element of <em>map</em> matching the key <em>key</em> and <em>end</em> possibly points to the last element of the sequence. If key is not present in the map <em>begin</em> and <em>end</em> point to the next greater element or, if no such element exists, to <b><a class="el" href="group__cxmap.html#gae5dd15139b587d10b5cb7a15128b880e" title="Get an iterator for the position after the last pair in the map.">cx_map_end()</a></b>. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga9db4e043848ab20c0111b9a1b081593a">cx_tree_equal_range()</a>.</p>

</div>
</div>
<a id="gae9a58e7a005280bdd0ba8a67b2c46c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9a58e7a005280bdd0ba8a67b2c46c89">&#9670;&nbsp;</a></span>cx_map_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_map_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase an element from a map according to the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the element to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of removed elements.</dd></dl>
<p>This function erases the element with the specified key <em>key</em>, from <em>map</em>. Key and value associated with the erased pair are deallocated using the map's key and value destructors, provided they have been set.</p>
<dl class="section note"><dt>Note</dt><dd>For maps the the returned number should only be 0 or 1, due to the nature of maps. </dd></dl>

<p class="reference">References <a class="el" href="group__cxtree.html#ga14027eafaeb3eaddd513b839672c5e92">cx_tree_erase()</a>.</p>

</div>
</div>
<a id="ga3b5fb17aeafdff4b2cd5a660b06e80fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b5fb17aeafdff4b2cd5a660b06e80fe">&#9670;&nbsp;</a></span>cx_map_erase_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_map_erase_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase an element from a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">position</td><td>Iterator position of the element to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function erases an element, specified by the iterator <em>position</em>, from <em>map</em>. Key and value associated with the erased pair are deallocated using the map's key and value destructors, provided they have been set. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#gaea5f45961ba5ab503c751f54810e8258">cx_tree_erase_position()</a>.</p>

</div>
</div>
<a id="ga284d85c6de2206aaf7ff60a6667ce084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga284d85c6de2206aaf7ff60a6667ce084">&#9670;&nbsp;</a></span>cx_map_erase_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_map_erase_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a range of elements from a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">begin</td><td>Iterator pointing to the start of the range to erase. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the range to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function erases all elements in the range [begin, end) from the map <em>map</em>. Key and value associated with the erased pair(s) are deallocated using the map's key and value destructors, provided they have been set. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#gae573050dfd0d7cc829844609ff4a1dc2">cx_tree_erase_range()</a>.</p>

</div>
</div>
<a id="gaacefcf33145d47dcb9439c23b07be5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacefcf33145d47dcb9439c23b07be5fa">&#9670;&nbsp;</a></span>cx_map_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> cx_map_find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate an element in the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the (key, value) pair to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the sought-after element, or <b><a class="el" href="group__cxmap.html#gae5dd15139b587d10b5cb7a15128b880e" title="Get an iterator for the position after the last pair in the map.">cx_map_end()</a></b> if it was not found.</dd></dl>
<p>The function searches the map <em>map</em> for an element with a key matching <em>key</em>. If the search was successful an iterator to the sought-after pair is returned. If the search did not succeed, i.e. <em>key</em> is not present in the map, a one past the end iterator is returned. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#gaa36076ac9467d17c8655a9a94a5f7a44">cx_tree_find()</a>.</p>

</div>
</div>
<a id="ga6dc8172e04dcf5589b00f1c6cc49207c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dc8172e04dcf5589b00f1c6cc49207c">&#9670;&nbsp;</a></span>cx_map_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_map_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data for a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">key</td><td>Key for which the data should be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the value of the (key, value) pair matching the key <em>key</em>.</dd></dl>
<p>The function looks for the key <em>key</em> in the map <em>map</em> and returns the data associated with this key. If <em>key</em> is not present in <em>map</em> it is inserted using <code>NULL</code> as the associated default value, which is then returned. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e">cx_tree_end()</a>, <a class="el" href="group__cxtree.html#ga5578369c1a53b8592ff83032c6780cfb">cx_tree_get_key()</a>, <a class="el" href="group__cxtree.html#ga4b15b6abafbb4f528b5a1f0090b48f86">cx_tree_get_value()</a>, <a class="el" href="group__cxtree.html#ga1f8f15e701fd1eb4ebe15639aea354e3">cx_tree_insert_unique()</a>, <a class="el" href="group__cxtree.html#ga40f1e3c1aff10f23fa128187f37f30ce">cx_tree_key_comp()</a>, and <a class="el" href="group__cxtree.html#ga22e4896d6cd7486dc6d73eb7c3a56fea">cx_tree_lower_bound()</a>.</p>

</div>
</div>
<a id="gaac55eccdca3ef107f4b76f5a7a57fca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac55eccdca3ef107f4b76f5a7a57fca0">&#9670;&nbsp;</a></span>cx_map_get_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_map_get_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga9e29bf978d1e595c8fedc6772e2ea907">cx_map_const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the key from a given iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">position</td><td>Iterator position the data is retrieved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference for the key.</dd></dl>
<p>The function returns a reference to the key associated with the iterator position <em>position</em> in the map <em>map</em>.</p>
<dl class="section note"><dt>Note</dt><dd>One must not modify the key of <em>position</em> through the returned reference, since this might corrupt the map! </dd></dl>

<p class="reference">References <a class="el" href="group__cxtree.html#ga5578369c1a53b8592ff83032c6780cfb">cx_tree_get_key()</a>.</p>

</div>
</div>
<a id="gad6088581b6b73fd905bc37abffab2edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6088581b6b73fd905bc37abffab2edf">&#9670;&nbsp;</a></span>cx_map_get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_map_get_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga9e29bf978d1e595c8fedc6772e2ea907">cx_map_const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data from a given iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">position</td><td>Iterator position the data is retrieved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for the data object.</dd></dl>
<p>The function returns a reference to the data stored at iterator position <em>position</em> in the map <em>map</em>. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga4b15b6abafbb4f528b5a1f0090b48f86">cx_tree_get_value()</a>.</p>

</div>
</div>
<a id="gaaf6b77fe3fc775b2fc29bc435e6130b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf6b77fe3fc775b2fc29bc435e6130b0">&#9670;&nbsp;</a></span>cx_map_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> cx_map_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to insert data into a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">key</td><td>Key used to store the data. </td></tr>
    <tr><td class="paramname">data</td><td>Data to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted pair, or <code>NULL</code> if the pair could not be inserted.</dd></dl>
<p>This function attempts to insert a (key, value) pair into the map <em>map</em>. The insertion fails if the key already present in the map, since a key may only occur once in a map. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga1f8f15e701fd1eb4ebe15639aea354e3">cx_tree_insert_unique()</a>.</p>

</div>
</div>
<a id="ga4d8fbf9375ffab6b66ef27cbee11a015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d8fbf9375ffab6b66ef27cbee11a015">&#9670;&nbsp;</a></span>cx_map_key_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmap.html#ga9ee0926cc0122c3a915929dc8d436198">cx_map_compare_func</a> cx_map_key_comp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a map's key comparison function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The map to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for the map's key comparison function.</dd></dl>
<p>The function retrieves the function used by the map methods for comparing keys. The key comparison function is set during map creation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxmap.html#ga6e539ee5ac510a3000d9984ce72d21f8" title="Create a new map without any elements.">cx_map_new()</a> </dd></dl>

<p class="reference">References <a class="el" href="group__cxtree.html#ga40f1e3c1aff10f23fa128187f37f30ce">cx_tree_key_comp()</a>.</p>

</div>
</div>
<a id="ga75110aefe5bdddd1b3ab03d752d8e22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75110aefe5bdddd1b3ab03d752d8e22b">&#9670;&nbsp;</a></span>cx_map_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> cx_map_lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the beginning of a subsequence matching a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the (key, value) pair(s) to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first position where an element with key <em>key</em> would get inserted, i.e. the first element with a key greater or equal than <em>key</em>.</dd></dl>
<p>The function returns the first element of a subsequence of elements in the map that match the given key <em>key</em>. If <em>key</em> is not present in the map <em>map</em> an iterator pointing to the first element that has a greater key than <em>key</em> or <b><a class="el" href="group__cxmap.html#gae5dd15139b587d10b5cb7a15128b880e" title="Get an iterator for the position after the last pair in the map.">cx_map_end()</a></b> if no such element exists.</p>
<dl class="section note"><dt>Note</dt><dd>For maps, where a key can occur only once, is a call to this function equivalent to calling <b><a class="el" href="group__cxmap.html#gaacefcf33145d47dcb9439c23b07be5fa" title="Locate an element in the map.">cx_map_find()</a></b>. </dd></dl>

<p class="reference">References <a class="el" href="group__cxtree.html#ga22e4896d6cd7486dc6d73eb7c3a56fea">cx_tree_lower_bound()</a>.</p>

</div>
</div>
<a id="ga81cb88ef79b84e82c362b09a78319fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81cb88ef79b84e82c362b09a78319fbe">&#9670;&nbsp;</a></span>cx_map_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_map_max_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum number of pairs possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of pairs that can be stored in the map.</dd></dl>
<p>Retrieves the map's capacity, i.e. the maximum possible number of pairs a map can manage. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga2a04a36bb3a449f14efa25e784169b57">cx_tree_max_size()</a>.</p>

</div>
</div>
<a id="ga6e539ee5ac510a3000d9984ce72d21f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e539ee5ac510a3000d9984ce72d21f8">&#9670;&nbsp;</a></span>cx_map_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a>* cx_map_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga9ee0926cc0122c3a915929dc8d436198">cx_map_compare_func</a>&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_free_func&#160;</td>
          <td class="paramname"><em>key_destroy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_free_func&#160;</td>
          <td class="paramname"><em>value_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new map without any elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>Function used to compare keys. </td></tr>
    <tr><td class="paramname">key_destroy</td><td>Destructor for the keys. </td></tr>
    <tr><td class="paramname">value_destroy</td><td>Destructor for the value field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for the newly allocated map.</dd></dl>
<p>Memory for a new map is allocated and the map is initialized to be a valid empty map.</p>
<p>The map's key comparison function is set to <em>compare</em>. It must return <code>TRUE</code> if the comparison of its first argument with its second argument succeeds, and <code>FALSE</code> otherwise.</p>
<p>The destructors for a map node's key and value field are set to <em>key_destroy</em> and <em>value_destroy</em>. Whenever a map node is destroyed these functions are used to deallocate the memory used by the key and the value. Each of the destructors might be <code>NULL</code>, i.e. keys and values are not deallocated during destroy operations.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxmap.html#ga9ee0926cc0122c3a915929dc8d436198" title="The map&#39;s key comparison operator function.">cx_map_compare_func()</a> </dd></dl>

<p class="reference">References <a class="el" href="group__cxtree.html#ga4d5b89c5e8709645b85996d05478d71e">cx_tree_new()</a>.</p>

</div>
</div>
<a id="ga0f33e89b70fefdb79b99467aba18587d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f33e89b70fefdb79b99467aba18587d">&#9670;&nbsp;</a></span>cx_map_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> cx_map_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga9e29bf978d1e595c8fedc6772e2ea907">cx_map_const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the next pair in the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">position</td><td>Current iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the pair immediately following <em>position</em>.</dd></dl>
<p>The function returns an iterator for the next pair in the map <em>map</em> with respect to the current iterator position <em>position</em>. Iteration is done in ascending order according to the keys. If the map is empty or <em>position</em> points to the end of the map the function returns <b><a class="el" href="group__cxmap.html#gae5dd15139b587d10b5cb7a15128b880e" title="Get an iterator for the position after the last pair in the map.">cx_map_end()</a></b>. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga86c1d604b075a32860f0f66cf678267c">cx_tree_next()</a>.</p>

</div>
</div>
<a id="ga6f6382072295b03f41686716486bb4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f6382072295b03f41686716486bb4d3">&#9670;&nbsp;</a></span>cx_map_previous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> cx_map_previous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga9e29bf978d1e595c8fedc6772e2ea907">cx_map_const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the previous pair in the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">position</td><td>Current iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the pair immediately preceding <em>position</em>.</dd></dl>
<p>The function returns an iterator for the previous pair in the map <em>map</em> with respect to the current iterator position <em>position</em>. Iteration is done in ascending order according to the keys. If the map is empty or <em>position</em> points to the beginning of the map the function returns <b><a class="el" href="group__cxmap.html#gae5dd15139b587d10b5cb7a15128b880e" title="Get an iterator for the position after the last pair in the map.">cx_map_end()</a></b>. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga7a7a6770d510c426f281fa9d46e1be5e">cx_tree_previous()</a>.</p>

</div>
</div>
<a id="gaeb1c59ace3e10f9588616d0b9ea7fbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb1c59ace3e10f9588616d0b9ea7fbfc">&#9670;&nbsp;</a></span>cx_map_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_map_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a pair matching the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the map element to be changed. </td></tr>
    <tr><td class="paramname">data</td><td>Data value to be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previously stored data value of the (key, value) pair.</dd></dl>
<p>The function replaces the value of the map element with the key <em>key</em> with <em>value</em>, if the <em>key</em> is present in the map <em>map</em>. The old value of the map element is returned. If the key is not yet present in the map the pair (<em>key</em>, <em>data</em>) is inserted in the map. In this case the returned handle to the previously stored data points to <em>data</em>. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga5e47b9013eaeb6fe294e02d54a1e8cdf">cx_tree_assign()</a>, <a class="el" href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e">cx_tree_end()</a>, <a class="el" href="group__cxtree.html#ga1f8f15e701fd1eb4ebe15639aea354e3">cx_tree_insert_unique()</a>, and <a class="el" href="group__cxtree.html#ga22e4896d6cd7486dc6d73eb7c3a56fea">cx_tree_lower_bound()</a>.</p>

</div>
</div>
<a id="ga307c8c94ef5f053f32fd3e2ba91d74c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga307c8c94ef5f053f32fd3e2ba91d74c0">&#9670;&nbsp;</a></span>cx_map_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_map_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the actual number of pairs in the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current number of pairs, or 0 if the map is empty.</dd></dl>
<p>Retrieves the current number of pairs stored in the map. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga3cc3eec66e54e3292d3354ffd2076696">cx_tree_size()</a>.</p>

</div>
</div>
<a id="gac480f53fd51f8e04b79ec92d1fe8e586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac480f53fd51f8e04b79ec92d1fe8e586">&#9670;&nbsp;</a></span>cx_map_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_map_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the contents of two maps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map1</td><td>First map. </td></tr>
    <tr><td class="paramname">map2</td><td>Second map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>All pairs stored in the first map <em>map1</em> are moved to the second map <em>map2</em>, while the pairs from <em>map2</em> are moved to <em>map1</em>. Also the key comparison function, the key and the value destructor are exchanged. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#gaf79317c9c323f0d7b1903b7f23c1012e">cx_tree_swap()</a>.</p>

</div>
</div>
<a id="gaa3cf57d1d4fc024a1d87dbae9807c209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3cf57d1d4fc024a1d87dbae9807c209">&#9670;&nbsp;</a></span>cx_map_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> cx_map_upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmap.html#ga760f439b10c78131f1e2bfdba44edfd5">cx_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the end of a subsequence matching a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A map. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the (key, value) pair(s) to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the last position where an element with key <em>key</em> would get inserted, i.e. the first element with a key greater than <em>key</em>.</dd></dl>
<p>The function returns the last element of a subsequence of elements in the map that match the given key <em>key</em>. If <em>key</em> is not present in the map <em>map</em> an iterator pointing to the first element that has a greater key than <em>key</em> or <b><a class="el" href="group__cxmap.html#gae5dd15139b587d10b5cb7a15128b880e" title="Get an iterator for the position after the last pair in the map.">cx_map_end()</a></b> if no such element exists.</p>
<dl class="section note"><dt>Note</dt><dd>For maps, calling this function is equivalent to: <div class="fragment"><div class="line"><a class="code" href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a> it;</div>
<div class="line"> </div>
<div class="line">it = <a class="code" href="group__cxmap.html#gaacefcf33145d47dcb9439c23b07be5fa">cx_map_find</a>(map, key);</div>
<div class="line">it = <a class="code" href="group__cxmap.html#ga0f33e89b70fefdb79b99467aba18587d">cx_map_next</a>(map, it);</div>
</div><!-- fragment --> omitting all error checks. </dd></dl>

<p class="reference">References <a class="el" href="group__cxtree.html#ga410dcaddb7845533076d98466f51c053">cx_tree_upper_bound()</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__cxmap_html_ga0f33e89b70fefdb79b99467aba18587d"><div class="ttname"><a href="group__cxmap.html#ga0f33e89b70fefdb79b99467aba18587d">cx_map_next</a></div><div class="ttdeci">cx_map_iterator cx_map_next(const cx_map *map, cx_map_const_iterator position)</div><div class="ttdoc">Get an iterator for the next pair in the map.</div><div class="ttdef"><b>Definition:</b> cxmap.c:110</div></div>
<div class="ttc" id="agroup__cxmap_html_ga307c8c94ef5f053f32fd3e2ba91d74c0"><div class="ttname"><a href="group__cxmap.html#ga307c8c94ef5f053f32fd3e2ba91d74c0">cx_map_size</a></div><div class="ttdeci">cxsize cx_map_size(const cx_map *map)</div><div class="ttdoc">Get the actual number of pairs in the map.</div><div class="ttdef"><b>Definition:</b> cxmap.c:267</div></div>
<div class="ttc" id="agroup__cxmap_html_gaacefcf33145d47dcb9439c23b07be5fa"><div class="ttname"><a href="group__cxmap.html#gaacefcf33145d47dcb9439c23b07be5fa">cx_map_find</a></div><div class="ttdeci">cx_map_iterator cx_map_find(const cx_map *map, cxcptr key)</div><div class="ttdoc">Locate an element in the map.</div><div class="ttdef"><b>Definition:</b> cxmap.c:505</div></div>
<div class="ttc" id="agroup__cxmap_html_gac5294a05a8562fc04f1ba110a2e0717b"><div class="ttname"><a href="group__cxmap.html#gac5294a05a8562fc04f1ba110a2e0717b">cx_map_iterator</a></div><div class="ttdeci">cx_tree_iterator cx_map_iterator</div><div class="ttdoc">The map iterator datatype.</div><div class="ttdef"><b>Definition:</b> cxmap.h:49</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
