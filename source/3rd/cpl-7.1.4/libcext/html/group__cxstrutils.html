<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Standard Library Extensions: String Utility Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C Standard Library Extensions
   &#160;<span id="projectnumber">1.2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">String Utility Functions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga371fe36ad7806cbb499dca1ec8607ef2"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#ga371fe36ad7806cbb499dca1ec8607ef2">cx_strcasecmp</a> (const cxchar *s1, const cxchar *s2)</td></tr>
<tr class="memdesc:ga371fe36ad7806cbb499dca1ec8607ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings ignoring the case of ASCII characters.  <a href="group__cxstrutils.html#ga371fe36ad7806cbb499dca1ec8607ef2">More...</a><br /></td></tr>
<tr class="separator:ga371fe36ad7806cbb499dca1ec8607ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9ec225c00d0517c4a8ba2f4668cc08"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#ga1c9ec225c00d0517c4a8ba2f4668cc08">cx_strncasecmp</a> (const cxchar *s1, const cxchar *s2, cxsize n)</td></tr>
<tr class="memdesc:ga1c9ec225c00d0517c4a8ba2f4668cc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the first n characters of two strings ignoring the case of ASCII characters.  <a href="group__cxstrutils.html#ga1c9ec225c00d0517c4a8ba2f4668cc08">More...</a><br /></td></tr>
<tr class="separator:ga1c9ec225c00d0517c4a8ba2f4668cc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga612c00b56334e83f5f043624098afd99"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#ga612c00b56334e83f5f043624098afd99">cx_strempty</a> (const cxchar *string, const cxchar *pattern)</td></tr>
<tr class="memdesc:ga612c00b56334e83f5f043624098afd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a string represents an empty string.  <a href="group__cxstrutils.html#ga612c00b56334e83f5f043624098afd99">More...</a><br /></td></tr>
<tr class="separator:ga612c00b56334e83f5f043624098afd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8afc087f87a757269b9cfd5c939c25c"><td class="memItemLeft" align="right" valign="top">cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#gad8afc087f87a757269b9cfd5c939c25c">cx_strlower</a> (cxchar *s)</td></tr>
<tr class="memdesc:gad8afc087f87a757269b9cfd5c939c25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all uppercase characters in a string into lowercase characters.  <a href="group__cxstrutils.html#gad8afc087f87a757269b9cfd5c939c25c">More...</a><br /></td></tr>
<tr class="separator:gad8afc087f87a757269b9cfd5c939c25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16c5404d48ada9a59bffcfe24f9f3cbc"><td class="memItemLeft" align="right" valign="top">cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#ga16c5404d48ada9a59bffcfe24f9f3cbc">cx_strupper</a> (cxchar *s)</td></tr>
<tr class="memdesc:ga16c5404d48ada9a59bffcfe24f9f3cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all lowercase characters in a string into uppercase characters.  <a href="group__cxstrutils.html#ga16c5404d48ada9a59bffcfe24f9f3cbc">More...</a><br /></td></tr>
<tr class="separator:ga16c5404d48ada9a59bffcfe24f9f3cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6a8fcaade966ed796ca29cbd68e5c9"><td class="memItemLeft" align="right" valign="top">cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#ga1b6a8fcaade966ed796ca29cbd68e5c9">cx_strtrim</a> (cxchar *string)</td></tr>
<tr class="memdesc:ga1b6a8fcaade966ed796ca29cbd68e5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove leading whitespace characters from a string.  <a href="group__cxstrutils.html#ga1b6a8fcaade966ed796ca29cbd68e5c9">More...</a><br /></td></tr>
<tr class="separator:ga1b6a8fcaade966ed796ca29cbd68e5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ef76b8d40146df979c0d1270a3ce872"><td class="memItemLeft" align="right" valign="top">cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#ga2ef76b8d40146df979c0d1270a3ce872">cx_strrtrim</a> (cxchar *string)</td></tr>
<tr class="memdesc:ga2ef76b8d40146df979c0d1270a3ce872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove trailing whitespace characters from a string.  <a href="group__cxstrutils.html#ga2ef76b8d40146df979c0d1270a3ce872">More...</a><br /></td></tr>
<tr class="separator:ga2ef76b8d40146df979c0d1270a3ce872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9003b2c56ddde022716ad99cb2045f7f"><td class="memItemLeft" align="right" valign="top">cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#ga9003b2c56ddde022716ad99cb2045f7f">cx_strstrip</a> (cxchar *string)</td></tr>
<tr class="memdesc:ga9003b2c56ddde022716ad99cb2045f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove leading and trailing whitespace characters from a string.  <a href="group__cxstrutils.html#ga9003b2c56ddde022716ad99cb2045f7f">More...</a><br /></td></tr>
<tr class="separator:ga9003b2c56ddde022716ad99cb2045f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a487bf0b9e11c69bcc34d38a3b00e1"><td class="memItemLeft" align="right" valign="top">cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#ga34a487bf0b9e11c69bcc34d38a3b00e1">cx_strskip</a> (const cxchar *string, int(*ctype)(int))</td></tr>
<tr class="memdesc:ga34a487bf0b9e11c69bcc34d38a3b00e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate the first character in a string that does not belong to a given character class.  <a href="group__cxstrutils.html#ga34a487bf0b9e11c69bcc34d38a3b00e1">More...</a><br /></td></tr>
<tr class="separator:ga34a487bf0b9e11c69bcc34d38a3b00e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5820e4271a2d9bfbad3b5612cfca159"><td class="memItemLeft" align="right" valign="top">cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#gab5820e4271a2d9bfbad3b5612cfca159">cx_strdup</a> (const cxchar *string)</td></tr>
<tr class="memdesc:gab5820e4271a2d9bfbad3b5612cfca159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a string.  <a href="group__cxstrutils.html#gab5820e4271a2d9bfbad3b5612cfca159">More...</a><br /></td></tr>
<tr class="separator:gab5820e4271a2d9bfbad3b5612cfca159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5097161d30fca7aceceafb1267486cfa"><td class="memItemLeft" align="right" valign="top">cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#ga5097161d30fca7aceceafb1267486cfa">cx_strndup</a> (const cxchar *string, cxsize n)</td></tr>
<tr class="memdesc:ga5097161d30fca7aceceafb1267486cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate the first n charactes of a string.  <a href="group__cxstrutils.html#ga5097161d30fca7aceceafb1267486cfa">More...</a><br /></td></tr>
<tr class="separator:ga5097161d30fca7aceceafb1267486cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6e42a2da10486d296fbac13afe2aeee"><td class="memItemLeft" align="right" valign="top">cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#gac6e42a2da10486d296fbac13afe2aeee">cx_strvdupf</a> (const cxchar *format, va_list args)</td></tr>
<tr class="memdesc:gac6e42a2da10486d296fbac13afe2aeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string from a variable-length argument list under format control.  <a href="group__cxstrutils.html#gac6e42a2da10486d296fbac13afe2aeee">More...</a><br /></td></tr>
<tr class="separator:gac6e42a2da10486d296fbac13afe2aeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b272f2e85b372142c5d09d9cada1a7"><td class="memItemLeft" align="right" valign="top">cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#gad5b272f2e85b372142c5d09d9cada1a7">cx_stpcpy</a> (cxchar *dest, const cxchar *src)</td></tr>
<tr class="memdesc:gad5b272f2e85b372142c5d09d9cada1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string returning a pointer to its end.  <a href="group__cxstrutils.html#gad5b272f2e85b372142c5d09d9cada1a7">More...</a><br /></td></tr>
<tr class="separator:gad5b272f2e85b372142c5d09d9cada1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435b2fcd1be708ad7aec8f1523612b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#ga435b2fcd1be708ad7aec8f1523612b8a">cx_strfreev</a> (cxchar **sarray)</td></tr>
<tr class="memdesc:ga435b2fcd1be708ad7aec8f1523612b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate a <code>NULL</code> terminated string array.  <a href="group__cxstrutils.html#ga435b2fcd1be708ad7aec8f1523612b8a">More...</a><br /></td></tr>
<tr class="separator:ga435b2fcd1be708ad7aec8f1523612b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a07380a56b6934e69d0a59324daf9d"><td class="memItemLeft" align="right" valign="top">cxchar **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#ga63a07380a56b6934e69d0a59324daf9d">cx_strsplit</a> (const cxchar *string, const cxchar *delimiter, cxint max_tokens)</td></tr>
<tr class="memdesc:ga63a07380a56b6934e69d0a59324daf9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into pieces at a given delimiter.  <a href="group__cxstrutils.html#ga63a07380a56b6934e69d0a59324daf9d">More...</a><br /></td></tr>
<tr class="separator:ga63a07380a56b6934e69d0a59324daf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga080c5e4cf8f46db99c4fde827f3876ef"><td class="memItemLeft" align="right" valign="top">cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstrutils.html#ga080c5e4cf8f46db99c4fde827f3876ef">cx_strjoinv</a> (const cxchar *separator, cxchar **sarray)</td></tr>
<tr class="memdesc:ga080c5e4cf8f46db99c4fde827f3876ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join strings from an array of strings.  <a href="group__cxstrutils.html#ga080c5e4cf8f46db99c4fde827f3876ef">More...</a><br /></td></tr>
<tr class="separator:ga080c5e4cf8f46db99c4fde827f3876ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The module implements various string-related utility functions suitable for creating, searching and modifying C strings.</p>
<dl class="section user"><dt>Synopsis:</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cxstrutils.h&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad5b272f2e85b372142c5d09d9cada1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b272f2e85b372142c5d09d9cada1a7">&#9670;&nbsp;</a></span>cx_stpcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxchar* cx_stpcpy </td>
          <td>(</td>
          <td class="paramtype">cxchar *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string returning a pointer to its end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Destination string. </td></tr>
    <tr><td class="paramname">src</td><td>Source string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the terminating '\0' of the concatenated string.</dd></dl>
<p>The function copies the string <em>src</em>, including its terminating '\0', to the string <em>dest</em>. The source and the destination string may not overlap and the destination buffer must be large enough to receive the copy. </p>

</div>
</div>
<a id="ga371fe36ad7806cbb499dca1ec8607ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga371fe36ad7806cbb499dca1ec8607ef2">&#9670;&nbsp;</a></span>cx_strcasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_strcasecmp </td>
          <td>(</td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings ignoring the case of ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>First string. </td></tr>
    <tr><td class="paramname">s2</td><td>Second string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer less than, equal to, or greater than zero if <em>s1</em> is found, respectively, to be less than, to match, or be greater than <em>s2</em>.</dd></dl>
<p>The function compares the two strings <em>s1</em> and <em>s2</em> as <b>strcmp()</b> does, but ignores the case of ASCII characters. </p>

<p class="reference">Referenced by <a class="el" href="group__cxstring.html#gaf1405a4f49042e53c06380f32875f901">cx_string_casecmp()</a>.</p>

</div>
</div>
<a id="gab5820e4271a2d9bfbad3b5612cfca159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5820e4271a2d9bfbad3b5612cfca159">&#9670;&nbsp;</a></span>cx_strdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxchar* cx_strdup </td>
          <td>(</td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>String to be duplicated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated copy of the original string.</dd></dl>
<p>Duplicates the input string <em>string</em>. The newly allocated copy returned to the caller can be deallocated using <b><a class="el" href="group__cxmemory.html#ga535a509573c6617da8f0dccdb2710bc9" title="Memory block deallocation.">cx_free()</a></b>. </p>

<p class="reference">Referenced by <a class="el" href="group__cxutils.html#ga0864ab11701a3596082a3317d94dddf9">cx_vasprintf()</a>.</p>

</div>
</div>
<a id="ga612c00b56334e83f5f043624098afd99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga612c00b56334e83f5f043624098afd99">&#9670;&nbsp;</a></span>cx_strempty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_strempty </td>
          <td>(</td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a string represents an empty string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>String to be tested. </td></tr>
    <tr><td class="paramname">pattern</td><td>String containing all allowed comment characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns 1 if the string is found to be empty or if the first non&ndash;whitespace character is one out of the set of provided comment characters. Otherwise the function returns 0.</dd></dl>
<p>The function skips all leading whitespace characters in the string <em>string</em>. Whitespace characters are recognized by <b>isspace()</b>. If the first character which is not a whitespace character is either '\0' or one out of the pattern string <em>pattern</em>, the string is considered as empty and the function returns 1.</p>
<p>If <em>pattern</em> is set to <code>NULL</code> there is no checking for special characters that should be considered as whitespaces. </p>

</div>
</div>
<a id="ga435b2fcd1be708ad7aec8f1523612b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga435b2fcd1be708ad7aec8f1523612b8a">&#9670;&nbsp;</a></span>cx_strfreev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_strfreev </td>
          <td>(</td>
          <td class="paramtype">cxchar **&#160;</td>
          <td class="paramname"><em>sarray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate a <code>NULL</code> terminated string array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sarray</td><td>String array to deallocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function deallocates the array of strings <em>sarray</em> and any string it possibly contains. </p>

<p class="reference">References <a class="el" href="group__cxmemory.html#ga535a509573c6617da8f0dccdb2710bc9">cx_free()</a>.</p>

</div>
</div>
<a id="ga080c5e4cf8f46db99c4fde827f3876ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga080c5e4cf8f46db99c4fde827f3876ef">&#9670;&nbsp;</a></span>cx_strjoinv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxchar* cx_strjoinv </td>
          <td>(</td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxchar **&#160;</td>
          <td class="paramname"><em>sarray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join strings from an array of strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>Optional separator string. </td></tr>
    <tr><td class="paramname">sarray</td><td>Array of strings to join.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated string containing the joined input strings separated by <em>separator</em>, or <code>NULL</code> in case of error.</dd></dl>
<p>The function builds a single string from the strings referenced by <em>sarray</em>. The array of input strings <em>sarray</em> has to be <code>NULL</code> terminated. Optionally, a separator string can be passed through <em>separator</em> which will then be inserted between two strings. If no separator should be inserted when joining, <em>separator</em> must be set to <code>NULL</code>. </p>

<p class="reference">References <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab">cx_malloc()</a>.</p>

</div>
</div>
<a id="gad8afc087f87a757269b9cfd5c939c25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8afc087f87a757269b9cfd5c939c25c">&#9670;&nbsp;</a></span>cx_strlower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxchar* cx_strlower </td>
          <td>(</td>
          <td class="paramtype">cxchar *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all uppercase characters in a string into lowercase characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the converted string.</dd></dl>
<p>Walks through the given string and turns uppercase characters into lowercase characters using <b>tolower()</b>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxstrutils.html#ga16c5404d48ada9a59bffcfe24f9f3cbc" title="Convert all lowercase characters in a string into uppercase characters.">cx_strupper()</a> </dd></dl>

</div>
</div>
<a id="ga1c9ec225c00d0517c4a8ba2f4668cc08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c9ec225c00d0517c4a8ba2f4668cc08">&#9670;&nbsp;</a></span>cx_strncasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_strncasecmp </td>
          <td>(</td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxsize&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the first n characters of two strings ignoring the case of ASCII characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>First string. </td></tr>
    <tr><td class="paramname">s2</td><td>Second string. </td></tr>
    <tr><td class="paramname">n</td><td>Number of characters to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer less than, equal to, or greater than zero if the first <em>n</em> characters of <em>s1</em> are found, respectively, to be less than, to match, or be greater than the first <em>n</em> characters of <em>s2</em>.</dd></dl>
<p>The function compares the first <em>n</em> characters of the two strings <em>s1</em> and <em>s2</em> as <b>strncmp()</b> does, but ignores the case of ASCII characters. </p>

<p class="reference">Referenced by <a class="el" href="group__cxstring.html#gaf0c12330806814bce631fdc121c8283b">cx_string_ncasecmp()</a>.</p>

</div>
</div>
<a id="ga5097161d30fca7aceceafb1267486cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5097161d30fca7aceceafb1267486cfa">&#9670;&nbsp;</a></span>cx_strndup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxchar* cx_strndup </td>
          <td>(</td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxsize&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate the first n charactes of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>Source string </td></tr>
    <tr><td class="paramname">n</td><td>Maximum number of characters to be duplicated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated copy of the first <em>n</em> characters of <em>string</em>.</dd></dl>
<p>Duplicates the first <em>n</em> characters of the source string <em>string</em>, returning the copied characters in newly allocated string of the size <em>n</em> + 1. The returned string is always null terminated. If the length of <em>string</em> is less than <em>n</em> the returned string is padded with nulls. The newly allocated string can be deallocated using <b><a class="el" href="group__cxmemory.html#ga535a509573c6617da8f0dccdb2710bc9" title="Memory block deallocation.">cx_free()</a></b>. </p>

<p class="reference">References <a class="el" href="group__cxmemory.html#gad6e24975b7161a4d3f5fe49fd84df740">cx_calloc()</a>.</p>

</div>
</div>
<a id="ga2ef76b8d40146df979c0d1270a3ce872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ef76b8d40146df979c0d1270a3ce872">&#9670;&nbsp;</a></span>cx_strrtrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxchar* cx_strrtrim </td>
          <td>(</td>
          <td class="paramtype">cxchar *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove trailing whitespace characters from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>String to be processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns a pointer to the modified string if no error occurred, otherwise <code>NULL</code>.</dd></dl>
<p>The function removes trailing whitespace characters, or from the string <em>string</em>. Whitespace characters are recognized by <b>isspace()</b>. </p>

</div>
</div>
<a id="ga34a487bf0b9e11c69bcc34d38a3b00e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34a487bf0b9e11c69bcc34d38a3b00e1">&#9670;&nbsp;</a></span>cx_strskip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxchar* cx_strskip </td>
          <td>(</td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int)&#160;</td>
          <td class="paramname"><em>ctype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate the first character in a string that does not belong to a given character class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>String to be processed. </td></tr>
    <tr><td class="paramname">ctype</td><td>Character class test function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first character that is not a member of the character class described by <em>ctype</em>.</dd></dl>
<p>Searches the string <em>string</em> for the first occurence of a character which does not belong to a certain character class. The character class is represented through a function that returns a non zero value if a character belongs to that class and 0 otherwise. Such functions are the character classification routines like <b>isspace()</b> for instance. It is expected that the input string is properly terminated. In case the whole string consists of characters of the specified class the function will return the location of the terminating '\0'. </p>

</div>
</div>
<a id="ga63a07380a56b6934e69d0a59324daf9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63a07380a56b6934e69d0a59324daf9d">&#9670;&nbsp;</a></span>cx_strsplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxchar** cx_strsplit </td>
          <td>(</td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxint&#160;</td>
          <td class="paramname"><em>max_tokens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into pieces at a given delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to split. </td></tr>
    <tr><td class="paramname">delimiter</td><td>String specifying the locations where to split. </td></tr>
    <tr><td class="paramname">max_tokens</td><td>The maximum number of tokens the string is split into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns a newly allocated, <code>NULL</code> terminated array of strings, or <code>NULL</code> in case of an error.</dd></dl>
<p>The function breaks up the string <em>string</em> into, at most, <em>max_tokens</em> pieces at the places indicated by <em>delimiter</em>. If <em>max_tokens</em> is reached, the remainder of the string is appended to the last token. If <em>max_tokens</em> is less than 1 the string <em>string</em> is split completely.</p>
<p>The delimiter string <em>delimiter</em> never shows up in any of the resulting strings, unless <em>max_tokens</em> is reached.</p>
<p>As a special case, the result of splitting the empty string "" is an empty vector, not a vector containing a single string.</p>
<p>The created result vector can be deallocated using <b><a class="el" href="group__cxstrutils.html#ga435b2fcd1be708ad7aec8f1523612b8a" title="Deallocate a NULL terminated string array.">cx_strfreev()</a></b>. </p>

<p class="reference">References <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab">cx_malloc()</a>, <a class="el" href="group__cxslist.html#gacbeb18632065ead0f8d196264040a485">cx_slist_new()</a>, and <a class="el" href="group__cxslist.html#gaf7015e5460f7565302254a3207ba84a9">cx_slist_push_front()</a>.</p>

</div>
</div>
<a id="ga9003b2c56ddde022716ad99cb2045f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9003b2c56ddde022716ad99cb2045f7f">&#9670;&nbsp;</a></span>cx_strstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxchar* cx_strstrip </td>
          <td>(</td>
          <td class="paramtype">cxchar *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove leading and trailing whitespace characters from a string. </p>
<dl class="section return"><dt>Returns</dt><dd>The function returns a pointer to the modified string if no error occurred, otherwise <code>NULL</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>String to be processed.</td></tr>
  </table>
  </dd>
</dl>
<p>The function removes leading and trailing whitespace characters from the string <em>string</em>. Whitespace characters are recognized by <b>isspace()</b>. </p>

</div>
</div>
<a id="ga1b6a8fcaade966ed796ca29cbd68e5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b6a8fcaade966ed796ca29cbd68e5c9">&#9670;&nbsp;</a></span>cx_strtrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxchar* cx_strtrim </td>
          <td>(</td>
          <td class="paramtype">cxchar *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove leading whitespace characters from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>String to be processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns a pointer to the modified string if no error occurred, otherwise <code>NULL</code>.</dd></dl>
<p>The function removes leading whitespace characters, or from the string <em>string</em>. Whitespace characters are recognized by <b>isspace()</b>. </p>

</div>
</div>
<a id="ga16c5404d48ada9a59bffcfe24f9f3cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16c5404d48ada9a59bffcfe24f9f3cbc">&#9670;&nbsp;</a></span>cx_strupper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxchar* cx_strupper </td>
          <td>(</td>
          <td class="paramtype">cxchar *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all lowercase characters in a string into uppercase characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the converted string.</dd></dl>
<p>Walks through the given string and turns lowercase characters into uppercase characters using <b>toupper()</b>.</p>
<dl class="section see"><dt>See also</dt><dd>strlower() </dd></dl>

</div>
</div>
<a id="gac6e42a2da10486d296fbac13afe2aeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6e42a2da10486d296fbac13afe2aeee">&#9670;&nbsp;</a></span>cx_strvdupf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxchar* cx_strvdupf </td>
          <td>(</td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string from a variable-length argument list under format control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The format string. </td></tr>
    <tr><td class="paramname">args</td><td>Variable-length arguments to be inserted into <em>format</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An newly allocated string containing the formatted result.</dd></dl>
<p>The function is similar to <b>vsprintf()</b> but calculates the size needed to store the formatted result string and allocates the memory. The newly allocated string can be deallocated using <b><a class="el" href="group__cxmemory.html#ga535a509573c6617da8f0dccdb2710bc9" title="Memory block deallocation.">cx_free()</a></b>. </p>

<p class="reference">References <a class="el" href="group__cxutils.html#ga0864ab11701a3596082a3317d94dddf9">cx_vasprintf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cxmessages.html#ga61bf6d7fbd22c7eaabc33028aae024f7">cx_print()</a>, and <a class="el" href="group__cxmessages.html#gadce1cff77bbf105e15da2c3fc1c9caec">cx_printerr()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
