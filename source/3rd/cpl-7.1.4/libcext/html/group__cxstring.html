<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Standard Library Extensions: Strings</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C Standard Library Extensions
   &#160;<span id="projectnumber">1.2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Strings</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga48dfca37e3a62f7fe98edc3f38c0faeb"><td class="memItemLeft" align="right" valign="top"><a id="ga48dfca37e3a62f7fe98edc3f38c0faeb"></a>
typedef struct _cx_string_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a></td></tr>
<tr class="memdesc:ga48dfca37e3a62f7fe98edc3f38c0faeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cx_string data type. <br /></td></tr>
<tr class="separator:ga48dfca37e3a62f7fe98edc3f38c0faeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2677bfd02e0324dcaf6a16146cc5d613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga2677bfd02e0324dcaf6a16146cc5d613">cx_string_new</a> (void)</td></tr>
<tr class="memdesc:ga2677bfd02e0324dcaf6a16146cc5d613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, empty string container.  <a href="group__cxstring.html#ga2677bfd02e0324dcaf6a16146cc5d613">More...</a><br /></td></tr>
<tr class="separator:ga2677bfd02e0324dcaf6a16146cc5d613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga173e094b6b10810d3b9b0891012d50a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga173e094b6b10810d3b9b0891012d50a4">cx_string_copy</a> (const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self)</td></tr>
<tr class="memdesc:ga173e094b6b10810d3b9b0891012d50a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy a cx_string.  <a href="group__cxstring.html#ga173e094b6b10810d3b9b0891012d50a4">More...</a><br /></td></tr>
<tr class="separator:ga173e094b6b10810d3b9b0891012d50a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21504ed4cde96fd5233167f09d90872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gae21504ed4cde96fd5233167f09d90872">cx_string_create</a> (const cxchar *value)</td></tr>
<tr class="memdesc:gae21504ed4cde96fd5233167f09d90872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string from a standard C string.  <a href="group__cxstring.html#gae21504ed4cde96fd5233167f09d90872">More...</a><br /></td></tr>
<tr class="separator:gae21504ed4cde96fd5233167f09d90872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c9522f40844cecd8aa31a537d594a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga7c9522f40844cecd8aa31a537d594a73">cx_string_delete</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self)</td></tr>
<tr class="memdesc:ga7c9522f40844cecd8aa31a537d594a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a string.  <a href="group__cxstring.html#ga7c9522f40844cecd8aa31a537d594a73">More...</a><br /></td></tr>
<tr class="separator:ga7c9522f40844cecd8aa31a537d594a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62f3f0eaf0a991913c826d2fb36c8c2"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gad62f3f0eaf0a991913c826d2fb36c8c2">cx_string_size</a> (const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self)</td></tr>
<tr class="memdesc:gad62f3f0eaf0a991913c826d2fb36c8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the length of the string.  <a href="group__cxstring.html#gad62f3f0eaf0a991913c826d2fb36c8c2">More...</a><br /></td></tr>
<tr class="separator:gad62f3f0eaf0a991913c826d2fb36c8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab302e36ebde49a78e387bda399762faa"><td class="memItemLeft" align="right" valign="top">cxbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gab302e36ebde49a78e387bda399762faa">cx_string_empty</a> (const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self)</td></tr>
<tr class="memdesc:gab302e36ebde49a78e387bda399762faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a string contains any characters.  <a href="group__cxstring.html#gab302e36ebde49a78e387bda399762faa">More...</a><br /></td></tr>
<tr class="separator:gab302e36ebde49a78e387bda399762faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga745c3e5f86abb0e9e64c3a4fa785c1de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga745c3e5f86abb0e9e64c3a4fa785c1de">cx_string_set</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, const cxchar *data)</td></tr>
<tr class="memdesc:ga745c3e5f86abb0e9e64c3a4fa785c1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a value to a string.  <a href="group__cxstring.html#ga745c3e5f86abb0e9e64c3a4fa785c1de">More...</a><br /></td></tr>
<tr class="separator:ga745c3e5f86abb0e9e64c3a4fa785c1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90d4fbf5e229be5dcbd05a83c4fa547a"><td class="memItemLeft" align="right" valign="top">const cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga90d4fbf5e229be5dcbd05a83c4fa547a">cx_string_get</a> (const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self)</td></tr>
<tr class="memdesc:ga90d4fbf5e229be5dcbd05a83c4fa547a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string's value.  <a href="group__cxstring.html#ga90d4fbf5e229be5dcbd05a83c4fa547a">More...</a><br /></td></tr>
<tr class="separator:ga90d4fbf5e229be5dcbd05a83c4fa547a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c8b03637f4a99432f40b200bcd9bd0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga8c8b03637f4a99432f40b200bcd9bd0a">cx_string_upper</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self)</td></tr>
<tr class="memdesc:ga8c8b03637f4a99432f40b200bcd9bd0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the string into uppercase.  <a href="group__cxstring.html#ga8c8b03637f4a99432f40b200bcd9bd0a">More...</a><br /></td></tr>
<tr class="separator:ga8c8b03637f4a99432f40b200bcd9bd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad99ff4d8cec308e5b7319f969f0330c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gad99ff4d8cec308e5b7319f969f0330c0">cx_string_lower</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self)</td></tr>
<tr class="memdesc:gad99ff4d8cec308e5b7319f969f0330c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the string into lowercase.  <a href="group__cxstring.html#gad99ff4d8cec308e5b7319f969f0330c0">More...</a><br /></td></tr>
<tr class="separator:gad99ff4d8cec308e5b7319f969f0330c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad38326b29c82dcdc93bfb3252f3c9f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gad38326b29c82dcdc93bfb3252f3c9f49">cx_string_trim</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self)</td></tr>
<tr class="memdesc:gad38326b29c82dcdc93bfb3252f3c9f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove leading whitespaces from the string.  <a href="group__cxstring.html#gad38326b29c82dcdc93bfb3252f3c9f49">More...</a><br /></td></tr>
<tr class="separator:gad38326b29c82dcdc93bfb3252f3c9f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a22caf2e7286730e882170cf4a6fe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gae7a22caf2e7286730e882170cf4a6fe3">cx_string_rtrim</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self)</td></tr>
<tr class="memdesc:gae7a22caf2e7286730e882170cf4a6fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove trailing whitespaces from the string.  <a href="group__cxstring.html#gae7a22caf2e7286730e882170cf4a6fe3">More...</a><br /></td></tr>
<tr class="separator:gae7a22caf2e7286730e882170cf4a6fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c1ed2a92a736ed8900101cdfbd3ce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gad1c1ed2a92a736ed8900101cdfbd3ce7">cx_string_strip</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self)</td></tr>
<tr class="memdesc:gad1c1ed2a92a736ed8900101cdfbd3ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove leading and trailing whitespaces from the string.  <a href="group__cxstring.html#gad1c1ed2a92a736ed8900101cdfbd3ce7">More...</a><br /></td></tr>
<tr class="separator:gad1c1ed2a92a736ed8900101cdfbd3ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5255beabea7b5da62d4d2bf7bf6a27ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga5255beabea7b5da62d4d2bf7bf6a27ad">cx_string_prepend</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, const cxchar *data)</td></tr>
<tr class="memdesc:ga5255beabea7b5da62d4d2bf7bf6a27ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend an array of characters to the string.  <a href="group__cxstring.html#ga5255beabea7b5da62d4d2bf7bf6a27ad">More...</a><br /></td></tr>
<tr class="separator:ga5255beabea7b5da62d4d2bf7bf6a27ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5488378ca5476e1402fa9ac880c5c2e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga5488378ca5476e1402fa9ac880c5c2e6">cx_string_append</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, const cxchar *data)</td></tr>
<tr class="memdesc:ga5488378ca5476e1402fa9ac880c5c2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an array of characters to the string.  <a href="group__cxstring.html#ga5488378ca5476e1402fa9ac880c5c2e6">More...</a><br /></td></tr>
<tr class="separator:ga5488378ca5476e1402fa9ac880c5c2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9916cdc9590244f118ee8d82d88f576"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gaa9916cdc9590244f118ee8d82d88f576">cx_string_insert</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, cxssize position, const cxchar *data)</td></tr>
<tr class="memdesc:gaa9916cdc9590244f118ee8d82d88f576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a copy of a string at a given position.  <a href="group__cxstring.html#gaa9916cdc9590244f118ee8d82d88f576">More...</a><br /></td></tr>
<tr class="separator:gaa9916cdc9590244f118ee8d82d88f576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac36b30ef4a5fa1036a333964db2ddbd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gac36b30ef4a5fa1036a333964db2ddbd0">cx_string_erase</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, cxssize position, cxssize length)</td></tr>
<tr class="memdesc:gac36b30ef4a5fa1036a333964db2ddbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a portion of the string.  <a href="group__cxstring.html#gac36b30ef4a5fa1036a333964db2ddbd0">More...</a><br /></td></tr>
<tr class="separator:gac36b30ef4a5fa1036a333964db2ddbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga871347bfc5e8a5beacf9864b250e0fc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga871347bfc5e8a5beacf9864b250e0fc0">cx_string_truncate</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, cxsize length)</td></tr>
<tr class="memdesc:ga871347bfc5e8a5beacf9864b250e0fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate the string.  <a href="group__cxstring.html#ga871347bfc5e8a5beacf9864b250e0fc0">More...</a><br /></td></tr>
<tr class="separator:ga871347bfc5e8a5beacf9864b250e0fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfb7b87860630a2170ca42f81fdca313"><td class="memItemLeft" align="right" valign="top">cxbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gabfb7b87860630a2170ca42f81fdca313">cx_string_equal</a> (const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *string1, const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *string2)</td></tr>
<tr class="memdesc:gabfb7b87860630a2170ca42f81fdca313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two cx_string for equality.  <a href="group__cxstring.html#gabfb7b87860630a2170ca42f81fdca313">More...</a><br /></td></tr>
<tr class="separator:gabfb7b87860630a2170ca42f81fdca313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga369142333463cf53a883641d6188add9"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga369142333463cf53a883641d6188add9">cx_string_compare</a> (const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *string1, const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *string2)</td></tr>
<tr class="memdesc:ga369142333463cf53a883641d6188add9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings.  <a href="group__cxstring.html#ga369142333463cf53a883641d6188add9">More...</a><br /></td></tr>
<tr class="separator:ga369142333463cf53a883641d6188add9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1405a4f49042e53c06380f32875f901"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gaf1405a4f49042e53c06380f32875f901">cx_string_casecmp</a> (const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *string1, const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *string2)</td></tr>
<tr class="memdesc:gaf1405a4f49042e53c06380f32875f901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings ignoring the case of characters.  <a href="group__cxstring.html#gaf1405a4f49042e53c06380f32875f901">More...</a><br /></td></tr>
<tr class="separator:gaf1405a4f49042e53c06380f32875f901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c12330806814bce631fdc121c8283b"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gaf0c12330806814bce631fdc121c8283b">cx_string_ncasecmp</a> (const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *string1, const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *string2, cxsize n)</td></tr>
<tr class="memdesc:gaf0c12330806814bce631fdc121c8283b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the first n characters of two strings ignoring the case of characters.  <a href="group__cxstring.html#gaf0c12330806814bce631fdc121c8283b">More...</a><br /></td></tr>
<tr class="separator:gaf0c12330806814bce631fdc121c8283b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29362244440619a3d7090259c7549585"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga29362244440619a3d7090259c7549585">cx_string_sprintf</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, const char *format,...)</td></tr>
<tr class="memdesc:ga29362244440619a3d7090259c7549585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to a string under format control.  <a href="group__cxstring.html#ga29362244440619a3d7090259c7549585">More...</a><br /></td></tr>
<tr class="separator:ga29362244440619a3d7090259c7549585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27c9339137a6f0b90cb93cb0bbd1c476"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga27c9339137a6f0b90cb93cb0bbd1c476">cx_string_vsprintf</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, const cxchar *format, va_list args)</td></tr>
<tr class="memdesc:ga27c9339137a6f0b90cb93cb0bbd1c476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the string from a variable-length argument list under format control.  <a href="group__cxstring.html#ga27c9339137a6f0b90cb93cb0bbd1c476">More...</a><br /></td></tr>
<tr class="separator:ga27c9339137a6f0b90cb93cb0bbd1c476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f190519bb7e5497c088cf8a60f2856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gac7f190519bb7e5497c088cf8a60f2856">cx_string_print</a> (const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *string)</td></tr>
<tr class="memdesc:gac7f190519bb7e5497c088cf8a60f2856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the value of a cx_string to the standard output.  <a href="group__cxstring.html#gac7f190519bb7e5497c088cf8a60f2856">More...</a><br /></td></tr>
<tr class="separator:gac7f190519bb7e5497c088cf8a60f2856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f129f15130f4e8e06c82c44a58d0663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga2f129f15130f4e8e06c82c44a58d0663">cx_string_replace_character</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, cxsize start, cxsize end, cxchar old_value, cxchar new_value)</td></tr>
<tr class="memdesc:ga2f129f15130f4e8e06c82c44a58d0663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a given character with a new character in a portion of a string.  <a href="group__cxstring.html#ga2f129f15130f4e8e06c82c44a58d0663">More...</a><br /></td></tr>
<tr class="separator:ga2f129f15130f4e8e06c82c44a58d0663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga379950ddc09f3785959e5765b3d91223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga379950ddc09f3785959e5765b3d91223">cx_string_resize</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, cxsize size, cxchar c)</td></tr>
<tr class="memdesc:ga379950ddc09f3785959e5765b3d91223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a string to a given length.  <a href="group__cxstring.html#ga379950ddc09f3785959e5765b3d91223">More...</a><br /></td></tr>
<tr class="separator:ga379950ddc09f3785959e5765b3d91223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae73fda53dad0d22b93eb0b21bdb30ef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gae73fda53dad0d22b93eb0b21bdb30ef8">cx_string_extend</a> (<a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, cxsize size, cxchar c)</td></tr>
<tr class="memdesc:gae73fda53dad0d22b93eb0b21bdb30ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend a string to a given length.  <a href="group__cxstring.html#gae73fda53dad0d22b93eb0b21bdb30ef8">More...</a><br /></td></tr>
<tr class="separator:gae73fda53dad0d22b93eb0b21bdb30ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad945ea3ce10ac659d45564ee9da3927e"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gad945ea3ce10ac659d45564ee9da3927e">cx_string_find_first_not_of</a> (const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, const cxchar *characters)</td></tr>
<tr class="memdesc:gad945ea3ce10ac659d45564ee9da3927e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string for the first character that does not match any of the given characters.  <a href="group__cxstring.html#gad945ea3ce10ac659d45564ee9da3927e">More...</a><br /></td></tr>
<tr class="separator:gad945ea3ce10ac659d45564ee9da3927e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae5e670c5c4942c41061865427d0317"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#ga4ae5e670c5c4942c41061865427d0317">cx_string_find_last_not_of</a> (const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, const cxchar *characters)</td></tr>
<tr class="memdesc:ga4ae5e670c5c4942c41061865427d0317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a string for the last character that does not match any of the given characters.  <a href="group__cxstring.html#ga4ae5e670c5c4942c41061865427d0317">More...</a><br /></td></tr>
<tr class="separator:ga4ae5e670c5c4942c41061865427d0317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c9f69afcebd0ef57d3e5a79fa221ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxstring.html#gad1c9f69afcebd0ef57d3e5a79fa221ac">cx_string_substr</a> (const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *self, cxsize pos, cxsize len)</td></tr>
<tr class="memdesc:gad1c9f69afcebd0ef57d3e5a79fa221ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string from a portion of a string.  <a href="group__cxstring.html#gad1c9f69afcebd0ef57d3e5a79fa221ac">More...</a><br /></td></tr>
<tr class="separator:gad1c9f69afcebd0ef57d3e5a79fa221ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A <b>cx_string</b> is similar to a standard C string, except that it grows automatically as text is appended or inserted. The character data the string contains is '\0' terminated in order to guarantee full compatibility with string utility functions processing standard C strings. Together with the character data it also stores the length of the string. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5488378ca5476e1402fa9ac880c5c2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5488378ca5476e1402fa9ac880c5c2e6">&#9670;&nbsp;</a></span>cx_string_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an array of characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to character array to be appended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed string <em>self</em> with the characters appended, or <code>NULL</code> in case of errors.</dd></dl>
<p>The function adds the contents of the character buffer <em>data</em> to the end of the string. If <em>data</em> is a <code>NULL</code> pointer the string <em>self</em> is not modified. </p>

<p class="reference">References <a class="el" href="group__cxmemory.html#ga535a509573c6617da8f0dccdb2710bc9">cx_free()</a>, and <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab">cx_malloc()</a>.</p>

</div>
</div>
<a id="gaf1405a4f49042e53c06380f32875f901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1405a4f49042e53c06380f32875f901">&#9670;&nbsp;</a></span>cx_string_casecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_string_casecmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>string1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>string2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings ignoring the case of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string1</td><td>First cx_string. </td></tr>
    <tr><td class="paramname">string2</td><td>Second cx_string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns an interger less than, equal to, or greater than <code>0</code> if <em>string1</em> is found, respectively, to be less than, to match, or to be greater than <em>string2</em>.</dd></dl>
<p>The function compares <em>string2</em> with <em>string</em> in the same way as the standard C function <b>strcmp()</b> does, but ignores the case of ASCII characters. </p>

<p class="reference">References <a class="el" href="group__cxstrutils.html#ga371fe36ad7806cbb499dca1ec8607ef2">cx_strcasecmp()</a>.</p>

</div>
</div>
<a id="ga369142333463cf53a883641d6188add9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga369142333463cf53a883641d6188add9">&#9670;&nbsp;</a></span>cx_string_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_string_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>string1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>string2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string1</td><td>First cx_string. </td></tr>
    <tr><td class="paramname">string2</td><td>Second cx_string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns an interger less than, equal to, or greater than <code>0</code> if <em>string1</em> is found, respectively, to be less than, to match, or to be greater than <em>string2</em>.</dd></dl>
<p>The function compares <em>string2</em> with <em>string</em> in the same way as the standard C function <b>strcmp()</b> does. </p>

</div>
</div>
<a id="ga173e094b6b10810d3b9b0891012d50a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga173e094b6b10810d3b9b0891012d50a4">&#9670;&nbsp;</a></span>cx_string_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy a cx_string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly created copy of <em>string</em>. </dd></dl>

</div>
</div>
<a id="gae21504ed4cde96fd5233167f09d90872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae21504ed4cde96fd5233167f09d90872">&#9670;&nbsp;</a></span>cx_string_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_create </td>
          <td>(</td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string from a standard C string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The initial text to copy into the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to newly created string.</dd></dl>
<p>A new string is created and the text <em>value</em> is initially copied into the string. </p>

<p class="reference">Referenced by <a class="el" href="group__cxstring.html#gad1c9f69afcebd0ef57d3e5a79fa221ac">cx_string_substr()</a>.</p>

</div>
</div>
<a id="ga7c9522f40844cecd8aa31a537d594a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c9522f40844cecd8aa31a537d594a73">&#9670;&nbsp;</a></span>cx_string_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_string_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function deallocates <em>string's</em> character buffer and finally frees the memory allocated for <em>string</em> itself. </p>

</div>
</div>
<a id="gab302e36ebde49a78e387bda399762faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab302e36ebde49a78e387bda399762faa">&#9670;&nbsp;</a></span>cx_string_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxbool cx_string_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a string contains any characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns TRUE if the string is empty, or FALSE otherwise.</dd></dl>
<p>A string is considered to be empty if its size is 0 or if it has not been initialized, i.e. no value has been assigned yet. </p>

</div>
</div>
<a id="gabfb7b87860630a2170ca42f81fdca313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfb7b87860630a2170ca42f81fdca313">&#9670;&nbsp;</a></span>cx_string_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxbool cx_string_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>string1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>string2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two cx_string for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string1</td><td>First cx_string. </td></tr>
    <tr><td class="paramname">string2</td><td>Second cx_string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if equal, FALSE if not.</dd></dl>
<p>The function checks whether two strings are equal. Two strings are equal if their values match on a character by character basis. </p>

</div>
</div>
<a id="gac36b30ef4a5fa1036a333964db2ddbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac36b30ef4a5fa1036a333964db2ddbd0">&#9670;&nbsp;</a></span>cx_string_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxssize&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxssize&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a portion of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string. </td></tr>
    <tr><td class="paramname">position</td><td>Position of the first character to be erased. </td></tr>
    <tr><td class="paramname">length</td><td>Number of characters to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed string <em>self</em> with the characters removed, or <code>NULL</code> in case of errors.</dd></dl>
<p>The function removes <em>length</em> characters from the string starting at the character index <em>position</em>. The number of characters to be removed is inclusive the character at index <em>position</em>. The characters following the removed portion are shifted to fill the gap. Character positions start counting from 0.</p>
<p>If the number of characters to erase <em>length</em> is less the <code>0</code> all characters starting at <em>position</em> up to the end of the string are erased. </p>

<p class="reference">References <a class="el" href="group__cxmemory.html#ga535a509573c6617da8f0dccdb2710bc9">cx_free()</a>, and <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab">cx_malloc()</a>.</p>

</div>
</div>
<a id="gae73fda53dad0d22b93eb0b21bdb30ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae73fda53dad0d22b93eb0b21bdb30ef8">&#9670;&nbsp;</a></span>cx_string_extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_string_extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxchar&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extend a string to a given length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A cx_string. </td></tr>
    <tr><td class="paramname">size</td><td>The number of characters by which the string is enlarged. </td></tr>
    <tr><td class="paramname">c</td><td>The character used to fill the new character space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function extends a string by adding to its end <em>size</em> number of of characters. The added characters are initialized with the character <em>c</em>.</p>
<p>Extending a string with zero characters leaves the string untouched.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxstring.html#ga379950ddc09f3785959e5765b3d91223" title="Resize a string to a given length.">cx_string_resize()</a> </dd></dl>

<p class="reference">References <a class="el" href="group__cxmemory.html#gad6e24975b7161a4d3f5fe49fd84df740">cx_calloc()</a>, and <a class="el" href="group__cxmemory.html#ga535a509573c6617da8f0dccdb2710bc9">cx_free()</a>.</p>

</div>
</div>
<a id="gad945ea3ce10ac659d45564ee9da3927e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad945ea3ce10ac659d45564ee9da3927e">&#9670;&nbsp;</a></span>cx_string_find_first_not_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_string_find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>characters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search a string for the first character that does not match any of the given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A string. </td></tr>
    <tr><td class="paramname">characters</td><td>Another string with a set of characters to be used in the search of the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the position of the first character that does not match, or the position one past the last element of the string(i.e. the current size of the string) if no such character exists.</dd></dl>
<p>The function searches the given string for the first character that does not match any of the characters specified in the set of characters <em>characters</em>. </p>

</div>
</div>
<a id="ga4ae5e670c5c4942c41061865427d0317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ae5e670c5c4942c41061865427d0317">&#9670;&nbsp;</a></span>cx_string_find_last_not_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_string_find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>characters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search a string for the last character that does not match any of the given characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A string. </td></tr>
    <tr><td class="paramname">characters</td><td>Another string with a set of characters to be used in the search of the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the position of the last character that does not match, or the position one past the last element of the string(i.e. the current size of the string) if no such character exists.</dd></dl>
<p>The function searches the given string for the last character that does not match any of the characters specified in the set of characters <em>characters</em>. </p>

</div>
</div>
<a id="ga90d4fbf5e229be5dcbd05a83c4fa547a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90d4fbf5e229be5dcbd05a83c4fa547a">&#9670;&nbsp;</a></span>cx_string_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cxchar* cx_string_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string's value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant pointer to the string's <em>data</em> member, or <code>NULL</code> if the string is uninitialized.</dd></dl>
<p>A pointer to the strings character data. The character array pointed to by this pointer is an standard C string, i.e. '\0' terminated and can be used together with any string processing function from the standard C library (but see below).</p>
<dl class="section warning"><dt>Warning</dt><dd>The string's data <b>must</b> <b>not</b> be modified using the returned pointer, otherwise the internal consistency may be lost. </dd></dl>

</div>
</div>
<a id="gaa9916cdc9590244f118ee8d82d88f576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9916cdc9590244f118ee8d82d88f576">&#9670;&nbsp;</a></span>cx_string_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxssize&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a copy of a string at a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string. </td></tr>
    <tr><td class="paramname">position</td><td>Character position at which the data is inserted. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to character array to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed string <em>self</em> with the characters inserted, or <code>NULL</code> in case of errors.</dd></dl>
<p>The function inserts the contents of the character buffer <em>data</em> at the character index <em>position</em> into the string, expanding the string if necessary. Character positions start counting from 0. If <em>data</em> is a <code>NULL</code> pointer the string <em>self</em> is not modified. </p>

<p class="reference">References <a class="el" href="group__cxmemory.html#ga535a509573c6617da8f0dccdb2710bc9">cx_free()</a>, and <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab">cx_malloc()</a>.</p>

</div>
</div>
<a id="gad99ff4d8cec308e5b7319f969f0330c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad99ff4d8cec308e5b7319f969f0330c0">&#9670;&nbsp;</a></span>cx_string_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the string into lowercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed string <em>self</em> with all characters converted to lowercase, or <code>NULL</code> in case of errors.</dd></dl>
<p>All uppercase letters stored in the string are converted to lowercase letters. The conversion is done using the standard C function <b>tolower()</b>. </p>

</div>
</div>
<a id="gaf0c12330806814bce631fdc121c8283b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c12330806814bce631fdc121c8283b">&#9670;&nbsp;</a></span>cx_string_ncasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_string_ncasecmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>string1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>string2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxsize&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the first n characters of two strings ignoring the case of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string1</td><td>First string. </td></tr>
    <tr><td class="paramname">string2</td><td>Second string. </td></tr>
    <tr><td class="paramname">n</td><td>Number of characters to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer less than, equal to, or greater than zero if the first <em>n</em> characters of <em>string1</em> are found, respectively, to be less than, to match, or be greater than the first <em>n</em> characters of <em>string2</em>.</dd></dl>
<p>The function compares the first <em>n</em> characters of the two strings <em>string1</em> and <em>string2</em> as <b>strncmp()</b> does, but ignores the case of ASCII characters. </p>

<p class="reference">References <a class="el" href="group__cxstrutils.html#ga1c9ec225c00d0517c4a8ba2f4668cc08">cx_strncasecmp()</a>.</p>

</div>
</div>
<a id="ga2677bfd02e0324dcaf6a16146cc5d613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2677bfd02e0324dcaf6a16146cc5d613">&#9670;&nbsp;</a></span>cx_string_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new, empty string container. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to newly created string.</dd></dl>
<p>The function allocates memory for a new string object and initializes it to represent the empty string.</p>
<p>Using this constructor is the <b>only</b> way to correctly create and setup a new string. </p>

<p class="reference">Referenced by <a class="el" href="group__cxstring.html#gad1c9f69afcebd0ef57d3e5a79fa221ac">cx_string_substr()</a>.</p>

</div>
</div>
<a id="ga5255beabea7b5da62d4d2bf7bf6a27ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5255beabea7b5da62d4d2bf7bf6a27ad">&#9670;&nbsp;</a></span>cx_string_prepend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepend an array of characters to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to character array to be prepended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed string <em>self</em> with the characters prepended, or <code>NULL</code> in case of errors.</dd></dl>
<p>The function adds the contents of the character buffer <em>data</em> to the beginning of the string. If <em>data</em> is a <code>NULL</code> pointer the string <em>self</em> is not modified. </p>

<p class="reference">References <a class="el" href="group__cxmemory.html#ga535a509573c6617da8f0dccdb2710bc9">cx_free()</a>, and <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab">cx_malloc()</a>.</p>

</div>
</div>
<a id="gac7f190519bb7e5497c088cf8a60f2856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7f190519bb7e5497c088cf8a60f2856">&#9670;&nbsp;</a></span>cx_string_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_string_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the value of a cx_string to the standard output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>A cx_string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is provided for debugging purposes. It just writes the strings contents to the standard output using <b><a class="el" href="group__cxmessages.html#ga61bf6d7fbd22c7eaabc33028aae024f7" title="Output a formatted message via the print handler.">cx_print()</a></b>. </p>

<p class="reference">References <a class="el" href="group__cxmessages.html#ga61bf6d7fbd22c7eaabc33028aae024f7">cx_print()</a>.</p>

</div>
</div>
<a id="ga2f129f15130f4e8e06c82c44a58d0663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f129f15130f4e8e06c82c44a58d0663">&#9670;&nbsp;</a></span>cx_string_replace_character()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_string_replace_character </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxsize&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxsize&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxchar&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxchar&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a given character with a new character in a portion of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A cx_string. </td></tr>
    <tr><td class="paramname">start</td><td>The initial position of the range. </td></tr>
    <tr><td class="paramname">end</td><td>The final position of the range. </td></tr>
    <tr><td class="paramname">old_value</td><td>The character to be replaced. </td></tr>
    <tr><td class="paramname">new_value</td><td>The character used as replacement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function replaces the all occurrences of the character <em>old_value</em> with the character <em>new_value</em> in the given range. The range of characters considered is given by the initial position <em>start</em> and the final position <em>end</em>, and does not include the final position, i.e. the range of characters is defined as [start, end).</p>
<p>If <em>start</em> is larger than the size of the string <em>string</em>, the function does nothing. </p>

</div>
</div>
<a id="ga379950ddc09f3785959e5765b3d91223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga379950ddc09f3785959e5765b3d91223">&#9670;&nbsp;</a></span>cx_string_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_string_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxchar&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a string to a given length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A cx_string. </td></tr>
    <tr><td class="paramname">size</td><td>The new length of the string. </td></tr>
    <tr><td class="paramname">c</td><td>The character used to fill the new character space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function resizes a string to a new length <em>size</em>. If the new length is smaller than the current length of the string, the string is shortened to its first <em>size</em> characters. If <em>size</em> is larger than the current length of the string its current contents is extended by adding to its end as many characters as needed to reach a length of <em>size</em> characters. In this latter case the added characters are initialized with the character <em>c</em>.</p>
<p>Specifying zero as the new length of the string, results in the empty string.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxstring.html#ga871347bfc5e8a5beacf9864b250e0fc0" title="Truncate the string.">cx_string_truncate()</a>, <a class="el" href="group__cxstring.html#gae73fda53dad0d22b93eb0b21bdb30ef8" title="Extend a string to a given length.">cx_string_extend()</a> </dd></dl>

</div>
</div>
<a id="gae7a22caf2e7286730e882170cf4a6fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7a22caf2e7286730e882170cf4a6fe3">&#9670;&nbsp;</a></span>cx_string_rtrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_rtrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove trailing whitespaces from the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed string <em>self</em> with trailing whitespaces revoved, or <code>NULL</code> in case of errors.</dd></dl>
<p>The function removes trailing whitespace characters from the string. Whitespace characters are recognized by the standard C function <b>isspace()</b>. </p>

</div>
</div>
<a id="ga745c3e5f86abb0e9e64c3a4fa785c1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga745c3e5f86abb0e9e64c3a4fa785c1de">&#9670;&nbsp;</a></span>cx_string_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_string_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a value to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string. </td></tr>
    <tr><td class="paramname">data</td><td>Character array to be assigned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Stores the contents of the character array pointed to by <em>data</em> into the string. </p>

</div>
</div>
<a id="gad62f3f0eaf0a991913c826d2fb36c8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad62f3f0eaf0a991913c826d2fb36c8c2">&#9670;&nbsp;</a></span>cx_string_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_string_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the length of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string's length, or 0 for uninitialized or empty strings.</dd></dl>
<p>Computes the length of the string. </p>

</div>
</div>
<a id="ga29362244440619a3d7090259c7549585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29362244440619a3d7090259c7549585">&#9670;&nbsp;</a></span>cx_string_sprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_string_sprintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes to a string under format control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string to write to. </td></tr>
    <tr><td class="paramname">format</td><td>The format string. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to insert into <em>format</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters (excluding the trailing null) written to <em>self</em>, i.e. its length. If sufficient space cannot be allocated, -1 is returned.</dd></dl>
<p>The function writes the formatted character array to the string. The function works similar to <b>sprintf()</b> function, except that the string's buffer expands automatically to contain the formatted result. The previous contents of the string is destroyed. </p>

</div>
</div>
<a id="gad1c1ed2a92a736ed8900101cdfbd3ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1c1ed2a92a736ed8900101cdfbd3ce7">&#9670;&nbsp;</a></span>cx_string_strip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_strip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove leading and trailing whitespaces from the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed string <em>self</em> with leading and trailing whitespaces removed, or <code>NULL</code> in case of errors.</dd></dl>
<p>The function removes leading and trailing whitespace characters from the string. Whitespace characters are recognized by the standard C function <b>isspace()</b>. </p>

</div>
</div>
<a id="gad1c9f69afcebd0ef57d3e5a79fa221ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1c9f69afcebd0ef57d3e5a79fa221ac">&#9670;&nbsp;</a></span>cx_string_substr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_substr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxsize&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxsize&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string from a portion of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A string. </td></tr>
    <tr><td class="paramname">pos</td><td>Position of the first character of the substring. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns a new string initialized with the characters of the specified substring.</dd></dl>
<p>The function constructs a new string with its value initialized to a copy of a substring of <em>self</em>. The substring is specified by the position of the first character of the substring <em>pos</em>, and the number of characters of the substring <em>len</em> (or the end of the string, whichever comes first).</p>
<p>If <em>pos</em> is equal to the length of <em>self</em>, an empty string is returned. It is an error if <em>pos</em> is greater than the length of <em>self</em>. </p>

<p class="reference">References <a class="el" href="group__cxmemory.html#ga535a509573c6617da8f0dccdb2710bc9">cx_free()</a>, <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab">cx_malloc()</a>, <a class="el" href="group__cxstring.html#gae21504ed4cde96fd5233167f09d90872">cx_string_create()</a>, and <a class="el" href="group__cxstring.html#ga2677bfd02e0324dcaf6a16146cc5d613">cx_string_new()</a>.</p>

</div>
</div>
<a id="gad38326b29c82dcdc93bfb3252f3c9f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad38326b29c82dcdc93bfb3252f3c9f49">&#9670;&nbsp;</a></span>cx_string_trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove leading whitespaces from the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed string <em>self</em> with leading whitespaces removed, or <code>NULL</code> in case of errors.</dd></dl>
<p>The function removes leading whitespace characters from the string. Whitespace characters are recognized by the standard C function <b>isspace()</b>. </p>

</div>
</div>
<a id="ga871347bfc5e8a5beacf9864b250e0fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga871347bfc5e8a5beacf9864b250e0fc0">&#9670;&nbsp;</a></span>cx_string_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxsize&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string. </td></tr>
    <tr><td class="paramname">length</td><td>The length to which the string is truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The truncated string <em>self</em>, or <code>NULL</code> in case of errors.</dd></dl>
<p>The function removes all characters from the string starting at the character index <em>length</em> up to the end of the string, effectively truncating the string from its original size to a string of length <em>length</em>.</p>
<p>Calling the truncate method is equivalent to: </p><div class="fragment"><div class="line"><a class="code" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *s;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__cxstring.html#gac36b30ef4a5fa1036a333964db2ddbd0">cx_string_erase</a>(s, length, -1);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga8c8b03637f4a99432f40b200bcd9bd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c8b03637f4a99432f40b200bcd9bd0a">&#9670;&nbsp;</a></span>cx_string_upper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a>* cx_string_upper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the string into uppercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed string <em>self</em> with all characters converted to uppercase, or <code>NULL</code> in case of errors.</dd></dl>
<p>All lowercase letters stored in the string are converted to uppercase letters. The conversion is done using the standard C function <b>toupper()</b>. </p>

</div>
</div>
<a id="ga27c9339137a6f0b90cb93cb0bbd1c476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27c9339137a6f0b90cb93cb0bbd1c476">&#9670;&nbsp;</a></span>cx_string_vsprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_string_vsprintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to the string from a variable-length argument list under format control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The string. </td></tr>
    <tr><td class="paramname">format</td><td>The format string. </td></tr>
    <tr><td class="paramname">args</td><td>Variable-length arguments to be inserted into <em>format</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters (excluding the trailing null) written to <em>self</em>, i.e. its length. If sufficient space cannot be allocated, -1 is returned.</dd></dl>
<p>The function writes the formatted character array to the string. The function works similar to <b>vsprintf()</b> function, except that the string's buffer expands automatically to contain the formatted result. The previous contents of the string is destroyed. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__cxstring_html_ga48dfca37e3a62f7fe98edc3f38c0faeb"><div class="ttname"><a href="group__cxstring.html#ga48dfca37e3a62f7fe98edc3f38c0faeb">cx_string</a></div><div class="ttdeci">struct _cx_string_ cx_string</div><div class="ttdoc">The cx_string data type.</div><div class="ttdef"><b>Definition:</b> cxstring.h:52</div></div>
<div class="ttc" id="agroup__cxstring_html_gac36b30ef4a5fa1036a333964db2ddbd0"><div class="ttname"><a href="group__cxstring.html#gac36b30ef4a5fa1036a333964db2ddbd0">cx_string_erase</a></div><div class="ttdeci">cx_string * cx_string_erase(cx_string *self, cxssize position, cxssize length)</div><div class="ttdoc">Erase a portion of the string.</div><div class="ttdef"><b>Definition:</b> cxstring.c:757</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
