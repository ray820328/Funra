<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Standard Library Extensions: Balanced Binary Trees</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C Standard Library Extensions
   &#160;<span id="projectnumber">1.2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Balanced Binary Trees</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0fba28796f9eaa709022e98cbb4f7d0e"><td class="memItemLeft" align="right" valign="top">typedef cxbool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga0fba28796f9eaa709022e98cbb4f7d0e">cx_tree_compare_func</a>) (cxcptr, cxcptr)</td></tr>
<tr class="memdesc:ga0fba28796f9eaa709022e98cbb4f7d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tree's key comparison operator function.  <a href="group__cxtree.html#ga0fba28796f9eaa709022e98cbb4f7d0e">More...</a><br /></td></tr>
<tr class="separator:ga0fba28796f9eaa709022e98cbb4f7d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6038e74547e7e3ac3280c519914b60a3"><td class="memItemLeft" align="right" valign="top">cx_tree_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga6038e74547e7e3ac3280c519914b60a3">cx_tree_begin</a> (const cx_tree *tree)</td></tr>
<tr class="memdesc:ga6038e74547e7e3ac3280c519914b60a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first pair in the tree.  <a href="group__cxtree.html#ga6038e74547e7e3ac3280c519914b60a3">More...</a><br /></td></tr>
<tr class="separator:ga6038e74547e7e3ac3280c519914b60a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff64dc3840bb3d663e6b93b89e52d1e"><td class="memItemLeft" align="right" valign="top">cx_tree_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e">cx_tree_end</a> (const cx_tree *tree)</td></tr>
<tr class="memdesc:gadff64dc3840bb3d663e6b93b89e52d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the position after the last pair in the tree.  <a href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e">More...</a><br /></td></tr>
<tr class="separator:gadff64dc3840bb3d663e6b93b89e52d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86c1d604b075a32860f0f66cf678267c"><td class="memItemLeft" align="right" valign="top">cx_tree_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga86c1d604b075a32860f0f66cf678267c">cx_tree_next</a> (const cx_tree *tree, cx_tree_const_iterator position)</td></tr>
<tr class="memdesc:ga86c1d604b075a32860f0f66cf678267c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the next pair in the tree.  <a href="group__cxtree.html#ga86c1d604b075a32860f0f66cf678267c">More...</a><br /></td></tr>
<tr class="separator:ga86c1d604b075a32860f0f66cf678267c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7a6770d510c426f281fa9d46e1be5e"><td class="memItemLeft" align="right" valign="top">cx_tree_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga7a7a6770d510c426f281fa9d46e1be5e">cx_tree_previous</a> (const cx_tree *tree, cx_tree_const_iterator position)</td></tr>
<tr class="memdesc:ga7a7a6770d510c426f281fa9d46e1be5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the previous pair in the tree.  <a href="group__cxtree.html#ga7a7a6770d510c426f281fa9d46e1be5e">More...</a><br /></td></tr>
<tr class="separator:ga7a7a6770d510c426f281fa9d46e1be5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga377e4c1587471733983f04707f8e619e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga377e4c1587471733983f04707f8e619e">cx_tree_clear</a> (cx_tree *tree)</td></tr>
<tr class="memdesc:ga377e4c1587471733983f04707f8e619e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all pairs from a tree.  <a href="group__cxtree.html#ga377e4c1587471733983f04707f8e619e">More...</a><br /></td></tr>
<tr class="separator:ga377e4c1587471733983f04707f8e619e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148c828066a5d05e95acd4ec3a525bc8"><td class="memItemLeft" align="right" valign="top">cxbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga148c828066a5d05e95acd4ec3a525bc8">cx_tree_empty</a> (const cx_tree *tree)</td></tr>
<tr class="memdesc:ga148c828066a5d05e95acd4ec3a525bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a tree is empty.  <a href="group__cxtree.html#ga148c828066a5d05e95acd4ec3a525bc8">More...</a><br /></td></tr>
<tr class="separator:ga148c828066a5d05e95acd4ec3a525bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d5b89c5e8709645b85996d05478d71e"><td class="memItemLeft" align="right" valign="top">cx_tree *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga4d5b89c5e8709645b85996d05478d71e">cx_tree_new</a> (<a class="el" href="group__cxtree.html#ga0fba28796f9eaa709022e98cbb4f7d0e">cx_tree_compare_func</a> compare, cx_free_func key_destroy, cx_free_func value_destroy)</td></tr>
<tr class="memdesc:ga4d5b89c5e8709645b85996d05478d71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new tree without any elements.  <a href="group__cxtree.html#ga4d5b89c5e8709645b85996d05478d71e">More...</a><br /></td></tr>
<tr class="separator:ga4d5b89c5e8709645b85996d05478d71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e30a6c27e8e423d35a0818f264337fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga5e30a6c27e8e423d35a0818f264337fe">cx_tree_delete</a> (cx_tree *tree)</td></tr>
<tr class="memdesc:ga5e30a6c27e8e423d35a0818f264337fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a tree and all its elements.  <a href="group__cxtree.html#ga5e30a6c27e8e423d35a0818f264337fe">More...</a><br /></td></tr>
<tr class="separator:ga5e30a6c27e8e423d35a0818f264337fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc3eec66e54e3292d3354ffd2076696"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga3cc3eec66e54e3292d3354ffd2076696">cx_tree_size</a> (const cx_tree *tree)</td></tr>
<tr class="memdesc:ga3cc3eec66e54e3292d3354ffd2076696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual number of pairs in the tree.  <a href="group__cxtree.html#ga3cc3eec66e54e3292d3354ffd2076696">More...</a><br /></td></tr>
<tr class="separator:ga3cc3eec66e54e3292d3354ffd2076696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a04a36bb3a449f14efa25e784169b57"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga2a04a36bb3a449f14efa25e784169b57">cx_tree_max_size</a> (const cx_tree *tree)</td></tr>
<tr class="memdesc:ga2a04a36bb3a449f14efa25e784169b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of pairs possible.  <a href="group__cxtree.html#ga2a04a36bb3a449f14efa25e784169b57">More...</a><br /></td></tr>
<tr class="separator:ga2a04a36bb3a449f14efa25e784169b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f1e3c1aff10f23fa128187f37f30ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxtree.html#ga0fba28796f9eaa709022e98cbb4f7d0e">cx_tree_compare_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga40f1e3c1aff10f23fa128187f37f30ce">cx_tree_key_comp</a> (const cx_tree *tree)</td></tr>
<tr class="memdesc:ga40f1e3c1aff10f23fa128187f37f30ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the key comparison function.  <a href="group__cxtree.html#ga40f1e3c1aff10f23fa128187f37f30ce">More...</a><br /></td></tr>
<tr class="separator:ga40f1e3c1aff10f23fa128187f37f30ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf79317c9c323f0d7b1903b7f23c1012e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#gaf79317c9c323f0d7b1903b7f23c1012e">cx_tree_swap</a> (cx_tree *tree1, cx_tree *tree2)</td></tr>
<tr class="memdesc:gaf79317c9c323f0d7b1903b7f23c1012e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of two trees.  <a href="group__cxtree.html#gaf79317c9c323f0d7b1903b7f23c1012e">More...</a><br /></td></tr>
<tr class="separator:gaf79317c9c323f0d7b1903b7f23c1012e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e47b9013eaeb6fe294e02d54a1e8cdf"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga5e47b9013eaeb6fe294e02d54a1e8cdf">cx_tree_assign</a> (cx_tree *tree, cx_tree_iterator position, cxcptr data)</td></tr>
<tr class="memdesc:ga5e47b9013eaeb6fe294e02d54a1e8cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign data to an iterator position.  <a href="group__cxtree.html#ga5e47b9013eaeb6fe294e02d54a1e8cdf">More...</a><br /></td></tr>
<tr class="separator:ga5e47b9013eaeb6fe294e02d54a1e8cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5578369c1a53b8592ff83032c6780cfb"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga5578369c1a53b8592ff83032c6780cfb">cx_tree_get_key</a> (const cx_tree *tree, cx_tree_const_iterator position)</td></tr>
<tr class="memdesc:ga5578369c1a53b8592ff83032c6780cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the key from a given iterator position.  <a href="group__cxtree.html#ga5578369c1a53b8592ff83032c6780cfb">More...</a><br /></td></tr>
<tr class="separator:ga5578369c1a53b8592ff83032c6780cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b15b6abafbb4f528b5a1f0090b48f86"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga4b15b6abafbb4f528b5a1f0090b48f86">cx_tree_get_value</a> (const cx_tree *tree, cx_tree_const_iterator position)</td></tr>
<tr class="memdesc:ga4b15b6abafbb4f528b5a1f0090b48f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data from a given iterator position.  <a href="group__cxtree.html#ga4b15b6abafbb4f528b5a1f0090b48f86">More...</a><br /></td></tr>
<tr class="separator:ga4b15b6abafbb4f528b5a1f0090b48f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa36076ac9467d17c8655a9a94a5f7a44"><td class="memItemLeft" align="right" valign="top">cx_tree_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#gaa36076ac9467d17c8655a9a94a5f7a44">cx_tree_find</a> (const cx_tree *tree, cxcptr key)</td></tr>
<tr class="memdesc:gaa36076ac9467d17c8655a9a94a5f7a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate an element in the tree.  <a href="group__cxtree.html#gaa36076ac9467d17c8655a9a94a5f7a44">More...</a><br /></td></tr>
<tr class="separator:gaa36076ac9467d17c8655a9a94a5f7a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e4896d6cd7486dc6d73eb7c3a56fea"><td class="memItemLeft" align="right" valign="top">cx_tree_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga22e4896d6cd7486dc6d73eb7c3a56fea">cx_tree_lower_bound</a> (const cx_tree *tree, cxcptr key)</td></tr>
<tr class="memdesc:ga22e4896d6cd7486dc6d73eb7c3a56fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of a subsequence.  <a href="group__cxtree.html#ga22e4896d6cd7486dc6d73eb7c3a56fea">More...</a><br /></td></tr>
<tr class="separator:ga22e4896d6cd7486dc6d73eb7c3a56fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410dcaddb7845533076d98466f51c053"><td class="memItemLeft" align="right" valign="top">cx_tree_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga410dcaddb7845533076d98466f51c053">cx_tree_upper_bound</a> (const cx_tree *tree, cxcptr key)</td></tr>
<tr class="memdesc:ga410dcaddb7845533076d98466f51c053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of a subsequence.  <a href="group__cxtree.html#ga410dcaddb7845533076d98466f51c053">More...</a><br /></td></tr>
<tr class="separator:ga410dcaddb7845533076d98466f51c053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db4e043848ab20c0111b9a1b081593a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga9db4e043848ab20c0111b9a1b081593a">cx_tree_equal_range</a> (const cx_tree *tree, cxcptr key, cx_tree_iterator *begin, cx_tree_iterator *end)</td></tr>
<tr class="memdesc:ga9db4e043848ab20c0111b9a1b081593a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a subsequence matching a given key.  <a href="group__cxtree.html#ga9db4e043848ab20c0111b9a1b081593a">More...</a><br /></td></tr>
<tr class="separator:ga9db4e043848ab20c0111b9a1b081593a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaede41b65d866b8c6cd7589bbebd81b39"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#gaede41b65d866b8c6cd7589bbebd81b39">cx_tree_count</a> (const cx_tree *tree, cxcptr key)</td></tr>
<tr class="memdesc:gaede41b65d866b8c6cd7589bbebd81b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements matching a key.  <a href="group__cxtree.html#gaede41b65d866b8c6cd7589bbebd81b39">More...</a><br /></td></tr>
<tr class="separator:gaede41b65d866b8c6cd7589bbebd81b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f8f15e701fd1eb4ebe15639aea354e3"><td class="memItemLeft" align="right" valign="top">cx_tree_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga1f8f15e701fd1eb4ebe15639aea354e3">cx_tree_insert_unique</a> (cx_tree *tree, cxcptr key, cxcptr data)</td></tr>
<tr class="memdesc:ga1f8f15e701fd1eb4ebe15639aea354e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to insert data into a tree.  <a href="group__cxtree.html#ga1f8f15e701fd1eb4ebe15639aea354e3">More...</a><br /></td></tr>
<tr class="separator:ga1f8f15e701fd1eb4ebe15639aea354e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b038bf6018884fa92a5aa316e4cb66"><td class="memItemLeft" align="right" valign="top">cx_tree_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga07b038bf6018884fa92a5aa316e4cb66">cx_tree_insert_equal</a> (cx_tree *tree, cxcptr key, cxcptr data)</td></tr>
<tr class="memdesc:ga07b038bf6018884fa92a5aa316e4cb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into a tree.  <a href="group__cxtree.html#ga07b038bf6018884fa92a5aa316e4cb66">More...</a><br /></td></tr>
<tr class="separator:ga07b038bf6018884fa92a5aa316e4cb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5f45961ba5ab503c751f54810e8258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#gaea5f45961ba5ab503c751f54810e8258">cx_tree_erase_position</a> (cx_tree *tree, cx_tree_iterator position)</td></tr>
<tr class="memdesc:gaea5f45961ba5ab503c751f54810e8258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element from a tree.  <a href="group__cxtree.html#gaea5f45961ba5ab503c751f54810e8258">More...</a><br /></td></tr>
<tr class="separator:gaea5f45961ba5ab503c751f54810e8258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae573050dfd0d7cc829844609ff4a1dc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#gae573050dfd0d7cc829844609ff4a1dc2">cx_tree_erase_range</a> (cx_tree *tree, cx_tree_iterator begin, cx_tree_iterator end)</td></tr>
<tr class="memdesc:gae573050dfd0d7cc829844609ff4a1dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a range of elements from a tree.  <a href="group__cxtree.html#gae573050dfd0d7cc829844609ff4a1dc2">More...</a><br /></td></tr>
<tr class="separator:gae573050dfd0d7cc829844609ff4a1dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14027eafaeb3eaddd513b839672c5e92"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#ga14027eafaeb3eaddd513b839672c5e92">cx_tree_erase</a> (cx_tree *tree, cxcptr key)</td></tr>
<tr class="memdesc:ga14027eafaeb3eaddd513b839672c5e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all elements from a tree matching the provided key.  <a href="group__cxtree.html#ga14027eafaeb3eaddd513b839672c5e92">More...</a><br /></td></tr>
<tr class="separator:ga14027eafaeb3eaddd513b839672c5e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba9a431c2237e6b98584dd47052f8529"><td class="memItemLeft" align="right" valign="top">cxbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxtree.html#gaba9a431c2237e6b98584dd47052f8529">cx_tree_verify</a> (const cx_tree *tree)</td></tr>
<tr class="memdesc:gaba9a431c2237e6b98584dd47052f8529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a tree.  <a href="group__cxtree.html#gaba9a431c2237e6b98584dd47052f8529">More...</a><br /></td></tr>
<tr class="separator:gaba9a431c2237e6b98584dd47052f8529"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The module implements a balanced binary tree type, i.e. a container managing key/value pairs as elements. The container is optimized for lookup operations.</p>
<dl class="section user"><dt>Synopsis:</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cxtree.h&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga0fba28796f9eaa709022e98cbb4f7d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fba28796f9eaa709022e98cbb4f7d0e">&#9670;&nbsp;</a></span>cx_tree_compare_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef cxbool(* cx_tree_compare_func) (cxcptr, cxcptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The tree's key comparison operator function. </p>
<p>This type of function is used by a tree internally to compare the keys of its elements. A key comparison operator returns <code>TRUE</code> if the comparison of its first argument with the second argument succeeds, and <code>FALSE</code> otherwise, as, for instance, the logical operators &lt;, &gt;, ==, and != do.</p>
<p>Examples:</p><ul>
<li>A less than operator for integer values <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cxtree.h&gt;</span></div>
<div class="line"> </div>
<div class="line">cxbool less_int(cxcptr i1, cxcptr i2)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> *i1 &lt; *i2;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>A less than and an equal operator for strings <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cxtree.h&gt;</span></div>
<div class="line"> </div>
<div class="line">cxbool less_string(cxcptr s1, cxcptr s2)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> strcmp(s1, s2) &lt; 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">cxbool equal_string(cxptr s1, cxptr s2)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> strcmp(s1, s2) == 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5e47b9013eaeb6fe294e02d54a1e8cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e47b9013eaeb6fe294e02d54a1e8cdf">&#9670;&nbsp;</a></span>cx_tree_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_tree_assign </td>
          <td>(</td>
          <td class="paramtype">cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_tree_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign data to an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">position</td><td>Iterator positions where the data will be stored. </td></tr>
    <tr><td class="paramname">data</td><td>Data to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the previously stored data object.</dd></dl>
<p>The function assigns a data object reference <em>data</em> to the iterator position <em>position</em> of the tree <em>tree</em>. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga80e8807a9c18e074bcac96a6477afb55">cx_map_assign()</a>, <a class="el" href="group__cxmap.html#gaeb1c59ace3e10f9588616d0b9ea7fbfc">cx_map_put()</a>, and <a class="el" href="group__cxmultimap.html#gae2c94b9833c1e2940c0cb626568c0e41">cx_multimap_assign()</a>.</p>

</div>
</div>
<a id="ga6038e74547e7e3ac3280c519914b60a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6038e74547e7e3ac3280c519914b60a3">&#9670;&nbsp;</a></span>cx_tree_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_tree_iterator cx_tree_begin </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator to the first pair in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the first pair or <b><a class="el" href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e" title="Get an iterator for the position after the last pair in the tree.">cx_tree_end()</a></b> if the tree is empty.</dd></dl>
<p>The function returns a handle for the first pair in the tree <em>tree</em>. The returned iterator cannot be used directly to access the value field of the key/value pair, but only through the appropriate methods. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga156f4653538a24d512874a23213a2e1f">cx_map_begin()</a>, and <a class="el" href="group__cxmultimap.html#gaf08e21b17216433c2f4b9f5c8482abcb">cx_multimap_begin()</a>.</p>

</div>
</div>
<a id="ga377e4c1587471733983f04707f8e619e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga377e4c1587471733983f04707f8e619e">&#9670;&nbsp;</a></span>cx_tree_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_tree_clear </td>
          <td>(</td>
          <td class="paramtype">cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all pairs from a tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The tree <em>tree</em> is cleared, i.e. all pairs are removed from the tree. Keys and values are destroyed using the key and value destructors set up during tree creation. After calling this function the tree is empty. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#gafe98264e8e9db4c0cfeba4561db37035">cx_map_clear()</a>, and <a class="el" href="group__cxmultimap.html#ga04e85e7fc13400eeb700066810e91e52">cx_multimap_clear()</a>.</p>

</div>
</div>
<a id="gaede41b65d866b8c6cd7589bbebd81b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaede41b65d866b8c6cd7589bbebd81b39">&#9670;&nbsp;</a></span>cx_tree_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_tree_count </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of elements matching a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the (key, value) pair(s) to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements with the specified key.</dd></dl>
<p>Counts all elements of the tree <em>tree</em> matching the key <em>key</em>. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmultimap.html#ga70527409d50026c0cfb85c491a55457d">cx_multimap_count()</a>.</p>

</div>
</div>
<a id="ga5e30a6c27e8e423d35a0818f264337fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e30a6c27e8e423d35a0818f264337fe">&#9670;&nbsp;</a></span>cx_tree_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_tree_delete </td>
          <td>(</td>
          <td class="paramtype">cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a tree and all its elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The tree <em>tree</em> is deallocated. All data values and keys are deallocated using the tree's key and value destructor. If no key and/or value destructor was set when the <em>tree</em> was created the keys and the stored data values are left untouched. In this case the key and value deallocation is the responsibility of the user.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxtree.html#ga4d5b89c5e8709645b85996d05478d71e" title="Create a new tree without any elements.">cx_tree_new()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga94d7565c5fe50fec961d4f3f4fdbd241">cx_map_delete()</a>, and <a class="el" href="group__cxmultimap.html#gab91edddb80f050169933450acf0be4d2">cx_multimap_delete()</a>.</p>

</div>
</div>
<a id="ga148c828066a5d05e95acd4ec3a525bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148c828066a5d05e95acd4ec3a525bc8">&#9670;&nbsp;</a></span>cx_tree_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxbool cx_tree_empty </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a tree is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <code>TRUE</code> if the tree is empty, and <code>FALSE</code> otherwise.</dd></dl>
<p>The function checks if the tree contains any pairs. Calling this function is equivalent to the statement: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> (<a class="code" href="group__cxtree.html#ga3cc3eec66e54e3292d3354ffd2076696">cx_tree_size</a>(tree) == 0);</div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="group__cxmap.html#gacd5d5b06a038b9746538291395432627">cx_map_empty()</a>, and <a class="el" href="group__cxmultimap.html#ga51fe454733ae3155f12a2b4f1242eae6">cx_multimap_empty()</a>.</p>

</div>
</div>
<a id="gadff64dc3840bb3d663e6b93b89e52d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadff64dc3840bb3d663e6b93b89e52d1e">&#9670;&nbsp;</a></span>cx_tree_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_tree_iterator cx_tree_end </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the position after the last pair in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the end of the tree.</dd></dl>
<p>The function returns an iterator for the position one past the last pair in the tree <em>tree</em>. The iteration is done in ascending order according to the keys. The returned iterator cannot be used directly to access the value field of the key/value pair, but only through the appropriate methods. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga11cb14ad033e85525ded6dc92d093499">cx_map_count()</a>, <a class="el" href="group__cxmap.html#gae5dd15139b587d10b5cb7a15128b880e">cx_map_end()</a>, <a class="el" href="group__cxmap.html#ga6dc8172e04dcf5589b00f1c6cc49207c">cx_map_get()</a>, <a class="el" href="group__cxmap.html#gaeb1c59ace3e10f9588616d0b9ea7fbfc">cx_map_put()</a>, and <a class="el" href="group__cxmultimap.html#ga0664926c1144abc42ff45630398cff3b">cx_multimap_end()</a>.</p>

</div>
</div>
<a id="ga9db4e043848ab20c0111b9a1b081593a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9db4e043848ab20c0111b9a1b081593a">&#9670;&nbsp;</a></span>cx_tree_equal_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_tree_equal_range </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_tree_iterator *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_tree_iterator *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a subsequence matching a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the (key, value) pair(s) to be located. </td></tr>
    <tr><td class="paramname">begin</td><td>First element with key <em>key</em>. </td></tr>
    <tr><td class="paramname">end</td><td>Last element with key <em>key</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function returns the beginning and the end of a subsequence of tree elements with the key <em>key</em> through through the <em>begin</em> and <em>end</em> arguments. After calling this function <em>begin</em> possibly points to the first element of <em>tree</em> matching the key <em>key</em> and <em>end</em> possibly points to the last element of the sequence. If key is not present in the tree <em>begin</em> points to the next greater element or, if no such element exists, to <b><a class="el" href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e" title="Get an iterator for the position after the last pair in the tree.">cx_tree_end()</a></b>. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga61e396d53f3fe4f3a28f906e59e02dfb">cx_map_equal_range()</a>, and <a class="el" href="group__cxmultimap.html#ga084d0d468f5f6074113f60a5560dce34">cx_multimap_equal_range()</a>.</p>

</div>
</div>
<a id="ga14027eafaeb3eaddd513b839672c5e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14027eafaeb3eaddd513b839672c5e92">&#9670;&nbsp;</a></span>cx_tree_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_tree_erase </td>
          <td>(</td>
          <td class="paramtype">cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all elements from a tree matching the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the element to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of removed elements.</dd></dl>
<p>This function erases all elements with the specified key <em>key</em>, from <em>tree</em>. Key and value associated with the erased pairs are deallocated using the tree's key and value destructors, provided they have been set. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#gae9a58e7a005280bdd0ba8a67b2c46c89">cx_map_erase()</a>, and <a class="el" href="group__cxmultimap.html#ga4445b5eb32f7452f56a0045dda373f94">cx_multimap_erase()</a>.</p>

</div>
</div>
<a id="gaea5f45961ba5ab503c751f54810e8258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea5f45961ba5ab503c751f54810e8258">&#9670;&nbsp;</a></span>cx_tree_erase_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_tree_erase_position </td>
          <td>(</td>
          <td class="paramtype">cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_tree_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase an element from a tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">position</td><td>Iterator position of the element to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function erases an element, specified by the iterator <em>position</em>, from <em>tree</em>. Key and value associated with the erased pair are deallocated using the tree's key and value destructors, provided they have been set. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga3b5fb17aeafdff4b2cd5a660b06e80fe">cx_map_erase_position()</a>, and <a class="el" href="group__cxmultimap.html#gace135776d124d74eada48b654abcfe04">cx_multimap_erase_position()</a>.</p>

</div>
</div>
<a id="gae573050dfd0d7cc829844609ff4a1dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae573050dfd0d7cc829844609ff4a1dc2">&#9670;&nbsp;</a></span>cx_tree_erase_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_tree_erase_range </td>
          <td>(</td>
          <td class="paramtype">cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_tree_iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_tree_iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a range of elements from a tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">begin</td><td>Iterator pointing to the start of the range to erase. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the range to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function erases all elements in the range [begin, end) from the tree <em>tree</em>. Key and value associated with the erased pair(s) are deallocated using the tree's key and value destructors, provided they have been set. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga284d85c6de2206aaf7ff60a6667ce084">cx_map_erase_range()</a>, and <a class="el" href="group__cxmultimap.html#ga567a2280d596e10e11c4806fe8df99f5">cx_multimap_erase_range()</a>.</p>

</div>
</div>
<a id="gaa36076ac9467d17c8655a9a94a5f7a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa36076ac9467d17c8655a9a94a5f7a44">&#9670;&nbsp;</a></span>cx_tree_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_tree_iterator cx_tree_find </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate an element in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the (key, value) pair to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the sought-after element, or <b><a class="el" href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e" title="Get an iterator for the position after the last pair in the tree.">cx_tree_end()</a></b> if it was not found.</dd></dl>
<p>The function searches the tree <em>tree</em> for an element with a key matching <em>key</em>. If the search was successful an iterator to the sought-after pair is returned. If the search did not succeed, i.e. <em>key</em> is not present in the tree, a one past the end iterator is returned. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga11cb14ad033e85525ded6dc92d093499">cx_map_count()</a>, <a class="el" href="group__cxmap.html#gaacefcf33145d47dcb9439c23b07be5fa">cx_map_find()</a>, and <a class="el" href="group__cxmultimap.html#gada385132d40cf231aa6e2c7da61ebd4e">cx_multimap_find()</a>.</p>

</div>
</div>
<a id="ga5578369c1a53b8592ff83032c6780cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5578369c1a53b8592ff83032c6780cfb">&#9670;&nbsp;</a></span>cx_tree_get_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_tree_get_key </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_tree_const_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the key from a given iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">position</td><td>Iterator position the data is retrieved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference for the key.</dd></dl>
<p>The function returns a reference to the key associated with the iterator position <em>position</em> in the tree <em>tree</em>.</p>
<dl class="section note"><dt>Note</dt><dd>One must not modify the key of <em>position</em> through the returned reference, since this might corrupt the tree! </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga6dc8172e04dcf5589b00f1c6cc49207c">cx_map_get()</a>, <a class="el" href="group__cxmap.html#gaac55eccdca3ef107f4b76f5a7a57fca0">cx_map_get_key()</a>, and <a class="el" href="group__cxmultimap.html#gaca42be4a86255128ff7fbd9d060422b7">cx_multimap_get_key()</a>.</p>

</div>
</div>
<a id="ga4b15b6abafbb4f528b5a1f0090b48f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b15b6abafbb4f528b5a1f0090b48f86">&#9670;&nbsp;</a></span>cx_tree_get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_tree_get_value </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_tree_const_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data from a given iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">position</td><td>Iterator position the data is retrieved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for the data object.</dd></dl>
<p>The function returns a reference to the data stored at iterator position <em>position</em> in the tree <em>tree</em>. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga6dc8172e04dcf5589b00f1c6cc49207c">cx_map_get()</a>, <a class="el" href="group__cxmap.html#gad6088581b6b73fd905bc37abffab2edf">cx_map_get_value()</a>, and <a class="el" href="group__cxmultimap.html#gad6457c9e3b6c522352d9500fd23ff634">cx_multimap_get_value()</a>.</p>

</div>
</div>
<a id="ga07b038bf6018884fa92a5aa316e4cb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07b038bf6018884fa92a5aa316e4cb66">&#9670;&nbsp;</a></span>cx_tree_insert_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_tree_iterator cx_tree_insert_equal </td>
          <td>(</td>
          <td class="paramtype">cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into a tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">key</td><td>Key used to store the data. </td></tr>
    <tr><td class="paramname">data</td><td>Data to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted pair.</dd></dl>
<p>This function inserts a (key, value) pair into the tree <em>tree</em>. Contrary to <b><a class="el" href="group__cxtree.html#ga1f8f15e701fd1eb4ebe15639aea354e3" title="Attempt to insert data into a tree.">cx_tree_insert_unique()</a></b> the key <em>key</em> used for inserting <em>data</em> may already be present in the tree. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmultimap.html#ga6281914a4c8a9b5582758b4e90c527b4">cx_multimap_insert()</a>.</p>

</div>
</div>
<a id="ga1f8f15e701fd1eb4ebe15639aea354e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f8f15e701fd1eb4ebe15639aea354e3">&#9670;&nbsp;</a></span>cx_tree_insert_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_tree_iterator cx_tree_insert_unique </td>
          <td>(</td>
          <td class="paramtype">cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to insert data into a tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">key</td><td>Key used to store the data. </td></tr>
    <tr><td class="paramname">data</td><td>Data to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted pair, or <code>NULL</code> if the pair could not be inserted.</dd></dl>
<p>This function attempts to insert a (key, value) pair into the tree <em>tree</em>. The insertion fails if the key already present in the tree, i.e. if the key is not unique. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga6dc8172e04dcf5589b00f1c6cc49207c">cx_map_get()</a>, <a class="el" href="group__cxmap.html#gaaf6b77fe3fc775b2fc29bc435e6130b0">cx_map_insert()</a>, and <a class="el" href="group__cxmap.html#gaeb1c59ace3e10f9588616d0b9ea7fbfc">cx_map_put()</a>.</p>

</div>
</div>
<a id="ga40f1e3c1aff10f23fa128187f37f30ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40f1e3c1aff10f23fa128187f37f30ce">&#9670;&nbsp;</a></span>cx_tree_key_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxtree.html#ga0fba28796f9eaa709022e98cbb4f7d0e">cx_tree_compare_func</a> cx_tree_key_comp </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the key comparison function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for the tree's key comparison function.</dd></dl>
<p>The function retrieves the function used by the tree methods for comparing keys. The key comparison function is set during tree creation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxtree.html#ga4d5b89c5e8709645b85996d05478d71e" title="Create a new tree without any elements.">cx_tree_new()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga6dc8172e04dcf5589b00f1c6cc49207c">cx_map_get()</a>, <a class="el" href="group__cxmap.html#ga4d8fbf9375ffab6b66ef27cbee11a015">cx_map_key_comp()</a>, and <a class="el" href="group__cxmultimap.html#gababd9f0e9931b1719e7ccadb41c96c26">cx_multimap_key_comp()</a>.</p>

</div>
</div>
<a id="ga22e4896d6cd7486dc6d73eb7c3a56fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22e4896d6cd7486dc6d73eb7c3a56fea">&#9670;&nbsp;</a></span>cx_tree_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_tree_iterator cx_tree_lower_bound </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the beginning of a subsequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the (key, value) pair(s) to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first position where an element with key <em>key</em> would get inserted, i.e. the first element with a key greater or equal than <em>key</em>.</dd></dl>
<p>The function returns the first element of a subsequence of elements in the tree that match the given key <em>key</em>. If <em>key</em> is not present in the tree <em>tree</em> an iterator pointing to the first element that has a greater key than <em>key</em> or <b><a class="el" href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e" title="Get an iterator for the position after the last pair in the tree.">cx_tree_end()</a></b> if no such element exists. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga6dc8172e04dcf5589b00f1c6cc49207c">cx_map_get()</a>, <a class="el" href="group__cxmap.html#ga75110aefe5bdddd1b3ab03d752d8e22b">cx_map_lower_bound()</a>, <a class="el" href="group__cxmap.html#gaeb1c59ace3e10f9588616d0b9ea7fbfc">cx_map_put()</a>, and <a class="el" href="group__cxmultimap.html#ga7b8519646c0823f93349524ca64944fe">cx_multimap_lower_bound()</a>.</p>

</div>
</div>
<a id="ga2a04a36bb3a449f14efa25e784169b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a04a36bb3a449f14efa25e784169b57">&#9670;&nbsp;</a></span>cx_tree_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_tree_max_size </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum number of pairs possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of pairs that can be stored in the tree.</dd></dl>
<p>Retrieves the tree's capacity, i.e. the maximum possible number of pairs a tree can manage. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga81cb88ef79b84e82c362b09a78319fbe">cx_map_max_size()</a>, and <a class="el" href="group__cxmultimap.html#ga5cb5a94c2aa80f245c6c29f32786830e">cx_multimap_max_size()</a>.</p>

</div>
</div>
<a id="ga4d5b89c5e8709645b85996d05478d71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d5b89c5e8709645b85996d05478d71e">&#9670;&nbsp;</a></span>cx_tree_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_tree* cx_tree_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxtree.html#ga0fba28796f9eaa709022e98cbb4f7d0e">cx_tree_compare_func</a>&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_free_func&#160;</td>
          <td class="paramname"><em>key_destroy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_free_func&#160;</td>
          <td class="paramname"><em>value_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new tree without any elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>Function used to compare keys. </td></tr>
    <tr><td class="paramname">key_destroy</td><td>Destructor for the keys. </td></tr>
    <tr><td class="paramname">value_destroy</td><td>Destructor for the value field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for the newly allocated tree.</dd></dl>
<p>Memory for a new tree is allocated and the tree is initialized to be a valid empty tree.</p>
<p>The tree's key comparison function is set to <em>compare</em>. It must return <code>TRUE</code> or <code>FALSE</code> if the comparison of the first argument passed to it with the second argument is found to be true or false respectively.</p>
<p>The destructors for a tree node's key and value field are set to <em>key_destroy</em> and <em>value_destroy</em>. Whenever a tree node is destroyed these functions are used to deallocate the memory used by the key and the value. Each of the destructors might be <code>NULL</code>, i.e. keys and values are not deallocated during destroy operations.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxtree.html#ga0fba28796f9eaa709022e98cbb4f7d0e" title="The tree&#39;s key comparison operator function.">cx_tree_compare_func()</a> </dd></dl>

<p class="reference">References <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab">cx_malloc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga6e539ee5ac510a3000d9984ce72d21f8">cx_map_new()</a>, and <a class="el" href="group__cxmultimap.html#ga2f7489b10291e6dbf257974f33fe00ad">cx_multimap_new()</a>.</p>

</div>
</div>
<a id="ga86c1d604b075a32860f0f66cf678267c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86c1d604b075a32860f0f66cf678267c">&#9670;&nbsp;</a></span>cx_tree_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_tree_iterator cx_tree_next </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_tree_const_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the next pair in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">position</td><td>Current iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the pair immediately following <em>position</em>.</dd></dl>
<p>The function returns an iterator for the next pair in the tree <em>tree</em> with respect to the current iterator position <em>position</em>. Iteration is done in ascending order according to the keys. If the tree is empty or <em>position</em> points to the end of the tree the function returns <b><a class="el" href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e" title="Get an iterator for the position after the last pair in the tree.">cx_tree_end()</a></b>. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga0f33e89b70fefdb79b99467aba18587d">cx_map_next()</a>, and <a class="el" href="group__cxmultimap.html#ga3e4675ececca240fd93a696273d94fd0">cx_multimap_next()</a>.</p>

</div>
</div>
<a id="ga7a7a6770d510c426f281fa9d46e1be5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a7a6770d510c426f281fa9d46e1be5e">&#9670;&nbsp;</a></span>cx_tree_previous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_tree_iterator cx_tree_previous </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_tree_const_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the previous pair in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">position</td><td>Current iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the pair immediately preceding <em>position</em>.</dd></dl>
<p>The function returns an iterator for the previous pair in the tree <em>tree</em> with respect to the current iterator position <em>position</em>. Iteration is done in ascending order according to the keys. If the tree is empty or <em>position</em> points to the beginning of the tree the function returns <b><a class="el" href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e" title="Get an iterator for the position after the last pair in the tree.">cx_tree_end()</a></b>. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga6f6382072295b03f41686716486bb4d3">cx_map_previous()</a>, and <a class="el" href="group__cxmultimap.html#ga436f55eebc0e96500579067a898361eb">cx_multimap_previous()</a>.</p>

</div>
</div>
<a id="ga3cc3eec66e54e3292d3354ffd2076696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cc3eec66e54e3292d3354ffd2076696">&#9670;&nbsp;</a></span>cx_tree_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_tree_size </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the actual number of pairs in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current number of pairs, or 0 if the tree is empty.</dd></dl>
<p>Retrieves the current number of pairs stored in the tree. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#ga307c8c94ef5f053f32fd3e2ba91d74c0">cx_map_size()</a>, and <a class="el" href="group__cxmultimap.html#gac5829ebe763fb7cfbfa895560e773dd0">cx_multimap_size()</a>.</p>

</div>
</div>
<a id="gaf79317c9c323f0d7b1903b7f23c1012e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf79317c9c323f0d7b1903b7f23c1012e">&#9670;&nbsp;</a></span>cx_tree_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_tree_swap </td>
          <td>(</td>
          <td class="paramtype">cx_tree *&#160;</td>
          <td class="paramname"><em>tree1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_tree *&#160;</td>
          <td class="paramname"><em>tree2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the contents of two trees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree1</td><td>First tree. </td></tr>
    <tr><td class="paramname">tree2</td><td>Second tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>All pairs stored in the first tree <em>tree1</em> are moved to the second tree <em>tree2</em>, while the pairs from <em>tree2</em> are moved to <em>tree1</em>. Also the key comparison function, the key and the value destructor are exchanged. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#gac480f53fd51f8e04b79ec92d1fe8e586">cx_map_swap()</a>, and <a class="el" href="group__cxmultimap.html#ga9007e9259934869c4bd71156b1b038dc">cx_multimap_swap()</a>.</p>

</div>
</div>
<a id="ga410dcaddb7845533076d98466f51c053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga410dcaddb7845533076d98466f51c053">&#9670;&nbsp;</a></span>cx_tree_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_tree_iterator cx_tree_upper_bound </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the end of a subsequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>A tree. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the (key, value) pair(s) to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the last position where an element with key <em>key</em> would get inserted, i.e. the first element with a key greater than <em>key</em>.</dd></dl>
<p>The function returns the last element of a subsequence of elements in the tree that match the given key <em>key</em>. If <em>key</em> is not present in the tree <em>tree</em> an iterator pointing to the first element that has a greater key than <em>key</em> or <b><a class="el" href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e" title="Get an iterator for the position after the last pair in the tree.">cx_tree_end()</a></b> if no such element exists. </p>

<p class="reference">Referenced by <a class="el" href="group__cxmap.html#gaa3cf57d1d4fc024a1d87dbae9807c209">cx_map_upper_bound()</a>, and <a class="el" href="group__cxmultimap.html#ga921040ae538ae0f1d3de3ec28f7bf151">cx_multimap_upper_bound()</a>.</p>

</div>
</div>
<a id="gaba9a431c2237e6b98584dd47052f8529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba9a431c2237e6b98584dd47052f8529">&#9670;&nbsp;</a></span>cx_tree_verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxbool cx_tree_verify </td>
          <td>(</td>
          <td class="paramtype">const cx_tree *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate a tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree to verify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>TRUE</code> if the tree is valid, or <code>FALSE</code> otherwise.</dd></dl>
<p>The function is provided for debugging purposes. It verifies that the internal tree structure of <em>tree</em> is valid. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__cxtree_html_ga3cc3eec66e54e3292d3354ffd2076696"><div class="ttname"><a href="group__cxtree.html#ga3cc3eec66e54e3292d3354ffd2076696">cx_tree_size</a></div><div class="ttdeci">cxsize cx_tree_size(const cx_tree *tree)</div><div class="ttdoc">Get the actual number of pairs in the tree.</div><div class="ttdef"><b>Definition:</b> cxtree.c:1276</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
