<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Standard Library Extensions: Singly Linked Lists</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C Standard Library Extensions
   &#160;<span id="projectnumber">1.2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Singly Linked Lists</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga40e56afd0a90dc1c8329b2b5c827d4f8"><td class="memItemLeft" align="right" valign="top">cx_slist_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga40e56afd0a90dc1c8329b2b5c827d4f8">cx_slist_begin</a> (const cx_slist *list)</td></tr>
<tr class="memdesc:ga40e56afd0a90dc1c8329b2b5c827d4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list iterator to the beginning of a list.  <a href="group__cxslist.html#ga40e56afd0a90dc1c8329b2b5c827d4f8">More...</a><br /></td></tr>
<tr class="separator:ga40e56afd0a90dc1c8329b2b5c827d4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49f0318ea92ad85b07ea785ba2072896"><td class="memItemLeft" align="right" valign="top">cx_slist_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga49f0318ea92ad85b07ea785ba2072896">cx_slist_end</a> (const cx_slist *list)</td></tr>
<tr class="memdesc:ga49f0318ea92ad85b07ea785ba2072896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list iterator to the end of a list.  <a href="group__cxslist.html#ga49f0318ea92ad85b07ea785ba2072896">More...</a><br /></td></tr>
<tr class="separator:ga49f0318ea92ad85b07ea785ba2072896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f35965462d90e81a620e84949f4cd6c"><td class="memItemLeft" align="right" valign="top">cx_slist_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga3f35965462d90e81a620e84949f4cd6c">cx_slist_next</a> (const cx_slist *list, cx_slist_const_iterator position)</td></tr>
<tr class="memdesc:ga3f35965462d90e81a620e84949f4cd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list iterator to the next list element.  <a href="group__cxslist.html#ga3f35965462d90e81a620e84949f4cd6c">More...</a><br /></td></tr>
<tr class="separator:ga3f35965462d90e81a620e84949f4cd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1842cad43628cb2e09fdd1e82579f501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga1842cad43628cb2e09fdd1e82579f501">cx_slist_clear</a> (cx_slist *list)</td></tr>
<tr class="memdesc:ga1842cad43628cb2e09fdd1e82579f501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from a list.  <a href="group__cxslist.html#ga1842cad43628cb2e09fdd1e82579f501">More...</a><br /></td></tr>
<tr class="separator:ga1842cad43628cb2e09fdd1e82579f501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7adcdaa81edd7cfac3c17e32e2477704"><td class="memItemLeft" align="right" valign="top">cxbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga7adcdaa81edd7cfac3c17e32e2477704">cx_slist_empty</a> (const cx_slist *list)</td></tr>
<tr class="memdesc:ga7adcdaa81edd7cfac3c17e32e2477704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a list is empty.  <a href="group__cxslist.html#ga7adcdaa81edd7cfac3c17e32e2477704">More...</a><br /></td></tr>
<tr class="separator:ga7adcdaa81edd7cfac3c17e32e2477704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbeb18632065ead0f8d196264040a485"><td class="memItemLeft" align="right" valign="top">cx_slist *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#gacbeb18632065ead0f8d196264040a485">cx_slist_new</a> (void)</td></tr>
<tr class="memdesc:gacbeb18632065ead0f8d196264040a485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new list without any elements.  <a href="group__cxslist.html#gacbeb18632065ead0f8d196264040a485">More...</a><br /></td></tr>
<tr class="separator:gacbeb18632065ead0f8d196264040a485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab85764bce368f99428c95479ae5240b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#gaab85764bce368f99428c95479ae5240b">cx_slist_delete</a> (cx_slist *list)</td></tr>
<tr class="memdesc:gaab85764bce368f99428c95479ae5240b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a list.  <a href="group__cxslist.html#gaab85764bce368f99428c95479ae5240b">More...</a><br /></td></tr>
<tr class="separator:gaab85764bce368f99428c95479ae5240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0edc236ae8857991e235f9172140c15e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga0edc236ae8857991e235f9172140c15e">cx_slist_destroy</a> (cx_slist *list, cx_free_func deallocate)</td></tr>
<tr class="memdesc:ga0edc236ae8857991e235f9172140c15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a list and all its elements.  <a href="group__cxslist.html#ga0edc236ae8857991e235f9172140c15e">More...</a><br /></td></tr>
<tr class="separator:ga0edc236ae8857991e235f9172140c15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab219284235d39b70d4a02c8761bf6675"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#gab219284235d39b70d4a02c8761bf6675">cx_slist_size</a> (const cx_slist *list)</td></tr>
<tr class="memdesc:gab219284235d39b70d4a02c8761bf6675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual number of list elements.  <a href="group__cxslist.html#gab219284235d39b70d4a02c8761bf6675">More...</a><br /></td></tr>
<tr class="separator:gab219284235d39b70d4a02c8761bf6675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87feb82b6b2e9e61fe1600e052a3c0e"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#gad87feb82b6b2e9e61fe1600e052a3c0e">cx_slist_max_size</a> (const cx_slist *list)</td></tr>
<tr class="memdesc:gad87feb82b6b2e9e61fe1600e052a3c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of list elements possible.  <a href="group__cxslist.html#gad87feb82b6b2e9e61fe1600e052a3c0e">More...</a><br /></td></tr>
<tr class="separator:gad87feb82b6b2e9e61fe1600e052a3c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa21f23b324310b6d80d1d816060eaf6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#gaa21f23b324310b6d80d1d816060eaf6d">cx_slist_swap</a> (cx_slist *list1, cx_slist *list2)</td></tr>
<tr class="memdesc:gaa21f23b324310b6d80d1d816060eaf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the data of two lists.  <a href="group__cxslist.html#gaa21f23b324310b6d80d1d816060eaf6d">More...</a><br /></td></tr>
<tr class="separator:gaa21f23b324310b6d80d1d816060eaf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2068dfbd0bf591fed18906b72db9819c"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga2068dfbd0bf591fed18906b72db9819c">cx_slist_assign</a> (cx_slist *list, cx_slist_iterator position, cxcptr data)</td></tr>
<tr class="memdesc:ga2068dfbd0bf591fed18906b72db9819c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign data to a list position.  <a href="group__cxslist.html#ga2068dfbd0bf591fed18906b72db9819c">More...</a><br /></td></tr>
<tr class="separator:ga2068dfbd0bf591fed18906b72db9819c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b7a9a35951850e468f799292c8109bc"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga6b7a9a35951850e468f799292c8109bc">cx_slist_front</a> (const cx_slist *list)</td></tr>
<tr class="memdesc:ga6b7a9a35951850e468f799292c8109bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first element of a list.  <a href="group__cxslist.html#ga6b7a9a35951850e468f799292c8109bc">More...</a><br /></td></tr>
<tr class="separator:ga6b7a9a35951850e468f799292c8109bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed43a43577e6d722e6cf9f099ab5a2e"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#gabed43a43577e6d722e6cf9f099ab5a2e">cx_slist_back</a> (const cx_slist *list)</td></tr>
<tr class="memdesc:gabed43a43577e6d722e6cf9f099ab5a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last element of a list.  <a href="group__cxslist.html#gabed43a43577e6d722e6cf9f099ab5a2e">More...</a><br /></td></tr>
<tr class="separator:gabed43a43577e6d722e6cf9f099ab5a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga459fd3870613b4ab38025ec1e8b099bd"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga459fd3870613b4ab38025ec1e8b099bd">cx_slist_get</a> (const cx_slist *list, cx_slist_const_iterator position)</td></tr>
<tr class="memdesc:ga459fd3870613b4ab38025ec1e8b099bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data at a given iterator position.  <a href="group__cxslist.html#ga459fd3870613b4ab38025ec1e8b099bd">More...</a><br /></td></tr>
<tr class="separator:ga459fd3870613b4ab38025ec1e8b099bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4d21d53456a121e1ad7d260a0b94f6"><td class="memItemLeft" align="right" valign="top">cx_slist_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#gaef4d21d53456a121e1ad7d260a0b94f6">cx_slist_insert</a> (cx_slist *list, cx_slist_iterator position, cxcptr data)</td></tr>
<tr class="memdesc:gaef4d21d53456a121e1ad7d260a0b94f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into a list at a given iterator position.  <a href="group__cxslist.html#gaef4d21d53456a121e1ad7d260a0b94f6">More...</a><br /></td></tr>
<tr class="separator:gaef4d21d53456a121e1ad7d260a0b94f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7015e5460f7565302254a3207ba84a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#gaf7015e5460f7565302254a3207ba84a9">cx_slist_push_front</a> (cx_slist *list, cxcptr data)</td></tr>
<tr class="memdesc:gaf7015e5460f7565302254a3207ba84a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data at the beginning of a list.  <a href="group__cxslist.html#gaf7015e5460f7565302254a3207ba84a9">More...</a><br /></td></tr>
<tr class="separator:gaf7015e5460f7565302254a3207ba84a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8586b24228d56a60671ae6032ee9079c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga8586b24228d56a60671ae6032ee9079c">cx_slist_push_back</a> (cx_slist *list, cxcptr data)</td></tr>
<tr class="memdesc:ga8586b24228d56a60671ae6032ee9079c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append data at the end of a list.  <a href="group__cxslist.html#ga8586b24228d56a60671ae6032ee9079c">More...</a><br /></td></tr>
<tr class="separator:ga8586b24228d56a60671ae6032ee9079c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda28a16e504fb58b0bfb13f20ea585a"><td class="memItemLeft" align="right" valign="top">cx_slist_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#gadda28a16e504fb58b0bfb13f20ea585a">cx_slist_erase</a> (cx_slist *list, cx_slist_iterator position, cx_free_func deallocate)</td></tr>
<tr class="memdesc:gadda28a16e504fb58b0bfb13f20ea585a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a list list element.  <a href="group__cxslist.html#gadda28a16e504fb58b0bfb13f20ea585a">More...</a><br /></td></tr>
<tr class="separator:gadda28a16e504fb58b0bfb13f20ea585a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07ae2cd9b1c166b186af912c61042376"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga07ae2cd9b1c166b186af912c61042376">cx_slist_extract</a> (cx_slist *list, cx_slist_iterator position)</td></tr>
<tr class="memdesc:ga07ae2cd9b1c166b186af912c61042376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a list element.  <a href="group__cxslist.html#ga07ae2cd9b1c166b186af912c61042376">More...</a><br /></td></tr>
<tr class="separator:ga07ae2cd9b1c166b186af912c61042376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4027eb27840a32af8ffe73e7852f782e"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga4027eb27840a32af8ffe73e7852f782e">cx_slist_pop_front</a> (cx_slist *list)</td></tr>
<tr class="memdesc:ga4027eb27840a32af8ffe73e7852f782e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first list element.  <a href="group__cxslist.html#ga4027eb27840a32af8ffe73e7852f782e">More...</a><br /></td></tr>
<tr class="separator:ga4027eb27840a32af8ffe73e7852f782e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab21fa2691fbe5ae2ce8a0c6e32fef03e"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#gab21fa2691fbe5ae2ce8a0c6e32fef03e">cx_slist_pop_back</a> (cx_slist *list)</td></tr>
<tr class="memdesc:gab21fa2691fbe5ae2ce8a0c6e32fef03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element of a list.  <a href="group__cxslist.html#gab21fa2691fbe5ae2ce8a0c6e32fef03e">More...</a><br /></td></tr>
<tr class="separator:gab21fa2691fbe5ae2ce8a0c6e32fef03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31109b9ff6a392a67f45d5705ef2d56a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga31109b9ff6a392a67f45d5705ef2d56a">cx_slist_remove</a> (cx_slist *list, cxcptr data)</td></tr>
<tr class="memdesc:ga31109b9ff6a392a67f45d5705ef2d56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements with a given value from a list.  <a href="group__cxslist.html#ga31109b9ff6a392a67f45d5705ef2d56a">More...</a><br /></td></tr>
<tr class="separator:ga31109b9ff6a392a67f45d5705ef2d56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4e66c58a2f2f2859d4451a3e1effe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga1b4e66c58a2f2f2859d4451a3e1effe6">cx_slist_unique</a> (cx_slist *list, cx_compare_func compare)</td></tr>
<tr class="memdesc:ga1b4e66c58a2f2f2859d4451a3e1effe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicates of consecutive elements.  <a href="group__cxslist.html#ga1b4e66c58a2f2f2859d4451a3e1effe6">More...</a><br /></td></tr>
<tr class="separator:ga1b4e66c58a2f2f2859d4451a3e1effe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga548f89bcabdd3a563e068553ce67010f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga548f89bcabdd3a563e068553ce67010f">cx_slist_splice</a> (cx_slist *tlist, cx_slist_iterator position, cx_slist *slist, cx_slist_iterator first, cx_slist_iterator last)</td></tr>
<tr class="memdesc:ga548f89bcabdd3a563e068553ce67010f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a range of list elements in front of a given position.  <a href="group__cxslist.html#ga548f89bcabdd3a563e068553ce67010f">More...</a><br /></td></tr>
<tr class="separator:ga548f89bcabdd3a563e068553ce67010f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0c20786c9b3b4d0162efb7ed286a629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#gac0c20786c9b3b4d0162efb7ed286a629">cx_slist_merge</a> (cx_slist *list1, cx_slist *list2, cx_compare_func compare)</td></tr>
<tr class="memdesc:gac0c20786c9b3b4d0162efb7ed286a629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two sorted lists.  <a href="group__cxslist.html#gac0c20786c9b3b4d0162efb7ed286a629">More...</a><br /></td></tr>
<tr class="separator:gac0c20786c9b3b4d0162efb7ed286a629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d5ec2a32adc097c1bcfbdc537c3f90f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#ga9d5ec2a32adc097c1bcfbdc537c3f90f">cx_slist_sort</a> (cx_slist *list, cx_compare_func compare)</td></tr>
<tr class="memdesc:ga9d5ec2a32adc097c1bcfbdc537c3f90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all elements of a list using the given comparison function.  <a href="group__cxslist.html#ga9d5ec2a32adc097c1bcfbdc537c3f90f">More...</a><br /></td></tr>
<tr class="separator:ga9d5ec2a32adc097c1bcfbdc537c3f90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacba1bc3d6b5e7730fac425c667b2dcd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxslist.html#gacba1bc3d6b5e7730fac425c667b2dcd2">cx_slist_reverse</a> (cx_slist *list)</td></tr>
<tr class="memdesc:gacba1bc3d6b5e7730fac425c667b2dcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the order of all list elements.  <a href="group__cxslist.html#gacba1bc3d6b5e7730fac425c667b2dcd2">More...</a><br /></td></tr>
<tr class="separator:gacba1bc3d6b5e7730fac425c667b2dcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The module implements a linked list object restricted to iterations in just one direction and methods to create, destroy and manipulate it.</p>
<dl class="section user"><dt>Synopsis:</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cxslist.h&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2068dfbd0bf591fed18906b72db9819c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2068dfbd0bf591fed18906b72db9819c">&#9670;&nbsp;</a></span>cx_slist_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_slist_assign </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_slist_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign data to a list position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list. </td></tr>
    <tr><td class="paramname">position</td><td>List position where the data will be stored </td></tr>
    <tr><td class="paramname">data</td><td>Data to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the previously stored data object.</dd></dl>
<p>The function assigns the data object reference <em>data</em> to the iterator position <em>position</em> of the list <em>list</em>. </p>

</div>
</div>
<a id="gabed43a43577e6d722e6cf9f099ab5a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabed43a43577e6d722e6cf9f099ab5a2e">&#9670;&nbsp;</a></span>cx_slist_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_slist_back </td>
          <td>(</td>
          <td class="paramtype">const cx_slist *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last element of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object stored as the last list element.</dd></dl>
<p>The function returns a reference to the last data item in the list <em>list</em>. </p>

<p class="reference">References <a class="el" href="group__cxslist.html#ga7adcdaa81edd7cfac3c17e32e2477704">cx_slist_empty()</a>.</p>

</div>
</div>
<a id="ga40e56afd0a90dc1c8329b2b5c827d4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40e56afd0a90dc1c8329b2b5c827d4f8">&#9670;&nbsp;</a></span>cx_slist_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_slist_iterator cx_slist_begin </td>
          <td>(</td>
          <td class="paramtype">const cx_slist *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list iterator to the beginning of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the first element in the list, or <b><a class="el" href="group__cxslist.html#ga49f0318ea92ad85b07ea785ba2072896" title="Get a list iterator to the end of a list.">cx_slist_end()</a></b> if the list is empty.</dd></dl>
<p>The function returns a handle to the first element of <em>list</em>. The handle cannot be used directly to access the element data, but only through the appropriate functions. </p>

</div>
</div>
<a id="ga1842cad43628cb2e09fdd1e82579f501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1842cad43628cb2e09fdd1e82579f501">&#9670;&nbsp;</a></span>cx_slist_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_slist_clear </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements from a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>List to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The list <em>list</em> is cleared, i.e. all elements are removed from the list. The removed data objects are left untouched, in particular they are not deallocated. It is the responsibility of the caller to ensure that there still are other references to the removed data objects. After calling <b><a class="el" href="group__cxslist.html#ga1842cad43628cb2e09fdd1e82579f501" title="Remove all elements from a list.">cx_slist_clear()</a></b> the list <em>list</em> is empty. </p>

</div>
</div>
<a id="gaab85764bce368f99428c95479ae5240b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab85764bce368f99428c95479ae5240b">&#9670;&nbsp;</a></span>cx_slist_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_slist_delete </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function deallocates the list object, but not the data objects currently stored in the list. </p>

</div>
</div>
<a id="ga0edc236ae8857991e235f9172140c15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0edc236ae8857991e235f9172140c15e">&#9670;&nbsp;</a></span>cx_slist_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_slist_destroy </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_free_func&#160;</td>
          <td class="paramname"><em>deallocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a list and all its elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>List container to destroy. </td></tr>
    <tr><td class="paramname">deallocate</td><td>Data deallocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function deallocates all data objects referenced by the list using the data deallocation function <em>deallocate</em> and finally dealocates the list object itself. </p>

</div>
</div>
<a id="ga7adcdaa81edd7cfac3c17e32e2477704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7adcdaa81edd7cfac3c17e32e2477704">&#9670;&nbsp;</a></span>cx_slist_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxbool cx_slist_empty </td>
          <td>(</td>
          <td class="paramtype">const cx_slist *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a list is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <code>TRUE</code> if the list is empty, and <code>FALSE</code> otherwise.</dd></dl>
<p>The function tests if the list <em>list</em> contains data. A call to this function is equivalent to the statement:</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> (<a class="code" href="group__cxslist.html#gab219284235d39b70d4a02c8761bf6675">cx_slist_size</a>(list) == 0);</div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="group__cxslist.html#gabed43a43577e6d722e6cf9f099ab5a2e">cx_slist_back()</a>, and <a class="el" href="group__cxslist.html#ga6b7a9a35951850e468f799292c8109bc">cx_slist_front()</a>.</p>

</div>
</div>
<a id="ga49f0318ea92ad85b07ea785ba2072896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49f0318ea92ad85b07ea785ba2072896">&#9670;&nbsp;</a></span>cx_slist_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_slist_iterator cx_slist_end </td>
          <td>(</td>
          <td class="paramtype">const cx_slist *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list iterator to the end of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the end of the list.</dd></dl>
<p>The function returns an iterator for the position one past the last element of the list <em>list</em>. The handle cannot be used to directly access the element data, but only through the appropriate functions. </p>

</div>
</div>
<a id="gadda28a16e504fb58b0bfb13f20ea585a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadda28a16e504fb58b0bfb13f20ea585a">&#9670;&nbsp;</a></span>cx_slist_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_slist_iterator cx_slist_erase </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_slist_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_free_func&#160;</td>
          <td class="paramname"><em>deallocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a list list element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to update. </td></tr>
    <tr><td class="paramname">position</td><td>List iterator position. </td></tr>
    <tr><td class="paramname">deallocate</td><td>Data deallocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator for the list position after <em>position</em>.</dd></dl>
<p>The function removes the data object stored at position <em>position</em> from the list <em>list</em>. The data object is deallocated bz calling the data deallocator <em>deallocate</em>. </p>

</div>
</div>
<a id="ga07ae2cd9b1c166b186af912c61042376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07ae2cd9b1c166b186af912c61042376">&#9670;&nbsp;</a></span>cx_slist_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_slist_extract </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_slist_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a list element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list. </td></tr>
    <tr><td class="paramname">position</td><td>List iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the previously stored data object.</dd></dl>
<p>The function removes a data object from the list <em>list</em> located at the iterator position <em>position</em> without destroying the data object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxslist.html#gadda28a16e504fb58b0bfb13f20ea585a" title="Erase a list list element.">cx_slist_erase()</a>, <a class="el" href="group__cxslist.html#ga31109b9ff6a392a67f45d5705ef2d56a" title="Remove all elements with a given value from a list.">cx_slist_remove()</a> </dd></dl>

</div>
</div>
<a id="ga6b7a9a35951850e468f799292c8109bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b7a9a35951850e468f799292c8109bc">&#9670;&nbsp;</a></span>cx_slist_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_slist_front </td>
          <td>(</td>
          <td class="paramtype">const cx_slist *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first element of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object stored as the first list element.</dd></dl>
<p>The function returns a reference to the first data item in the list <em>list</em>. </p>

<p class="reference">References <a class="el" href="group__cxslist.html#ga7adcdaa81edd7cfac3c17e32e2477704">cx_slist_empty()</a>.</p>

</div>
</div>
<a id="ga459fd3870613b4ab38025ec1e8b099bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga459fd3870613b4ab38025ec1e8b099bd">&#9670;&nbsp;</a></span>cx_slist_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_slist_get </td>
          <td>(</td>
          <td class="paramtype">const cx_slist *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_slist_const_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data at a given iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list. </td></tr>
    <tr><td class="paramname">position</td><td>List position the data is retrieved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object.</dd></dl>
<p>The function returns a reference to the data item stored in the list <em>list</em> at the iterator position <em>position</em>. </p>

</div>
</div>
<a id="gaef4d21d53456a121e1ad7d260a0b94f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef4d21d53456a121e1ad7d260a0b94f6">&#9670;&nbsp;</a></span>cx_slist_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_slist_iterator cx_slist_insert </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_slist_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into a list at a given iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to update. </td></tr>
    <tr><td class="paramname">position</td><td>List iterator position. </td></tr>
    <tr><td class="paramname">data</td><td>Data item to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List iterator position of the inserted data item.</dd></dl>
<p>The function inserts the data handle <em>data</em> into the list <em>list</em> at the list position given by the list iterator <em>position</em>. </p>

</div>
</div>
<a id="gad87feb82b6b2e9e61fe1600e052a3c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad87feb82b6b2e9e61fe1600e052a3c0e">&#9670;&nbsp;</a></span>cx_slist_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_slist_max_size </td>
          <td>(</td>
          <td class="paramtype">const cx_slist *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum number of list elements possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of elements that can be stored in the list.</dd></dl>
<p>Retrieves the lists capacity, i.e. the maximum possible number of data items a list can hold. </p>

</div>
</div>
<a id="gac0c20786c9b3b4d0162efb7ed286a629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0c20786c9b3b4d0162efb7ed286a629">&#9670;&nbsp;</a></span>cx_slist_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_slist_merge </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_compare_func&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge two sorted lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list1</td><td>First list to merge. </td></tr>
    <tr><td class="paramname">list2</td><td>Second list to merge. </td></tr>
    <tr><td class="paramname">compare</td><td>Function comparing the list elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function combines the two lists <em>list1</em> and <em>list2</em> by moving all elements from <em>list2</em> into <em>list1</em>, so that all elements are still sorted. The function requires that both input lists are already sorted. The sorting order in which the elements of <em>list2</em> are inserted into <em>list1</em> is determined by the comparison function <em>compare</em>. The comparison function <em>compare</em> must return an integer less than, equal or greater than zero if the first argument passed to it is found, respectively, to be less than, match, or be greater than the second argument.</p>
<p>The list <em>list2</em> is consumed by this process, i.e. after the successful merging of the two lists, list <em>list2</em> will be empty. </p>

</div>
</div>
<a id="gacbeb18632065ead0f8d196264040a485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbeb18632065ead0f8d196264040a485">&#9670;&nbsp;</a></span>cx_slist_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_slist* cx_slist_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new list without any elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Handle to the newly allocated list.</dd></dl>
<p>The function allocates memory for the list object and initializes it to a empty list. </p>

<p class="reference">References <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab">cx_malloc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cxstrutils.html#ga63a07380a56b6934e69d0a59324daf9d">cx_strsplit()</a>.</p>

</div>
</div>
<a id="ga3f35965462d90e81a620e84949f4cd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f35965462d90e81a620e84949f4cd6c">&#9670;&nbsp;</a></span>cx_slist_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_slist_iterator cx_slist_next </td>
          <td>(</td>
          <td class="paramtype">const cx_slist *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_slist_const_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list iterator to the next list element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list. </td></tr>
    <tr><td class="paramname">position</td><td>Current iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the next list element.</dd></dl>
<p>The function returns an iterator for the next element in the list <em>list</em> with respect to the current iterator position <em>position</em>. If the list <em>list</em> is empty or <em>position</em> points to the list end the function returns <b><a class="el" href="group__cxslist.html#ga49f0318ea92ad85b07ea785ba2072896" title="Get a list iterator to the end of a list.">cx_slist_end()</a></b>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxslist.html#ga7adcdaa81edd7cfac3c17e32e2477704" title="Check whether a list is empty.">cx_slist_empty()</a> </dd></dl>

</div>
</div>
<a id="gab21fa2691fbe5ae2ce8a0c6e32fef03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab21fa2691fbe5ae2ce8a0c6e32fef03e">&#9670;&nbsp;</a></span>cx_slist_pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_slist_pop_back </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the last element of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to update.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object previously stored as the last list element.</dd></dl>
<p>The function removes the last element from the list <em>list</em> returning a handle to the previously stored data. </p>

</div>
</div>
<a id="ga4027eb27840a32af8ffe73e7852f782e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4027eb27840a32af8ffe73e7852f782e">&#9670;&nbsp;</a></span>cx_slist_pop_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_slist_pop_front </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the first list element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to update.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object previously stored as the last list element.</dd></dl>
<p>The function removes the first element from the list <em>list</em> returning a handle to the previously stored data. </p>

</div>
</div>
<a id="ga8586b24228d56a60671ae6032ee9079c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8586b24228d56a60671ae6032ee9079c">&#9670;&nbsp;</a></span>cx_slist_push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_slist_push_back </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append data at the end of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to update. </td></tr>
    <tr><td class="paramname">data</td><td>Data to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The data <em>data</em> is inserted into the list <em>list</em> after the last element, so that it becomes the new list tail.</p>
<p>It is equivalent to the statement </p><div class="fragment"><div class="line"><a class="code" href="group__cxslist.html#gaef4d21d53456a121e1ad7d260a0b94f6">cx_slist_insert</a>(list, <a class="code" href="group__cxslist.html#ga49f0318ea92ad85b07ea785ba2072896">cx_slist_end</a>(list), data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaf7015e5460f7565302254a3207ba84a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7015e5460f7565302254a3207ba84a9">&#9670;&nbsp;</a></span>cx_slist_push_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_slist_push_front </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data at the beginning of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to update. </td></tr>
    <tr><td class="paramname">data</td><td>Data to add to the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<p>The data <em>data</em> is inserted into the list <em>list</em> before the first element of the list, so that it becomes the new list head.</p>
<p>It is equivalent to the statement </p><div class="fragment"><div class="line"><a class="code" href="group__cxslist.html#gaef4d21d53456a121e1ad7d260a0b94f6">cx_slist_insert</a>(list, <a class="code" href="group__cxslist.html#ga40e56afd0a90dc1c8329b2b5c827d4f8">cx_slist_begin</a>(list), data);</div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="group__cxstrutils.html#ga63a07380a56b6934e69d0a59324daf9d">cx_strsplit()</a>.</p>

</div>
</div>
<a id="ga31109b9ff6a392a67f45d5705ef2d56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31109b9ff6a392a67f45d5705ef2d56a">&#9670;&nbsp;</a></span>cx_slist_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_slist_remove </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements with a given value from a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list object. </td></tr>
    <tr><td class="paramname">data</td><td>Data to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The value <em>data</em> is searched in the list <em>list</em>. If the data is found it is removed from the list. The data object itself is not deallocated. </p>

</div>
</div>
<a id="gacba1bc3d6b5e7730fac425c667b2dcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacba1bc3d6b5e7730fac425c667b2dcd2">&#9670;&nbsp;</a></span>cx_slist_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_slist_reverse </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the order of all list elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to reverse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The order of the elements of the list <em>list</em> is reversed. </p>

</div>
</div>
<a id="gab219284235d39b70d4a02c8761bf6675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab219284235d39b70d4a02c8761bf6675">&#9670;&nbsp;</a></span>cx_slist_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_slist_size </td>
          <td>(</td>
          <td class="paramtype">const cx_slist *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the actual number of list elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current number of elements the list contains, or 0 if the list is empty.</dd></dl>
<p>Retrieves the number of elements currently stored in the list <em>list</em>. </p>

</div>
</div>
<a id="ga9d5ec2a32adc097c1bcfbdc537c3f90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d5ec2a32adc097c1bcfbdc537c3f90f">&#9670;&nbsp;</a></span>cx_slist_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_slist_sort </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_compare_func&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort all elements of a list using the given comparison function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to sort. </td></tr>
    <tr><td class="paramname">compare</td><td>Function comparing the list elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The input list <em>list</em> is sorted using the comparison function <em>compare</em> to determine the order of two list elements. The comparison function <em>compare</em> must return an integer less than, equal or greater than zero if the first argument passed to it is found, respectively, to be less than, match, or be greater than the second argument. </p>

</div>
</div>
<a id="ga548f89bcabdd3a563e068553ce67010f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga548f89bcabdd3a563e068553ce67010f">&#9670;&nbsp;</a></span>cx_slist_splice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_slist_splice </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>tlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_slist_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>slist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_slist_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_slist_iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a range of list elements in front of a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tlist</td><td>Target list. </td></tr>
    <tr><td class="paramname">position</td><td>Target iterator position. </td></tr>
    <tr><td class="paramname">slist</td><td>Source list. </td></tr>
    <tr><td class="paramname">first</td><td>Position of the first element to move. </td></tr>
    <tr><td class="paramname">last</td><td>Position of the last element to move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The range of list elements from the iterator position <em>first</em> to <em>last</em>, but not including <em>last</em>, is moved from the source list <em>slist</em> in front of the position <em>position</em> of the target list <em>tlist</em>. Target and source list may be identical, provided that the target position <em>position</em> does not fall within the range of list elements to move. </p>

</div>
</div>
<a id="gaa21f23b324310b6d80d1d816060eaf6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa21f23b324310b6d80d1d816060eaf6d">&#9670;&nbsp;</a></span>cx_slist_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_slist_swap </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the data of two lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list1</td><td>First list. </td></tr>
    <tr><td class="paramname">list2</td><td>Second list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The contents of the first list <em>list1</em> will be moved to the second list <em>list2</em>, while the contents of <em>list2</em> is moved to <em>list1</em>. </p>

</div>
</div>
<a id="ga1b4e66c58a2f2f2859d4451a3e1effe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b4e66c58a2f2f2859d4451a3e1effe6">&#9670;&nbsp;</a></span>cx_slist_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_slist_unique </td>
          <td>(</td>
          <td class="paramtype">cx_slist *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_compare_func&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove duplicates of consecutive elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list. </td></tr>
    <tr><td class="paramname">compare</td><td>Function comparing the list elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function removes duplicates of consecutive list elements, i.e. list elements with the same value, from the list <em>list</em>. The equality of the list elements is checked using the comparison function <em>compare</em>. The comparison function <em>compare</em> must return an integer less than, equal or greater than zero if the first argument passed to it is found, respectively, to be less than, match, or be greater than the second argument. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__cxslist_html_ga40e56afd0a90dc1c8329b2b5c827d4f8"><div class="ttname"><a href="group__cxslist.html#ga40e56afd0a90dc1c8329b2b5c827d4f8">cx_slist_begin</a></div><div class="ttdeci">cx_slist_iterator cx_slist_begin(const cx_slist *list)</div><div class="ttdoc">Get list iterator to the beginning of a list.</div><div class="ttdef"><b>Definition:</b> cxslist.c:580</div></div>
<div class="ttc" id="agroup__cxslist_html_gaef4d21d53456a121e1ad7d260a0b94f6"><div class="ttname"><a href="group__cxslist.html#gaef4d21d53456a121e1ad7d260a0b94f6">cx_slist_insert</a></div><div class="ttdeci">cx_slist_iterator cx_slist_insert(cx_slist *list, cx_slist_iterator position, cxcptr data)</div><div class="ttdoc">Insert data into a list at a given iterator position.</div><div class="ttdef"><b>Definition:</b> cxslist.c:990</div></div>
<div class="ttc" id="agroup__cxslist_html_gab219284235d39b70d4a02c8761bf6675"><div class="ttname"><a href="group__cxslist.html#gab219284235d39b70d4a02c8761bf6675">cx_slist_size</a></div><div class="ttdeci">cxsize cx_slist_size(const cx_slist *list)</div><div class="ttdoc">Get the actual number of list elements.</div><div class="ttdef"><b>Definition:</b> cxslist.c:803</div></div>
<div class="ttc" id="agroup__cxslist_html_ga49f0318ea92ad85b07ea785ba2072896"><div class="ttname"><a href="group__cxslist.html#ga49f0318ea92ad85b07ea785ba2072896">cx_slist_end</a></div><div class="ttdeci">cx_slist_iterator cx_slist_end(const cx_slist *list)</div><div class="ttdoc">Get a list iterator to the end of a list.</div><div class="ttdef"><b>Definition:</b> cxslist.c:604</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
