<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Standard Library Extensions: Miscellaneous Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C Standard Library Extensions
   &#160;<span id="projectnumber">1.2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Miscellaneous Utilities</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2e3010cb1f5f44e0e064c798aebc4bbb"><td class="memItemLeft" align="right" valign="top">const cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxutils.html#ga2e3010cb1f5f44e0e064c798aebc4bbb">cx_program_get_name</a> (void)</td></tr>
<tr class="memdesc:ga2e3010cb1f5f44e0e064c798aebc4bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the application.  <a href="group__cxutils.html#ga2e3010cb1f5f44e0e064c798aebc4bbb">More...</a><br /></td></tr>
<tr class="separator:ga2e3010cb1f5f44e0e064c798aebc4bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98f021d0f4930900ace77052253f5808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxutils.html#ga98f021d0f4930900ace77052253f5808">cx_program_set_name</a> (const cxchar *name)</td></tr>
<tr class="memdesc:ga98f021d0f4930900ace77052253f5808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the application.  <a href="group__cxutils.html#ga98f021d0f4930900ace77052253f5808">More...</a><br /></td></tr>
<tr class="separator:ga98f021d0f4930900ace77052253f5808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53d3c63bd0f5132978afe8048170a6a5"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxutils.html#ga53d3c63bd0f5132978afe8048170a6a5">cx_bits_find</a> (cxuint32 mask, cxint start)</td></tr>
<tr class="memdesc:ga53d3c63bd0f5132978afe8048170a6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of the first bit set, searching from left to right.  <a href="group__cxutils.html#ga53d3c63bd0f5132978afe8048170a6a5">More...</a><br /></td></tr>
<tr class="separator:ga53d3c63bd0f5132978afe8048170a6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8477e3801214a0077bd545279cf4764"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxutils.html#gac8477e3801214a0077bd545279cf4764">cx_bits_rfind</a> (cxuint32 mask, cxint start)</td></tr>
<tr class="memdesc:gac8477e3801214a0077bd545279cf4764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of the first bit set, searching from right to left.  <a href="group__cxutils.html#gac8477e3801214a0077bd545279cf4764">More...</a><br /></td></tr>
<tr class="separator:gac8477e3801214a0077bd545279cf4764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0f5eb71a795d28fce21b6265189e85"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxutils.html#gaca0f5eb71a795d28fce21b6265189e85">cx_snprintf</a> (cxchar *string, cxsize n, const cxchar *format,...)</td></tr>
<tr class="memdesc:gaca0f5eb71a795d28fce21b6265189e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe version of <b>sprintf()</b>.  <a href="group__cxutils.html#gaca0f5eb71a795d28fce21b6265189e85">More...</a><br /></td></tr>
<tr class="separator:gaca0f5eb71a795d28fce21b6265189e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e848550cf5701e299759174e9b0ad89"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxutils.html#ga7e848550cf5701e299759174e9b0ad89">cx_vsnprintf</a> (cxchar *string, cxsize n, const cxchar *format, va_list args)</td></tr>
<tr class="memdesc:ga7e848550cf5701e299759174e9b0ad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe version of <b>vsprintf()</b>.  <a href="group__cxutils.html#ga7e848550cf5701e299759174e9b0ad89">More...</a><br /></td></tr>
<tr class="separator:ga7e848550cf5701e299759174e9b0ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3554360d3da7ab9dcf27978ae1d232e"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxutils.html#gaa3554360d3da7ab9dcf27978ae1d232e">cx_asprintf</a> (cxchar **string, const cxchar *format,...)</td></tr>
<tr class="memdesc:gaa3554360d3da7ab9dcf27978ae1d232e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write formatted output to a newly allocated string.  <a href="group__cxutils.html#gaa3554360d3da7ab9dcf27978ae1d232e">More...</a><br /></td></tr>
<tr class="separator:gaa3554360d3da7ab9dcf27978ae1d232e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0864ab11701a3596082a3317d94dddf9"><td class="memItemLeft" align="right" valign="top">cxint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxutils.html#ga0864ab11701a3596082a3317d94dddf9">cx_vasprintf</a> (cxchar **string, const cxchar *format, va_list args)</td></tr>
<tr class="memdesc:ga0864ab11701a3596082a3317d94dddf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write formatted output to a newly allocated string with a variable-length argument list.  <a href="group__cxutils.html#ga0864ab11701a3596082a3317d94dddf9">More...</a><br /></td></tr>
<tr class="separator:ga0864ab11701a3596082a3317d94dddf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1081630631464bf91fa7e5fce5228854"><td class="memItemLeft" align="right" valign="top">cxlong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxutils.html#ga1081630631464bf91fa7e5fce5228854">cx_line_max</a> (void)</td></tr>
<tr class="memdesc:ga1081630631464bf91fa7e5fce5228854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum length of a line supported by the system.  <a href="group__cxutils.html#ga1081630631464bf91fa7e5fce5228854">More...</a><br /></td></tr>
<tr class="separator:ga1081630631464bf91fa7e5fce5228854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91f78cad9b32274b77051bf75178d023"><td class="memItemLeft" align="right" valign="top">cxchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxutils.html#ga91f78cad9b32274b77051bf75178d023">cx_line_alloc</a> (void)</td></tr>
<tr class="memdesc:ga91f78cad9b32274b77051bf75178d023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a line buffer with the maximum size supported by the system.  <a href="group__cxutils.html#ga91f78cad9b32274b77051bf75178d023">More...</a><br /></td></tr>
<tr class="separator:ga91f78cad9b32274b77051bf75178d023"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The module provides a portable implementation of a selection of miscellaneous utility functions.</p>
<dl class="section user"><dt>Synopsis:</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cxutils.h&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa3554360d3da7ab9dcf27978ae1d232e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3554360d3da7ab9dcf27978ae1d232e">&#9670;&nbsp;</a></span>cx_asprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_asprintf </td>
          <td>(</td>
          <td class="paramtype">cxchar **&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write formatted output to a newly allocated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>Address where the allocated string is stored. </td></tr>
    <tr><td class="paramname">format</td><td>The format string. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments to be inserted into the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters (excluding the trailing null) written to allocated string, i.e. its length. If sufficient space cannot be allocated, -1 is returned.</dd></dl>
<p>The function is similar to <b><a class="el" href="group__cxutils.html#gaca0f5eb71a795d28fce21b6265189e85" title="Safe version of sprintf().">cx_snprintf()</a></b> or <b>sprintf()</b>. The difference to <b><a class="el" href="group__cxutils.html#gaca0f5eb71a795d28fce21b6265189e85" title="Safe version of sprintf().">cx_snprintf()</a></b> is that the output created from the format string <em>format</em> and the formatted arguments is placed into a string which is allocated using <b><a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab" title="Allocate nbytes bytes.">cx_malloc()</a></b>. All standard C conversion directives are supported. The allocated string is always null terminated.</p>
<p>The pointer to the allocated string buffer sufficiently large to hold the string is returned to the caller in the <em>string</em> argument. This pointer should be passed to <b>cx_free</b> to release the allocated storage when it is no longer needed. If sufficient memory cannot be allocated <em>is</em> set to <code>NULL</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxutils.html#gaca0f5eb71a795d28fce21b6265189e85" title="Safe version of sprintf().">cx_snprintf()</a>, cx_strdupf(), <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab" title="Allocate nbytes bytes.">cx_malloc()</a>, <a class="el" href="group__cxmemory.html#ga535a509573c6617da8f0dccdb2710bc9" title="Memory block deallocation.">cx_free()</a> </dd></dl>

<p class="reference">References <a class="el" href="group__cxutils.html#ga0864ab11701a3596082a3317d94dddf9">cx_vasprintf()</a>.</p>

</div>
</div>
<a id="ga53d3c63bd0f5132978afe8048170a6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53d3c63bd0f5132978afe8048170a6a5">&#9670;&nbsp;</a></span>cx_bits_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_bits_find </td>
          <td>(</td>
          <td class="paramtype">cxuint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxint&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the position of the first bit set, searching from left to right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>A 32 bit integer containing bit flags. </td></tr>
    <tr><td class="paramname">start</td><td>Bit position where the search starts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit position of the first bit set which is lower than <em>start</em>. If no bit is set -1 is returned.</dd></dl>
<p>The function searches for the first bit set in <em>mask</em>, starting at the bit position <em>start</em> - 1. The bit mask <em>mask</em> is searched from left to right. If <em>start</em> is less than 0 or bigger than 32 the search starts at the 31st bit.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxutils.html#gac8477e3801214a0077bd545279cf4764" title="Get the position of the first bit set, searching from right to left.">cx_bits_rfind()</a> </dd></dl>

</div>
</div>
<a id="gac8477e3801214a0077bd545279cf4764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8477e3801214a0077bd545279cf4764">&#9670;&nbsp;</a></span>cx_bits_rfind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_bits_rfind </td>
          <td>(</td>
          <td class="paramtype">cxuint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxint&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the position of the first bit set, searching from right to left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>A 32 bit integer containing bit flags. </td></tr>
    <tr><td class="paramname">start</td><td>Bit position where the search starts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit position of the first bit set which is higher than <em>start</em>. If no bit is set -1 is returned.</dd></dl>
<p>The function searches for the first bit set in <em>mask</em>, starting at the bit position <em>start</em> + 1. The bit mask <em>mask</em> is searched from right to left. If <em>start</em> is less than 0 the search starts at the 1st bit.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxutils.html#ga53d3c63bd0f5132978afe8048170a6a5" title="Get the position of the first bit set, searching from left to right.">cx_bits_find()</a> </dd></dl>

</div>
</div>
<a id="ga91f78cad9b32274b77051bf75178d023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91f78cad9b32274b77051bf75178d023">&#9670;&nbsp;</a></span>cx_line_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxchar* cx_line_alloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a line buffer with the maximum size supported by the system. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer allocated memory.</dd></dl>
<p>The function creates a line buffer with the maximum length supported by the system. The size of the buffer is determined calling <b><a class="el" href="group__cxutils.html#ga1081630631464bf91fa7e5fce5228854" title="Get the maximum length of a line supported by the system.">cx_line_max()</a></b> which gives the maximum size including the trailing zero. </p>

<p class="reference">References <a class="el" href="group__cxmemory.html#gad6e24975b7161a4d3f5fe49fd84df740">cx_calloc()</a>, and <a class="el" href="group__cxutils.html#ga1081630631464bf91fa7e5fce5228854">cx_line_max()</a>.</p>

</div>
</div>
<a id="ga1081630631464bf91fa7e5fce5228854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1081630631464bf91fa7e5fce5228854">&#9670;&nbsp;</a></span>cx_line_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxlong cx_line_max </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum length of a line supported by the system. </p>
<dl class="section return"><dt>Returns</dt><dd>The length of a line including the trailing zero.</dd></dl>
<p>The function uses the <b>sysconf()</b> function to determine the maximum length of a line buffer that is supported by the system and available for utility programs. If the <b>sysconf()</b> facility is not available the function returns a guessed value of 4096 characters as the maximum length of a line taking into account the trailing zero. </p>

<p class="reference">Referenced by <a class="el" href="group__cxutils.html#ga91f78cad9b32274b77051bf75178d023">cx_line_alloc()</a>.</p>

</div>
</div>
<a id="ga2e3010cb1f5f44e0e064c798aebc4bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e3010cb1f5f44e0e064c798aebc4bbb">&#9670;&nbsp;</a></span>cx_program_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cxchar* cx_program_get_name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the application. </p>
<dl class="section return"><dt>Returns</dt><dd>The program's name string.</dd></dl>
<p>The program's name is retrieved and returned to the caller. The returned pointer is a library resource and must not be freed or modified. </p>

</div>
</div>
<a id="ga98f021d0f4930900ace77052253f5808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98f021d0f4930900ace77052253f5808">&#9670;&nbsp;</a></span>cx_program_set_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_program_set_name </td>
          <td>(</td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the name of the application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The program name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The program's name is set to the string <em>name</em>.</p>
<dl class="section attention"><dt>Attention</dt><dd>For thread-safety reasons this function may be called only once! </dd></dl>

</div>
</div>
<a id="gaca0f5eb71a795d28fce21b6265189e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca0f5eb71a795d28fce21b6265189e85">&#9670;&nbsp;</a></span>cx_snprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_snprintf </td>
          <td>(</td>
          <td class="paramtype">cxchar *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxsize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe version of <b>sprintf()</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>Destination string. </td></tr>
    <tr><td class="paramname">n</td><td>Maximum number of characters to be written. </td></tr>
    <tr><td class="paramname">format</td><td>The format string. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments to be inserted into the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters (excluding the trailing null) which would have been written to the destination string if enough space had been available, i.e. if the destination string is large enough the function returns the number of characters written to the string.</dd></dl>
<p>The function is a safe form of <b>sprintf()</b>. It writes output to the string <em>string</em>, under the control of the format string <em>format</em>. The format string specifies how the arguments are formatted for output. All standard C conversion directives are supported.</p>
<p>The difference compared to <b>sprintf()</b> is that the produced number of characters does not exceed <em>n</em> (including the trailing null).</p>
<dl class="section note"><dt>Note</dt><dd>The return value of <b><a class="el" href="group__cxutils.html#gaca0f5eb71a795d28fce21b6265189e85" title="Safe version of sprintf().">cx_snprintf()</a></b> conforms to the <b>snprintf()</b> function as standardized in ISO C99. This might be different from traditional implementations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxutils.html#gaa3554360d3da7ab9dcf27978ae1d232e" title="Write formatted output to a newly allocated string.">cx_asprintf()</a>, cx_strdupf() </dd></dl>

<p class="reference">References <a class="el" href="group__cxutils.html#ga7e848550cf5701e299759174e9b0ad89">cx_vsnprintf()</a>.</p>

</div>
</div>
<a id="ga0864ab11701a3596082a3317d94dddf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0864ab11701a3596082a3317d94dddf9">&#9670;&nbsp;</a></span>cx_vasprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_vasprintf </td>
          <td>(</td>
          <td class="paramtype">cxchar **&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write formatted output to a newly allocated string with a variable-length argument list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>Address where the allocated string is stored. </td></tr>
    <tr><td class="paramname">format</td><td>The format string. </td></tr>
    <tr><td class="paramname">args</td><td>List of arguments to be inserted into the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters (excluding the trailing null) written to allocated string, i.e. its length. If sufficient space cannot be allocated, -1 is returned.</dd></dl>
<p>The function is similar to <b><a class="el" href="group__cxutils.html#ga7e848550cf5701e299759174e9b0ad89" title="Safe version of vsprintf().">cx_vsnprintf()</a></b> or <b>vsprintf()</b>. The difference to <b><a class="el" href="group__cxutils.html#ga7e848550cf5701e299759174e9b0ad89" title="Safe version of vsprintf().">cx_vsnprintf()</a></b> is that the output, created from the format string <em>format</em> and the arguments given by the variable-length argument list <em>args</em>, is placed into a string which is allocated using <b><a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab" title="Allocate nbytes bytes.">cx_malloc()</a></b>. All standard C conversion directives are supported. The allocated string is always null terminated.</p>
<p>The pointer to the allocated string buffer sufficiently large to hold the string is returned to the caller in the <em>string</em> argument. This pointer should be passed to <b>cx_free</b> to release the allocated storage when it is no longer needed. If sufficient memory cannot be allocated <em>is</em> set to <code>NULL</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxutils.html#ga7e848550cf5701e299759174e9b0ad89" title="Safe version of vsprintf().">cx_vsnprintf()</a>, <a class="el" href="group__cxstrutils.html#gac6e42a2da10486d296fbac13afe2aeee" title="Create a string from a variable-length argument list under format control.">cx_strvdupf()</a>, <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab" title="Allocate nbytes bytes.">cx_malloc()</a>, <a class="el" href="group__cxmemory.html#ga535a509573c6617da8f0dccdb2710bc9" title="Memory block deallocation.">cx_free()</a> </dd></dl>

<p class="reference">References <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab">cx_malloc()</a>, <a class="el" href="group__cxmemory.html#gae489c929c01055ebf1fd49b2148c2f92">cx_memory_is_system_malloc()</a>, <a class="el" href="group__cxstrutils.html#gab5820e4271a2d9bfbad3b5612cfca159">cx_strdup()</a>, and <a class="el" href="group__cxutils.html#ga7e848550cf5701e299759174e9b0ad89">cx_vsnprintf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cxutils.html#gaa3554360d3da7ab9dcf27978ae1d232e">cx_asprintf()</a>, and <a class="el" href="group__cxstrutils.html#gac6e42a2da10486d296fbac13afe2aeee">cx_strvdupf()</a>.</p>

</div>
</div>
<a id="ga7e848550cf5701e299759174e9b0ad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e848550cf5701e299759174e9b0ad89">&#9670;&nbsp;</a></span>cx_vsnprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxint cx_vsnprintf </td>
          <td>(</td>
          <td class="paramtype">cxchar *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxsize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxchar *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe version of <b>vsprintf()</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>Destination string. </td></tr>
    <tr><td class="paramname">n</td><td>Maximum number of characters to be written. </td></tr>
    <tr><td class="paramname">format</td><td>The format string. </td></tr>
    <tr><td class="paramname">args</td><td>List of arguments to be inserted into the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters (excluding the trailing null) which would have been written to the destination string if enough space had been available, i.e. if the destination string is large enough the function returns the number of characters written to the string.</dd></dl>
<p>The function is a safe form of <b>vsprintf()</b>. It writes output to the string <em>string</em>, under the control of the format string <em>format</em>. The format string specifies how the arguments, provided through the variable-length argument list <em>args</em>, are formatted for output. All standard C conversion directives are supported.</p>
<p>The difference compared to <b>vsprintf()</b> is that the produced number of characters does not exceed <em>n</em> (including the trailing null).</p>
<dl class="section note"><dt>Note</dt><dd>The return value of <b><a class="el" href="group__cxutils.html#ga7e848550cf5701e299759174e9b0ad89" title="Safe version of vsprintf().">cx_vsnprintf()</a></b> conforms to the <b>vsnprintf()</b> function as standardized in ISO C99. This might be different from traditional implementations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxutils.html#ga0864ab11701a3596082a3317d94dddf9" title="Write formatted output to a newly allocated string with a variable-length argument list.">cx_vasprintf()</a>, <a class="el" href="group__cxstrutils.html#gac6e42a2da10486d296fbac13afe2aeee" title="Create a string from a variable-length argument list under format control.">cx_strvdupf()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__cxutils.html#gaca0f5eb71a795d28fce21b6265189e85">cx_snprintf()</a>, and <a class="el" href="group__cxutils.html#ga0864ab11701a3596082a3317d94dddf9">cx_vasprintf()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
