<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Standard Library Extensions: Multi Maps</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C Standard Library Extensions
   &#160;<span id="projectnumber">1.2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Multi Maps</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga06de3578571e65ae6049492f2610553a"><td class="memItemLeft" align="right" valign="top">typedef cx_tree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a></td></tr>
<tr class="memdesc:ga06de3578571e65ae6049492f2610553a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multimap datatype.  <a href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">More...</a><br /></td></tr>
<tr class="separator:ga06de3578571e65ae6049492f2610553a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f97bd4509ae71db017fa329b5d4a16c"><td class="memItemLeft" align="right" valign="top">typedef cx_tree_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a></td></tr>
<tr class="memdesc:ga7f97bd4509ae71db017fa329b5d4a16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multimap iterator datatype.  <a href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">More...</a><br /></td></tr>
<tr class="separator:ga7f97bd4509ae71db017fa329b5d4a16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0649c126aa1a71d58823fb7271a16f7"><td class="memItemLeft" align="right" valign="top">typedef cx_tree_const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#gab0649c126aa1a71d58823fb7271a16f7">cx_multimap_const_iterator</a></td></tr>
<tr class="memdesc:gab0649c126aa1a71d58823fb7271a16f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multimap constant iterator datatype.  <a href="group__cxmultimap.html#gab0649c126aa1a71d58823fb7271a16f7">More...</a><br /></td></tr>
<tr class="separator:gab0649c126aa1a71d58823fb7271a16f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf600553e79dfd1dab23202a0fad67db5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__cxtree.html#ga0fba28796f9eaa709022e98cbb4f7d0e">cx_tree_compare_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#gaf600553e79dfd1dab23202a0fad67db5">cx_multimap_compare_func</a></td></tr>
<tr class="memdesc:gaf600553e79dfd1dab23202a0fad67db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multimap's key comparison operator function.  <a href="group__cxmultimap.html#gaf600553e79dfd1dab23202a0fad67db5">More...</a><br /></td></tr>
<tr class="separator:gaf600553e79dfd1dab23202a0fad67db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf08e21b17216433c2f4b9f5c8482abcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#gaf08e21b17216433c2f4b9f5c8482abcb">cx_multimap_begin</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap)</td></tr>
<tr class="memdesc:gaf08e21b17216433c2f4b9f5c8482abcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first pair in a multimap.  <a href="group__cxmultimap.html#gaf08e21b17216433c2f4b9f5c8482abcb">More...</a><br /></td></tr>
<tr class="separator:gaf08e21b17216433c2f4b9f5c8482abcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0664926c1144abc42ff45630398cff3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga0664926c1144abc42ff45630398cff3b">cx_multimap_end</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap)</td></tr>
<tr class="memdesc:ga0664926c1144abc42ff45630398cff3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the position after the last pair in the multimap.  <a href="group__cxmultimap.html#ga0664926c1144abc42ff45630398cff3b">More...</a><br /></td></tr>
<tr class="separator:ga0664926c1144abc42ff45630398cff3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4675ececca240fd93a696273d94fd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga3e4675ececca240fd93a696273d94fd0">cx_multimap_next</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, <a class="el" href="group__cxmultimap.html#gab0649c126aa1a71d58823fb7271a16f7">cx_multimap_const_iterator</a> position)</td></tr>
<tr class="memdesc:ga3e4675ececca240fd93a696273d94fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the next pair in the multimap.  <a href="group__cxmultimap.html#ga3e4675ececca240fd93a696273d94fd0">More...</a><br /></td></tr>
<tr class="separator:ga3e4675ececca240fd93a696273d94fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436f55eebc0e96500579067a898361eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga436f55eebc0e96500579067a898361eb">cx_multimap_previous</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, <a class="el" href="group__cxmultimap.html#gab0649c126aa1a71d58823fb7271a16f7">cx_multimap_const_iterator</a> position)</td></tr>
<tr class="memdesc:ga436f55eebc0e96500579067a898361eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the previous pair in the multimap.  <a href="group__cxmultimap.html#ga436f55eebc0e96500579067a898361eb">More...</a><br /></td></tr>
<tr class="separator:ga436f55eebc0e96500579067a898361eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e85e7fc13400eeb700066810e91e52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga04e85e7fc13400eeb700066810e91e52">cx_multimap_clear</a> (<a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap)</td></tr>
<tr class="memdesc:ga04e85e7fc13400eeb700066810e91e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all pairs from a multimap.  <a href="group__cxmultimap.html#ga04e85e7fc13400eeb700066810e91e52">More...</a><br /></td></tr>
<tr class="separator:ga04e85e7fc13400eeb700066810e91e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51fe454733ae3155f12a2b4f1242eae6"><td class="memItemLeft" align="right" valign="top">cxbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga51fe454733ae3155f12a2b4f1242eae6">cx_multimap_empty</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap)</td></tr>
<tr class="memdesc:ga51fe454733ae3155f12a2b4f1242eae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a multimap is empty.  <a href="group__cxmultimap.html#ga51fe454733ae3155f12a2b4f1242eae6">More...</a><br /></td></tr>
<tr class="separator:ga51fe454733ae3155f12a2b4f1242eae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f7489b10291e6dbf257974f33fe00ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga2f7489b10291e6dbf257974f33fe00ad">cx_multimap_new</a> (<a class="el" href="group__cxmultimap.html#gaf600553e79dfd1dab23202a0fad67db5">cx_multimap_compare_func</a> compare, cx_free_func key_destroy, cx_free_func value_destroy)</td></tr>
<tr class="memdesc:ga2f7489b10291e6dbf257974f33fe00ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new multimap without any elements.  <a href="group__cxmultimap.html#ga2f7489b10291e6dbf257974f33fe00ad">More...</a><br /></td></tr>
<tr class="separator:ga2f7489b10291e6dbf257974f33fe00ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91edddb80f050169933450acf0be4d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#gab91edddb80f050169933450acf0be4d2">cx_multimap_delete</a> (<a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap)</td></tr>
<tr class="memdesc:gab91edddb80f050169933450acf0be4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a multimap and all its elements.  <a href="group__cxmultimap.html#gab91edddb80f050169933450acf0be4d2">More...</a><br /></td></tr>
<tr class="separator:gab91edddb80f050169933450acf0be4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5829ebe763fb7cfbfa895560e773dd0"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#gac5829ebe763fb7cfbfa895560e773dd0">cx_multimap_size</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap)</td></tr>
<tr class="memdesc:gac5829ebe763fb7cfbfa895560e773dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual number of pairs in the multimap.  <a href="group__cxmultimap.html#gac5829ebe763fb7cfbfa895560e773dd0">More...</a><br /></td></tr>
<tr class="separator:gac5829ebe763fb7cfbfa895560e773dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb5a94c2aa80f245c6c29f32786830e"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga5cb5a94c2aa80f245c6c29f32786830e">cx_multimap_max_size</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap)</td></tr>
<tr class="memdesc:ga5cb5a94c2aa80f245c6c29f32786830e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of pairs possible.  <a href="group__cxmultimap.html#ga5cb5a94c2aa80f245c6c29f32786830e">More...</a><br /></td></tr>
<tr class="separator:ga5cb5a94c2aa80f245c6c29f32786830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gababd9f0e9931b1719e7ccadb41c96c26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmultimap.html#gaf600553e79dfd1dab23202a0fad67db5">cx_multimap_compare_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#gababd9f0e9931b1719e7ccadb41c96c26">cx_multimap_key_comp</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap)</td></tr>
<tr class="memdesc:gababd9f0e9931b1719e7ccadb41c96c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a multimap's key comparison function.  <a href="group__cxmultimap.html#gababd9f0e9931b1719e7ccadb41c96c26">More...</a><br /></td></tr>
<tr class="separator:gababd9f0e9931b1719e7ccadb41c96c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9007e9259934869c4bd71156b1b038dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga9007e9259934869c4bd71156b1b038dc">cx_multimap_swap</a> (<a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap1, <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap2)</td></tr>
<tr class="memdesc:ga9007e9259934869c4bd71156b1b038dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of two multimaps.  <a href="group__cxmultimap.html#ga9007e9259934869c4bd71156b1b038dc">More...</a><br /></td></tr>
<tr class="separator:ga9007e9259934869c4bd71156b1b038dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c94b9833c1e2940c0cb626568c0e41"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#gae2c94b9833c1e2940c0cb626568c0e41">cx_multimap_assign</a> (<a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, <a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> position, cxcptr data)</td></tr>
<tr class="memdesc:gae2c94b9833c1e2940c0cb626568c0e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign data to an iterator position.  <a href="group__cxmultimap.html#gae2c94b9833c1e2940c0cb626568c0e41">More...</a><br /></td></tr>
<tr class="separator:gae2c94b9833c1e2940c0cb626568c0e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca42be4a86255128ff7fbd9d060422b7"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#gaca42be4a86255128ff7fbd9d060422b7">cx_multimap_get_key</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, <a class="el" href="group__cxmultimap.html#gab0649c126aa1a71d58823fb7271a16f7">cx_multimap_const_iterator</a> position)</td></tr>
<tr class="memdesc:gaca42be4a86255128ff7fbd9d060422b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the key from a given iterator position.  <a href="group__cxmultimap.html#gaca42be4a86255128ff7fbd9d060422b7">More...</a><br /></td></tr>
<tr class="separator:gaca42be4a86255128ff7fbd9d060422b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6457c9e3b6c522352d9500fd23ff634"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#gad6457c9e3b6c522352d9500fd23ff634">cx_multimap_get_value</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, <a class="el" href="group__cxmultimap.html#gab0649c126aa1a71d58823fb7271a16f7">cx_multimap_const_iterator</a> position)</td></tr>
<tr class="memdesc:gad6457c9e3b6c522352d9500fd23ff634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data from a given iterator position.  <a href="group__cxmultimap.html#gad6457c9e3b6c522352d9500fd23ff634">More...</a><br /></td></tr>
<tr class="separator:gad6457c9e3b6c522352d9500fd23ff634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada385132d40cf231aa6e2c7da61ebd4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#gada385132d40cf231aa6e2c7da61ebd4e">cx_multimap_find</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, cxcptr key)</td></tr>
<tr class="memdesc:gada385132d40cf231aa6e2c7da61ebd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate an element in the multimap.  <a href="group__cxmultimap.html#gada385132d40cf231aa6e2c7da61ebd4e">More...</a><br /></td></tr>
<tr class="separator:gada385132d40cf231aa6e2c7da61ebd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b8519646c0823f93349524ca64944fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga7b8519646c0823f93349524ca64944fe">cx_multimap_lower_bound</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, cxcptr key)</td></tr>
<tr class="memdesc:ga7b8519646c0823f93349524ca64944fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the beginning of a subsequence matching a given key.  <a href="group__cxmultimap.html#ga7b8519646c0823f93349524ca64944fe">More...</a><br /></td></tr>
<tr class="separator:ga7b8519646c0823f93349524ca64944fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga921040ae538ae0f1d3de3ec28f7bf151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga921040ae538ae0f1d3de3ec28f7bf151">cx_multimap_upper_bound</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, cxcptr key)</td></tr>
<tr class="memdesc:ga921040ae538ae0f1d3de3ec28f7bf151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the end of a subsequence matching a given key.  <a href="group__cxmultimap.html#ga921040ae538ae0f1d3de3ec28f7bf151">More...</a><br /></td></tr>
<tr class="separator:ga921040ae538ae0f1d3de3ec28f7bf151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084d0d468f5f6074113f60a5560dce34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga084d0d468f5f6074113f60a5560dce34">cx_multimap_equal_range</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, cxcptr key, <a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> *begin, <a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> *end)</td></tr>
<tr class="memdesc:ga084d0d468f5f6074113f60a5560dce34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a subsequence matching a given key.  <a href="group__cxmultimap.html#ga084d0d468f5f6074113f60a5560dce34">More...</a><br /></td></tr>
<tr class="separator:ga084d0d468f5f6074113f60a5560dce34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70527409d50026c0cfb85c491a55457d"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga70527409d50026c0cfb85c491a55457d">cx_multimap_count</a> (const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, cxcptr key)</td></tr>
<tr class="memdesc:ga70527409d50026c0cfb85c491a55457d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements matching a key.  <a href="group__cxmultimap.html#ga70527409d50026c0cfb85c491a55457d">More...</a><br /></td></tr>
<tr class="separator:ga70527409d50026c0cfb85c491a55457d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6281914a4c8a9b5582758b4e90c527b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga6281914a4c8a9b5582758b4e90c527b4">cx_multimap_insert</a> (<a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, cxcptr key, cxcptr data)</td></tr>
<tr class="memdesc:ga6281914a4c8a9b5582758b4e90c527b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into a multimap.  <a href="group__cxmultimap.html#ga6281914a4c8a9b5582758b4e90c527b4">More...</a><br /></td></tr>
<tr class="separator:ga6281914a4c8a9b5582758b4e90c527b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace135776d124d74eada48b654abcfe04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#gace135776d124d74eada48b654abcfe04">cx_multimap_erase_position</a> (<a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, <a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> position)</td></tr>
<tr class="memdesc:gace135776d124d74eada48b654abcfe04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element from a multimap.  <a href="group__cxmultimap.html#gace135776d124d74eada48b654abcfe04">More...</a><br /></td></tr>
<tr class="separator:gace135776d124d74eada48b654abcfe04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga567a2280d596e10e11c4806fe8df99f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga567a2280d596e10e11c4806fe8df99f5">cx_multimap_erase_range</a> (<a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, <a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> begin, <a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> end)</td></tr>
<tr class="memdesc:ga567a2280d596e10e11c4806fe8df99f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a range of elements from a multimap.  <a href="group__cxmultimap.html#ga567a2280d596e10e11c4806fe8df99f5">More...</a><br /></td></tr>
<tr class="separator:ga567a2280d596e10e11c4806fe8df99f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4445b5eb32f7452f56a0045dda373f94"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxmultimap.html#ga4445b5eb32f7452f56a0045dda373f94">cx_multimap_erase</a> (<a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *multimap, cxcptr key)</td></tr>
<tr class="memdesc:ga4445b5eb32f7452f56a0045dda373f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element from a multimap according to the provided key.  <a href="group__cxmultimap.html#ga4445b5eb32f7452f56a0045dda373f94">More...</a><br /></td></tr>
<tr class="separator:ga4445b5eb32f7452f56a0045dda373f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The module implements a map data type, i.e. a container managing key/value pairs as elements. Their elements are automatically sorted according to a sorting criterion used for the key. The container is optimized for lookup operations. Contrary to ordinary maps a multimap is not restricted to unique keys, but may contain multiple duplicate keys.</p>
<dl class="section user"><dt>Synopsis:</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cxmultimap.h&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga06de3578571e65ae6049492f2610553a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06de3578571e65ae6049492f2610553a">&#9670;&nbsp;</a></span>cx_multimap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef cx_tree <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The multimap datatype. </p>
<p>The internal representation of a mutimap is, as for ordinary maps too, a balanced binary tree. For this reason cx_multimap is just an alias for cx_tree. </p>

</div>
</div>
<a id="gaf600553e79dfd1dab23202a0fad67db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf600553e79dfd1dab23202a0fad67db5">&#9670;&nbsp;</a></span>cx_multimap_compare_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__cxtree.html#ga0fba28796f9eaa709022e98cbb4f7d0e">cx_tree_compare_func</a> <a class="el" href="group__cxmultimap.html#gaf600553e79dfd1dab23202a0fad67db5">cx_multimap_compare_func</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The multimap's key comparison operator function. </p>
<p>This type of function is used internally by a multimap when key comparisons are necessary. It must return <code>TRUE</code> if the comparison of its first argument with the second argument succeeds, and <code>FALSE</code> otherwise. It is actually an alias for cx_tree_compare_func.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxtree.html#ga0fba28796f9eaa709022e98cbb4f7d0e" title="The tree&#39;s key comparison operator function.">cx_tree_compare_func</a> </dd></dl>

</div>
</div>
<a id="gab0649c126aa1a71d58823fb7271a16f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0649c126aa1a71d58823fb7271a16f7">&#9670;&nbsp;</a></span>cx_multimap_const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef cx_tree_const_iterator <a class="el" href="group__cxmultimap.html#gab0649c126aa1a71d58823fb7271a16f7">cx_multimap_const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The multimap constant iterator datatype. </p>
<p>The multimap constant iterator is just an alias for the cx_tree_const_iterator datatype. </p>

</div>
</div>
<a id="ga7f97bd4509ae71db017fa329b5d4a16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f97bd4509ae71db017fa329b5d4a16c">&#9670;&nbsp;</a></span>cx_multimap_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef cx_tree_iterator <a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The multimap iterator datatype. </p>
<p>The multimap iterator is just an alias for the cx_tree_iterator datatype. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae2c94b9833c1e2940c0cb626568c0e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2c94b9833c1e2940c0cb626568c0e41">&#9670;&nbsp;</a></span>cx_multimap_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_multimap_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign data to an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">position</td><td>Iterator positions where the data will be stored. </td></tr>
    <tr><td class="paramname">data</td><td>Data to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the previously stored data object.</dd></dl>
<p>The function assigns a data object reference <em>data</em> to the iterator position <em>position</em> of the multimap <em>multimap</em>. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga5e47b9013eaeb6fe294e02d54a1e8cdf">cx_tree_assign()</a>.</p>

</div>
</div>
<a id="gaf08e21b17216433c2f4b9f5c8482abcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf08e21b17216433c2f4b9f5c8482abcb">&#9670;&nbsp;</a></span>cx_multimap_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> cx_multimap_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator to the first pair in a multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>The multimap to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the first pair or <b><a class="el" href="group__cxmultimap.html#ga0664926c1144abc42ff45630398cff3b" title="Get an iterator for the position after the last pair in the multimap.">cx_multimap_end()</a></b> if the multimap is empty.</dd></dl>
<p>The function returns a handle for the first pair in the multimap <em>multimap</em>. The returned iterator cannot be used directly to access the value field of the key/value pair, but only through the appropriate methods. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga6038e74547e7e3ac3280c519914b60a3">cx_tree_begin()</a>.</p>

</div>
</div>
<a id="ga04e85e7fc13400eeb700066810e91e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04e85e7fc13400eeb700066810e91e52">&#9670;&nbsp;</a></span>cx_multimap_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_multimap_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all pairs from a multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>Multimap to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The multimap <em>multimap</em> is cleared, i.e. all pairs are removed from the multimap. Keys and values are destroyed using the key and value destructors set up during multimap creation. After calling this function the multimap is empty. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga377e4c1587471733983f04707f8e619e">cx_tree_clear()</a>.</p>

</div>
</div>
<a id="ga70527409d50026c0cfb85c491a55457d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70527409d50026c0cfb85c491a55457d">&#9670;&nbsp;</a></span>cx_multimap_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_multimap_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of elements matching a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the (key, value) pair(s) to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements with the specified key.</dd></dl>
<p>Counts all elements of the multimap <em>multimap</em> matching the key <em>key</em>. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#gaede41b65d866b8c6cd7589bbebd81b39">cx_tree_count()</a>.</p>

</div>
</div>
<a id="gab91edddb80f050169933450acf0be4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab91edddb80f050169933450acf0be4d2">&#9670;&nbsp;</a></span>cx_multimap_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_multimap_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a multimap and all its elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>The multimap to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The multimap <em>multimap</em> is deallocated. All data values and keys are deallocated using the multimap's key and value destructor. If no key and/or value destructor was set when the <em>multimap</em> was created the keys and the stored data values are left untouched. In this case the key and value deallocation is the responsibility of the user.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxmultimap.html#ga2f7489b10291e6dbf257974f33fe00ad" title="Create a new multimap without any elements.">cx_multimap_new()</a> </dd></dl>

<p class="reference">References <a class="el" href="group__cxtree.html#ga5e30a6c27e8e423d35a0818f264337fe">cx_tree_delete()</a>.</p>

</div>
</div>
<a id="ga51fe454733ae3155f12a2b4f1242eae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51fe454733ae3155f12a2b4f1242eae6">&#9670;&nbsp;</a></span>cx_multimap_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxbool cx_multimap_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a multimap is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <code>TRUE</code> if the multimap is empty, and <code>FALSE</code> otherwise.</dd></dl>
<p>The function checks if the multimap contains any pairs. Calling this function is equivalent to the statement: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> (<a class="code" href="group__cxmultimap.html#gac5829ebe763fb7cfbfa895560e773dd0">cx_multimap_size</a>(multimap) == 0);</div>
</div><!-- fragment --> 
<p class="reference">References <a class="el" href="group__cxtree.html#ga148c828066a5d05e95acd4ec3a525bc8">cx_tree_empty()</a>.</p>

</div>
</div>
<a id="ga0664926c1144abc42ff45630398cff3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0664926c1144abc42ff45630398cff3b">&#9670;&nbsp;</a></span>cx_multimap_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> cx_multimap_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the position after the last pair in the multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>The multimap to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the end of the multimap.</dd></dl>
<p>The function returns an iterator for the position one past the last pair in the multimap <em>multimap</em>. The iteration is done in ascending order according to the keys. The returned iterator cannot be used directly to access the value field of the key/value pair, but only through the appropriate methods. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#gadff64dc3840bb3d663e6b93b89e52d1e">cx_tree_end()</a>.</p>

</div>
</div>
<a id="ga084d0d468f5f6074113f60a5560dce34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga084d0d468f5f6074113f60a5560dce34">&#9670;&nbsp;</a></span>cx_multimap_equal_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_multimap_equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a subsequence matching a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the (key, value) pair(s) to be located. </td></tr>
    <tr><td class="paramname">begin</td><td>First element with key <em>key</em>. </td></tr>
    <tr><td class="paramname">end</td><td>Last element with key <em>key</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function returns the beginning and the end of a subsequence of multimap elements with the key <em>key</em> through through the <em>begin</em> and <em>end</em> arguments. After calling this function <em>begin</em> possibly points to the first element of <em>multimap</em> matching the key <em>key</em> and <em>end</em> possibly points to the last element of the sequence. If key is not present in the multimap <em>begin</em> and <em>end</em> point to the next greater element or, if no such element exists, to <b><a class="el" href="group__cxmultimap.html#ga0664926c1144abc42ff45630398cff3b" title="Get an iterator for the position after the last pair in the multimap.">cx_multimap_end()</a></b>. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga9db4e043848ab20c0111b9a1b081593a">cx_tree_equal_range()</a>.</p>

</div>
</div>
<a id="ga4445b5eb32f7452f56a0045dda373f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4445b5eb32f7452f56a0045dda373f94">&#9670;&nbsp;</a></span>cx_multimap_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_multimap_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase an element from a multimap according to the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the element to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of removed elements.</dd></dl>
<p>This function erases the element with the specified key <em>key</em>, from <em>multimap</em>. Key and value associated with the erased pair are deallocated using the multimap's key and value destructors, provided they have been set. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga14027eafaeb3eaddd513b839672c5e92">cx_tree_erase()</a>.</p>

</div>
</div>
<a id="gace135776d124d74eada48b654abcfe04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace135776d124d74eada48b654abcfe04">&#9670;&nbsp;</a></span>cx_multimap_erase_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_multimap_erase_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase an element from a multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">position</td><td>Iterator position of the element to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function erases an element, specified by the iterator <em>position</em>, from <em>multimap</em>. Key and value associated with the erased pair are deallocated using the multimap's key and value destructors, provided they have been set. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#gaea5f45961ba5ab503c751f54810e8258">cx_tree_erase_position()</a>.</p>

</div>
</div>
<a id="ga567a2280d596e10e11c4806fe8df99f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga567a2280d596e10e11c4806fe8df99f5">&#9670;&nbsp;</a></span>cx_multimap_erase_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_multimap_erase_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a range of elements from a multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">begin</td><td>Iterator pointing to the start of the range to erase. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the range to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function erases all elements in the range [begin, end) from the multimap <em>multimap</em>. Key and value associated with the erased pair(s) are deallocated using the multimap's key and value destructors, provided they have been set. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#gae573050dfd0d7cc829844609ff4a1dc2">cx_tree_erase_range()</a>.</p>

</div>
</div>
<a id="gada385132d40cf231aa6e2c7da61ebd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada385132d40cf231aa6e2c7da61ebd4e">&#9670;&nbsp;</a></span>cx_multimap_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> cx_multimap_find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate an element in the multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the (key, value) pair to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the sought-after element, or <b><a class="el" href="group__cxmultimap.html#ga0664926c1144abc42ff45630398cff3b" title="Get an iterator for the position after the last pair in the multimap.">cx_multimap_end()</a></b> if it was not found.</dd></dl>
<p>The function searches the multimap <em>multimap</em> for the first element with a key matching <em>key</em>. If the search was successful an iterator to the sought-after pair is returned. If the search did not succeed, i.e. <em>key</em> is not present in the multimap, a one past the end iterator is returned. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#gaa36076ac9467d17c8655a9a94a5f7a44">cx_tree_find()</a>.</p>

</div>
</div>
<a id="gaca42be4a86255128ff7fbd9d060422b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca42be4a86255128ff7fbd9d060422b7">&#9670;&nbsp;</a></span>cx_multimap_get_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_multimap_get_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#gab0649c126aa1a71d58823fb7271a16f7">cx_multimap_const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the key from a given iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">position</td><td>Iterator position the data is retrieved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference for the key.</dd></dl>
<p>The function returns a reference to the key associated with the iterator position <em>position</em> in the multimap <em>multimap</em>.</p>
<dl class="section note"><dt>Note</dt><dd>One must not modify the key of <em>position</em> through the returned reference, since this might corrupt the multimap! </dd></dl>

<p class="reference">References <a class="el" href="group__cxtree.html#ga5578369c1a53b8592ff83032c6780cfb">cx_tree_get_key()</a>.</p>

</div>
</div>
<a id="gad6457c9e3b6c522352d9500fd23ff634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6457c9e3b6c522352d9500fd23ff634">&#9670;&nbsp;</a></span>cx_multimap_get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_multimap_get_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#gab0649c126aa1a71d58823fb7271a16f7">cx_multimap_const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data from a given iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">position</td><td>Iterator position the data is retrieved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for the data object.</dd></dl>
<p>The function returns a reference to the data stored at iterator position <em>position</em> in the multimap <em>multimap</em>. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga4b15b6abafbb4f528b5a1f0090b48f86">cx_tree_get_value()</a>.</p>

</div>
</div>
<a id="ga6281914a4c8a9b5582758b4e90c527b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6281914a4c8a9b5582758b4e90c527b4">&#9670;&nbsp;</a></span>cx_multimap_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> cx_multimap_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into a multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">key</td><td>Key used to store the data. </td></tr>
    <tr><td class="paramname">data</td><td>Data to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted pair.</dd></dl>
<p>This function inserts a (key, value) pair into the multimap <em>multimap</em>. The same key may be inserted with different data values. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga07b038bf6018884fa92a5aa316e4cb66">cx_tree_insert_equal()</a>.</p>

</div>
</div>
<a id="gababd9f0e9931b1719e7ccadb41c96c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gababd9f0e9931b1719e7ccadb41c96c26">&#9670;&nbsp;</a></span>cx_multimap_key_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmultimap.html#gaf600553e79dfd1dab23202a0fad67db5">cx_multimap_compare_func</a> cx_multimap_key_comp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a multimap's key comparison function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>The multimap to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for the multimap's key comparison function.</dd></dl>
<p>The function retrieves the function used by the multimap methods for comparing keys. The key comparison function is set during multimap creation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxmultimap.html#ga2f7489b10291e6dbf257974f33fe00ad" title="Create a new multimap without any elements.">cx_multimap_new()</a> </dd></dl>

<p class="reference">References <a class="el" href="group__cxtree.html#ga40f1e3c1aff10f23fa128187f37f30ce">cx_tree_key_comp()</a>.</p>

</div>
</div>
<a id="ga7b8519646c0823f93349524ca64944fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b8519646c0823f93349524ca64944fe">&#9670;&nbsp;</a></span>cx_multimap_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> cx_multimap_lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the beginning of a subsequence matching a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the (key, value) pair(s) to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first position where an element with key <em>key</em> would get inserted, i.e. the first element with a key greater or equal than <em>key</em>.</dd></dl>
<p>The function returns the first element of a subsequence of elements in the multimap that match the given key <em>key</em>. If <em>key</em> is not present in the multimap <em>multimap</em> an iterator pointing to the first element that has a greater key than <em>key</em> or <b><a class="el" href="group__cxmultimap.html#ga0664926c1144abc42ff45630398cff3b" title="Get an iterator for the position after the last pair in the multimap.">cx_multimap_end()</a></b> if no such element exists. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga22e4896d6cd7486dc6d73eb7c3a56fea">cx_tree_lower_bound()</a>.</p>

</div>
</div>
<a id="ga5cb5a94c2aa80f245c6c29f32786830e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cb5a94c2aa80f245c6c29f32786830e">&#9670;&nbsp;</a></span>cx_multimap_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_multimap_max_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum number of pairs possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of pairs that can be stored in the multimap.</dd></dl>
<p>Retrieves the multimap's capacity, i.e. the maximum possible number of pairs a multimap can manage. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga2a04a36bb3a449f14efa25e784169b57">cx_tree_max_size()</a>.</p>

</div>
</div>
<a id="ga2f7489b10291e6dbf257974f33fe00ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f7489b10291e6dbf257974f33fe00ad">&#9670;&nbsp;</a></span>cx_multimap_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a>* cx_multimap_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#gaf600553e79dfd1dab23202a0fad67db5">cx_multimap_compare_func</a>&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_free_func&#160;</td>
          <td class="paramname"><em>key_destroy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_free_func&#160;</td>
          <td class="paramname"><em>value_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new multimap without any elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>Function used to compare keys. </td></tr>
    <tr><td class="paramname">key_destroy</td><td>Destructor for the keys. </td></tr>
    <tr><td class="paramname">value_destroy</td><td>Destructor for the value field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for the newly allocated multimap.</dd></dl>
<p>Memory for a new multimap is allocated and the multimap is initialized to be a valid empty multimap.</p>
<p>The multimap's key comparison function is set to <em>compare</em>. It must return <code>TRUE</code> or <code>FALSE</code> if the comparison of the first argument passed to it with the second argument is found to be true or false respectively.</p>
<p>The destructors for a multimap node's key and value field are set to <em>key_destroy</em> and <em>value_destroy</em>. Whenever a multimap node is destroyed these functions are used to deallocate the memory used by the key and the value. Each of the destructors might be <code>NULL</code>, i.e. keys and values are not deallocated during destroy operations.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxmultimap.html#gaf600553e79dfd1dab23202a0fad67db5" title="The multimap&#39;s key comparison operator function.">cx_multimap_compare_func()</a> </dd></dl>

<p class="reference">References <a class="el" href="group__cxtree.html#ga4d5b89c5e8709645b85996d05478d71e">cx_tree_new()</a>.</p>

</div>
</div>
<a id="ga3e4675ececca240fd93a696273d94fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e4675ececca240fd93a696273d94fd0">&#9670;&nbsp;</a></span>cx_multimap_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> cx_multimap_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#gab0649c126aa1a71d58823fb7271a16f7">cx_multimap_const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the next pair in the multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">position</td><td>Current iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the pair immediately following <em>position</em>.</dd></dl>
<p>The function returns an iterator for the next pair in the multimap <em>multimap</em> with respect to the current iterator position <em>position</em>. Iteration is done in ascending order according to the keys. If the multimap is empty or <em>position</em> points to the end of the multimap the function returns <b><a class="el" href="group__cxmultimap.html#ga0664926c1144abc42ff45630398cff3b" title="Get an iterator for the position after the last pair in the multimap.">cx_multimap_end()</a></b>. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga86c1d604b075a32860f0f66cf678267c">cx_tree_next()</a>.</p>

</div>
</div>
<a id="ga436f55eebc0e96500579067a898361eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga436f55eebc0e96500579067a898361eb">&#9670;&nbsp;</a></span>cx_multimap_previous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> cx_multimap_previous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#gab0649c126aa1a71d58823fb7271a16f7">cx_multimap_const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the previous pair in the multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">position</td><td>Current iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the pair immediately preceding <em>position</em>.</dd></dl>
<p>The function returns an iterator for the previous pair in the multimap <em>multimap</em> with respect to the current iterator position <em>position</em>. Iteration is done in ascending order according to the keys. If the multimap is empty or <em>position</em> points to the beginning of the multimap the function returns <b><a class="el" href="group__cxmultimap.html#ga0664926c1144abc42ff45630398cff3b" title="Get an iterator for the position after the last pair in the multimap.">cx_multimap_end()</a></b>. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga7a7a6770d510c426f281fa9d46e1be5e">cx_tree_previous()</a>.</p>

</div>
</div>
<a id="gac5829ebe763fb7cfbfa895560e773dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5829ebe763fb7cfbfa895560e773dd0">&#9670;&nbsp;</a></span>cx_multimap_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_multimap_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the actual number of pairs in the multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current number of pairs, or 0 if the multimap is empty.</dd></dl>
<p>Retrieves the current number of pairs stored in the multimap. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga3cc3eec66e54e3292d3354ffd2076696">cx_tree_size()</a>.</p>

</div>
</div>
<a id="ga9007e9259934869c4bd71156b1b038dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9007e9259934869c4bd71156b1b038dc">&#9670;&nbsp;</a></span>cx_multimap_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_multimap_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the contents of two multimaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap1</td><td>First multimap. </td></tr>
    <tr><td class="paramname">multimap2</td><td>Second multimap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>All pairs stored in the first multimap <em>multimap1</em> are moved to the second multimap <em>multimap2</em>, while the pairs from <em>multimap2</em> are moved to <em>multimap1</em>. Also the key comparison function, the key and the value destructor are exchanged. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#gaf79317c9c323f0d7b1903b7f23c1012e">cx_tree_swap()</a>.</p>

</div>
</div>
<a id="ga921040ae538ae0f1d3de3ec28f7bf151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga921040ae538ae0f1d3de3ec28f7bf151">&#9670;&nbsp;</a></span>cx_multimap_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cxmultimap.html#ga7f97bd4509ae71db017fa329b5d4a16c">cx_multimap_iterator</a> cx_multimap_upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxmultimap.html#ga06de3578571e65ae6049492f2610553a">cx_multimap</a> *&#160;</td>
          <td class="paramname"><em>multimap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the end of a subsequence matching a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A multimap. </td></tr>
    <tr><td class="paramname">key</td><td>Key of the (key, value) pair(s) to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the last position where an element with key <em>key</em> would get inserted, i.e. the first element with a key greater than <em>key</em>.</dd></dl>
<p>The function returns the last element of a subsequence of elements in the multimap that match the given key <em>key</em>. If <em>key</em> is not present in the multimap <em>multimap</em> an iterator pointing to the first element that has a greater key than <em>key</em> or <b><a class="el" href="group__cxmultimap.html#ga0664926c1144abc42ff45630398cff3b" title="Get an iterator for the position after the last pair in the multimap.">cx_multimap_end()</a></b> if no such element exists. </p>

<p class="reference">References <a class="el" href="group__cxtree.html#ga410dcaddb7845533076d98466f51c053">cx_tree_upper_bound()</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__cxmultimap_html_gac5829ebe763fb7cfbfa895560e773dd0"><div class="ttname"><a href="group__cxmultimap.html#gac5829ebe763fb7cfbfa895560e773dd0">cx_multimap_size</a></div><div class="ttdeci">cxsize cx_multimap_size(const cx_multimap *multimap)</div><div class="ttdoc">Get the actual number of pairs in the multimap.</div><div class="ttdef"><b>Definition:</b> cxmultimap.c:272</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
