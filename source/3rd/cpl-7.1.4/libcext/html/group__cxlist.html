<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Standard Library Extensions: Doubly Linked Lists</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C Standard Library Extensions
   &#160;<span id="projectnumber">1.2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Doubly Linked Lists</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7dd1ce7935f90a6c240040a8b7946e9d"><td class="memItemLeft" align="right" valign="top">cx_list_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga7dd1ce7935f90a6c240040a8b7946e9d">cx_list_begin</a> (const cx_list *list)</td></tr>
<tr class="memdesc:ga7dd1ce7935f90a6c240040a8b7946e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the first list element.  <a href="group__cxlist.html#ga7dd1ce7935f90a6c240040a8b7946e9d">More...</a><br /></td></tr>
<tr class="separator:ga7dd1ce7935f90a6c240040a8b7946e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab280babf40e0e55382c9951d8ced3550"><td class="memItemLeft" align="right" valign="top">cx_list_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#gab280babf40e0e55382c9951d8ced3550">cx_list_end</a> (const cx_list *list)</td></tr>
<tr class="memdesc:gab280babf40e0e55382c9951d8ced3550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the position after the last list element.  <a href="group__cxlist.html#gab280babf40e0e55382c9951d8ced3550">More...</a><br /></td></tr>
<tr class="separator:gab280babf40e0e55382c9951d8ced3550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e53f0d5090624dcb57c088f3dc48b8d"><td class="memItemLeft" align="right" valign="top">cx_list_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga9e53f0d5090624dcb57c088f3dc48b8d">cx_list_next</a> (const cx_list *list, cx_list_const_iterator position)</td></tr>
<tr class="memdesc:ga9e53f0d5090624dcb57c088f3dc48b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the next list element.  <a href="group__cxlist.html#ga9e53f0d5090624dcb57c088f3dc48b8d">More...</a><br /></td></tr>
<tr class="separator:ga9e53f0d5090624dcb57c088f3dc48b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f7028b32c68bcbeb6b7e21881135f8c"><td class="memItemLeft" align="right" valign="top">cx_list_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga5f7028b32c68bcbeb6b7e21881135f8c">cx_list_previous</a> (const cx_list *list, cx_list_const_iterator position)</td></tr>
<tr class="memdesc:ga5f7028b32c68bcbeb6b7e21881135f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the previous list element.  <a href="group__cxlist.html#ga5f7028b32c68bcbeb6b7e21881135f8c">More...</a><br /></td></tr>
<tr class="separator:ga5f7028b32c68bcbeb6b7e21881135f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c07f0c1379bc8bcd1763931b3d2b665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga7c07f0c1379bc8bcd1763931b3d2b665">cx_list_clear</a> (cx_list *list)</td></tr>
<tr class="memdesc:ga7c07f0c1379bc8bcd1763931b3d2b665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from a list.  <a href="group__cxlist.html#ga7c07f0c1379bc8bcd1763931b3d2b665">More...</a><br /></td></tr>
<tr class="separator:ga7c07f0c1379bc8bcd1763931b3d2b665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1c062fa908d78dd45de918899b15208"><td class="memItemLeft" align="right" valign="top">cxbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#gae1c062fa908d78dd45de918899b15208">cx_list_empty</a> (const cx_list *list)</td></tr>
<tr class="memdesc:gae1c062fa908d78dd45de918899b15208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a list is empty.  <a href="group__cxlist.html#gae1c062fa908d78dd45de918899b15208">More...</a><br /></td></tr>
<tr class="separator:gae1c062fa908d78dd45de918899b15208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga488b31c7553afc4ac5b31b276dda80e6"><td class="memItemLeft" align="right" valign="top">cx_list *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga488b31c7553afc4ac5b31b276dda80e6">cx_list_new</a> (void)</td></tr>
<tr class="memdesc:ga488b31c7553afc4ac5b31b276dda80e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new list without any elements.  <a href="group__cxlist.html#ga488b31c7553afc4ac5b31b276dda80e6">More...</a><br /></td></tr>
<tr class="separator:ga488b31c7553afc4ac5b31b276dda80e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3facbcedf3ad4df40d39cb674fbf504"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#gad3facbcedf3ad4df40d39cb674fbf504">cx_list_delete</a> (cx_list *list)</td></tr>
<tr class="memdesc:gad3facbcedf3ad4df40d39cb674fbf504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a list.  <a href="group__cxlist.html#gad3facbcedf3ad4df40d39cb674fbf504">More...</a><br /></td></tr>
<tr class="separator:gad3facbcedf3ad4df40d39cb674fbf504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1709c7653459559ee7f4f8371dec77c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#gaf1709c7653459559ee7f4f8371dec77c">cx_list_destroy</a> (cx_list *list, cx_free_func deallocate)</td></tr>
<tr class="memdesc:gaf1709c7653459559ee7f4f8371dec77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a list and all its elements.  <a href="group__cxlist.html#gaf1709c7653459559ee7f4f8371dec77c">More...</a><br /></td></tr>
<tr class="separator:gaf1709c7653459559ee7f4f8371dec77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3417fcbb2b6a3045dd8f1f6847e2f34"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#gaf3417fcbb2b6a3045dd8f1f6847e2f34">cx_list_size</a> (const cx_list *list)</td></tr>
<tr class="memdesc:gaf3417fcbb2b6a3045dd8f1f6847e2f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual number of list elements.  <a href="group__cxlist.html#gaf3417fcbb2b6a3045dd8f1f6847e2f34">More...</a><br /></td></tr>
<tr class="separator:gaf3417fcbb2b6a3045dd8f1f6847e2f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf97a97b515bdd297e55893b2822d952d"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#gaf97a97b515bdd297e55893b2822d952d">cx_list_max_size</a> (const cx_list *list)</td></tr>
<tr class="memdesc:gaf97a97b515bdd297e55893b2822d952d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of list elements possible.  <a href="group__cxlist.html#gaf97a97b515bdd297e55893b2822d952d">More...</a><br /></td></tr>
<tr class="separator:gaf97a97b515bdd297e55893b2822d952d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f165b45758ae6d15aa69ad58afc759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#gae9f165b45758ae6d15aa69ad58afc759">cx_list_swap</a> (cx_list *list1, cx_list *list2)</td></tr>
<tr class="memdesc:gae9f165b45758ae6d15aa69ad58afc759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the data of two lists.  <a href="group__cxlist.html#gae9f165b45758ae6d15aa69ad58afc759">More...</a><br /></td></tr>
<tr class="separator:gae9f165b45758ae6d15aa69ad58afc759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc80ce2ff3e90fbd222af292375d00cb"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#gafc80ce2ff3e90fbd222af292375d00cb">cx_list_assign</a> (cx_list *list, cx_list_iterator position, cxcptr data)</td></tr>
<tr class="memdesc:gafc80ce2ff3e90fbd222af292375d00cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign data to a list element.  <a href="group__cxlist.html#gafc80ce2ff3e90fbd222af292375d00cb">More...</a><br /></td></tr>
<tr class="separator:gafc80ce2ff3e90fbd222af292375d00cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6b14c8182d5b205e53bd3e13624ad7"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga3e6b14c8182d5b205e53bd3e13624ad7">cx_list_front</a> (const cx_list *list)</td></tr>
<tr class="memdesc:ga3e6b14c8182d5b205e53bd3e13624ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first element of a list.  <a href="group__cxlist.html#ga3e6b14c8182d5b205e53bd3e13624ad7">More...</a><br /></td></tr>
<tr class="separator:ga3e6b14c8182d5b205e53bd3e13624ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0caea68a00f2cdb18d1f32eeb07e41"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#gacf0caea68a00f2cdb18d1f32eeb07e41">cx_list_back</a> (const cx_list *list)</td></tr>
<tr class="memdesc:gacf0caea68a00f2cdb18d1f32eeb07e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last element of a list.  <a href="group__cxlist.html#gacf0caea68a00f2cdb18d1f32eeb07e41">More...</a><br /></td></tr>
<tr class="separator:gacf0caea68a00f2cdb18d1f32eeb07e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79116ce49cc4f0a1ceea844ee2f9d6d7"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga79116ce49cc4f0a1ceea844ee2f9d6d7">cx_list_get</a> (const cx_list *list, cx_list_const_iterator position)</td></tr>
<tr class="memdesc:ga79116ce49cc4f0a1ceea844ee2f9d6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data at a given iterator position.  <a href="group__cxlist.html#ga79116ce49cc4f0a1ceea844ee2f9d6d7">More...</a><br /></td></tr>
<tr class="separator:ga79116ce49cc4f0a1ceea844ee2f9d6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ed5712a71ac0896440a650ad1aa7df9"><td class="memItemLeft" align="right" valign="top">cx_list_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga2ed5712a71ac0896440a650ad1aa7df9">cx_list_insert</a> (cx_list *list, cx_list_iterator position, cxcptr data)</td></tr>
<tr class="memdesc:ga2ed5712a71ac0896440a650ad1aa7df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into a list at a given iterator position.  <a href="group__cxlist.html#ga2ed5712a71ac0896440a650ad1aa7df9">More...</a><br /></td></tr>
<tr class="separator:ga2ed5712a71ac0896440a650ad1aa7df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga737c2b5c766a5ec80fe372deea43a12a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga737c2b5c766a5ec80fe372deea43a12a">cx_list_push_front</a> (cx_list *list, cxcptr data)</td></tr>
<tr class="memdesc:ga737c2b5c766a5ec80fe372deea43a12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data at the beginning of a list.  <a href="group__cxlist.html#ga737c2b5c766a5ec80fe372deea43a12a">More...</a><br /></td></tr>
<tr class="separator:ga737c2b5c766a5ec80fe372deea43a12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd0abcb9ca9ccf2fc863bf9fd60e0e7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#gacd0abcb9ca9ccf2fc863bf9fd60e0e7d">cx_list_push_back</a> (cx_list *list, cxcptr data)</td></tr>
<tr class="memdesc:gacd0abcb9ca9ccf2fc863bf9fd60e0e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append data at the end of a list.  <a href="group__cxlist.html#gacd0abcb9ca9ccf2fc863bf9fd60e0e7d">More...</a><br /></td></tr>
<tr class="separator:gacd0abcb9ca9ccf2fc863bf9fd60e0e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7341a5648349bcc7e5f511d771098b3d"><td class="memItemLeft" align="right" valign="top">cx_list_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga7341a5648349bcc7e5f511d771098b3d">cx_list_erase</a> (cx_list *list, cx_list_iterator position, cx_free_func deallocate)</td></tr>
<tr class="memdesc:ga7341a5648349bcc7e5f511d771098b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a list element.  <a href="group__cxlist.html#ga7341a5648349bcc7e5f511d771098b3d">More...</a><br /></td></tr>
<tr class="separator:ga7341a5648349bcc7e5f511d771098b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9148f04fdd7b544a7d5ff830022cbcec"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga9148f04fdd7b544a7d5ff830022cbcec">cx_list_extract</a> (cx_list *list, cx_list_iterator position)</td></tr>
<tr class="memdesc:ga9148f04fdd7b544a7d5ff830022cbcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a list element.  <a href="group__cxlist.html#ga9148f04fdd7b544a7d5ff830022cbcec">More...</a><br /></td></tr>
<tr class="separator:ga9148f04fdd7b544a7d5ff830022cbcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade04529f7309c819a4fffba4758692fc"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#gade04529f7309c819a4fffba4758692fc">cx_list_pop_front</a> (cx_list *list)</td></tr>
<tr class="memdesc:gade04529f7309c819a4fffba4758692fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first list element.  <a href="group__cxlist.html#gade04529f7309c819a4fffba4758692fc">More...</a><br /></td></tr>
<tr class="separator:gade04529f7309c819a4fffba4758692fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91966ea34eb6c39fba77164c961cb920"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga91966ea34eb6c39fba77164c961cb920">cx_list_pop_back</a> (cx_list *list)</td></tr>
<tr class="memdesc:ga91966ea34eb6c39fba77164c961cb920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element of a list.  <a href="group__cxlist.html#ga91966ea34eb6c39fba77164c961cb920">More...</a><br /></td></tr>
<tr class="separator:ga91966ea34eb6c39fba77164c961cb920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ce5b82d46b8998d8213c589e75aa2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#gaf8ce5b82d46b8998d8213c589e75aa2a">cx_list_remove</a> (cx_list *list, cxcptr data)</td></tr>
<tr class="memdesc:gaf8ce5b82d46b8998d8213c589e75aa2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements with a given value from a list.  <a href="group__cxlist.html#gaf8ce5b82d46b8998d8213c589e75aa2a">More...</a><br /></td></tr>
<tr class="separator:gaf8ce5b82d46b8998d8213c589e75aa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27dd296207560af9669c16123f4034a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga27dd296207560af9669c16123f4034a0">cx_list_unique</a> (cx_list *list, cx_compare_func compare)</td></tr>
<tr class="memdesc:ga27dd296207560af9669c16123f4034a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicates of consecutive elements.  <a href="group__cxlist.html#ga27dd296207560af9669c16123f4034a0">More...</a><br /></td></tr>
<tr class="separator:ga27dd296207560af9669c16123f4034a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga259d8cf49e7224cc9f52f13bec59fa25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga259d8cf49e7224cc9f52f13bec59fa25">cx_list_splice</a> (cx_list *tlist, cx_list_iterator position, cx_list *slist, cx_list_iterator first, cx_list_iterator last)</td></tr>
<tr class="memdesc:ga259d8cf49e7224cc9f52f13bec59fa25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a range of list elements in front of a given position.  <a href="group__cxlist.html#ga259d8cf49e7224cc9f52f13bec59fa25">More...</a><br /></td></tr>
<tr class="separator:ga259d8cf49e7224cc9f52f13bec59fa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb0b0d01b7e73fc2cc29c64c36a7dbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#gaceb0b0d01b7e73fc2cc29c64c36a7dbc">cx_list_merge</a> (cx_list *list1, cx_list *list2, cx_compare_func compare)</td></tr>
<tr class="memdesc:gaceb0b0d01b7e73fc2cc29c64c36a7dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two sorted lists.  <a href="group__cxlist.html#gaceb0b0d01b7e73fc2cc29c64c36a7dbc">More...</a><br /></td></tr>
<tr class="separator:gaceb0b0d01b7e73fc2cc29c64c36a7dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga310b8510df135f4dea6e6a2b489a58f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga310b8510df135f4dea6e6a2b489a58f4">cx_list_sort</a> (cx_list *list, cx_compare_func compare)</td></tr>
<tr class="memdesc:ga310b8510df135f4dea6e6a2b489a58f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all elements of a list using the given comparison function.  <a href="group__cxlist.html#ga310b8510df135f4dea6e6a2b489a58f4">More...</a><br /></td></tr>
<tr class="separator:ga310b8510df135f4dea6e6a2b489a58f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0336d894ad1a48777a236032a1f465c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxlist.html#ga0336d894ad1a48777a236032a1f465c3">cx_list_reverse</a> (cx_list *list)</td></tr>
<tr class="memdesc:ga0336d894ad1a48777a236032a1f465c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the order of all list elements.  <a href="group__cxlist.html#ga0336d894ad1a48777a236032a1f465c3">More...</a><br /></td></tr>
<tr class="separator:ga0336d894ad1a48777a236032a1f465c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The module implements a doubly linked list object which can be traversed in both directions, forward and backward, and methods to create, destroy and manipulate it.</p>
<dl class="section user"><dt>Synopsis:</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cxlist.h&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafc80ce2ff3e90fbd222af292375d00cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc80ce2ff3e90fbd222af292375d00cb">&#9670;&nbsp;</a></span>cx_list_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_list_assign </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_list_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign data to a list element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list. </td></tr>
    <tr><td class="paramname">position</td><td>List position where the data will be stored </td></tr>
    <tr><td class="paramname">data</td><td>Data to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the previously stored data object.</dd></dl>
<p>The function assigns the data object reference <em>data</em> to the iterator position <em>position</em> of the list <em>list</em>. </p>

</div>
</div>
<a id="gacf0caea68a00f2cdb18d1f32eeb07e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf0caea68a00f2cdb18d1f32eeb07e41">&#9670;&nbsp;</a></span>cx_list_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_list_back </td>
          <td>(</td>
          <td class="paramtype">const cx_list *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last element of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object stored in the last list element.</dd></dl>
<p>The function returns a reference to the last data item in the list <em>list</em>.</p>
<p>Calling this function with an empty list is an invalid operation, and the result is undefined. </p>

<p class="reference">References <a class="el" href="group__cxlist.html#gae1c062fa908d78dd45de918899b15208">cx_list_empty()</a>.</p>

</div>
</div>
<a id="ga7dd1ce7935f90a6c240040a8b7946e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dd1ce7935f90a6c240040a8b7946e9d">&#9670;&nbsp;</a></span>cx_list_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_list_iterator cx_list_begin </td>
          <td>(</td>
          <td class="paramtype">const cx_list *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the first list element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the first element in the list or <b><a class="el" href="group__cxlist.html#gab280babf40e0e55382c9951d8ced3550" title="Get an iterator for the position after the last list element.">cx_list_end()</a></b> if the list is empty.</dd></dl>
<p>The function returns a handle to the first element of <em>list</em>. The handle cannot be used directly to access the element data, but only through the appropriate functions. </p>

<p class="reference">Referenced by <a class="el" href="group__cxlist.html#gaf8ce5b82d46b8998d8213c589e75aa2a">cx_list_remove()</a>.</p>

</div>
</div>
<a id="ga7c07f0c1379bc8bcd1763931b3d2b665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c07f0c1379bc8bcd1763931b3d2b665">&#9670;&nbsp;</a></span>cx_list_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_list_clear </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements from a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>List to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The list <em>list</em> is cleared, i.e. all elements are removed from the list. The removed data objects are left untouched, in particular they are not deallocated. It is the responsibility of the caller to ensure that there are still other references to the removed data objects. After calling <b><a class="el" href="group__cxlist.html#ga7c07f0c1379bc8bcd1763931b3d2b665" title="Remove all elements from a list.">cx_list_clear()</a></b> the list <em>list</em> is empty. </p>

</div>
</div>
<a id="gad3facbcedf3ad4df40d39cb674fbf504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3facbcedf3ad4df40d39cb674fbf504">&#9670;&nbsp;</a></span>cx_list_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_list_delete </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function deallocates the list object, but not the data objects currently stored in the list. </p>

</div>
</div>
<a id="gaf1709c7653459559ee7f4f8371dec77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1709c7653459559ee7f4f8371dec77c">&#9670;&nbsp;</a></span>cx_list_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_list_destroy </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_free_func&#160;</td>
          <td class="paramname"><em>deallocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a list and all its elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>List container to destroy. </td></tr>
    <tr><td class="paramname">deallocate</td><td>Data deallocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function deallocates all data objects referenced by the list using the data deallocation function <em>deallocate</em> and finally deallocates the list itself. </p>

</div>
</div>
<a id="gae1c062fa908d78dd45de918899b15208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1c062fa908d78dd45de918899b15208">&#9670;&nbsp;</a></span>cx_list_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxbool cx_list_empty </td>
          <td>(</td>
          <td class="paramtype">const cx_list *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a list is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <code>TRUE</code> if the list is empty, and <code>FALSE</code> otherwise.</dd></dl>
<p>The function tests if the list <em>list</em> contains data. A call to this function is equivalent to the statement:</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> (<a class="code" href="group__cxlist.html#gaf3417fcbb2b6a3045dd8f1f6847e2f34">cx_list_size</a>(list) == 0);</div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="group__cxlist.html#gacf0caea68a00f2cdb18d1f32eeb07e41">cx_list_back()</a>, <a class="el" href="group__cxlist.html#ga3e6b14c8182d5b205e53bd3e13624ad7">cx_list_front()</a>, <a class="el" href="group__cxlist.html#ga91966ea34eb6c39fba77164c961cb920">cx_list_pop_back()</a>, <a class="el" href="group__cxlist.html#gade04529f7309c819a4fffba4758692fc">cx_list_pop_front()</a>, and <a class="el" href="group__cxlist.html#ga27dd296207560af9669c16123f4034a0">cx_list_unique()</a>.</p>

</div>
</div>
<a id="gab280babf40e0e55382c9951d8ced3550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab280babf40e0e55382c9951d8ced3550">&#9670;&nbsp;</a></span>cx_list_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_list_iterator cx_list_end </td>
          <td>(</td>
          <td class="paramtype">const cx_list *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the position after the last list element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the end of the list.</dd></dl>
<p>The function returns an iterator for the position one past the last element of the list <em>list</em>. The handle cannot be used to directly access the element data, but only through the appropriate functions. </p>

</div>
</div>
<a id="ga7341a5648349bcc7e5f511d771098b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7341a5648349bcc7e5f511d771098b3d">&#9670;&nbsp;</a></span>cx_list_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_list_iterator cx_list_erase </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_list_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_free_func&#160;</td>
          <td class="paramname"><em>deallocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a list element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to update. </td></tr>
    <tr><td class="paramname">position</td><td>List iterator position. </td></tr>
    <tr><td class="paramname">deallocate</td><td>Data deallocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator for the list position after <em>position</em>.</dd></dl>
<p>The function removes the data object stored at position <em>position</em> from the list <em>list</em>. The data object itself is deallocated by calling the data deallocator <em>deallocate</em>. </p>

</div>
</div>
<a id="ga9148f04fdd7b544a7d5ff830022cbcec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9148f04fdd7b544a7d5ff830022cbcec">&#9670;&nbsp;</a></span>cx_list_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_list_extract </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_list_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a list element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list. </td></tr>
    <tr><td class="paramname">position</td><td>List iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the previously stored data object.</dd></dl>
<p>The function removes a data object from the list <em>list</em> located at the iterator position <em>position</em> without destroying the data object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxlist.html#ga7341a5648349bcc7e5f511d771098b3d" title="Erase a list element.">cx_list_erase()</a>, <a class="el" href="group__cxlist.html#gaf8ce5b82d46b8998d8213c589e75aa2a" title="Remove all elements with a given value from a list.">cx_list_remove()</a> </dd></dl>

</div>
</div>
<a id="ga3e6b14c8182d5b205e53bd3e13624ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e6b14c8182d5b205e53bd3e13624ad7">&#9670;&nbsp;</a></span>cx_list_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_list_front </td>
          <td>(</td>
          <td class="paramtype">const cx_list *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first element of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object stored in the first list element.</dd></dl>
<p>The function returns a reference to the first data item in the list <em>list</em>.</p>
<p>Calling this function with an empty list is an invalid operation, and the result is undefined. </p>

<p class="reference">References <a class="el" href="group__cxlist.html#gae1c062fa908d78dd45de918899b15208">cx_list_empty()</a>.</p>

</div>
</div>
<a id="ga79116ce49cc4f0a1ceea844ee2f9d6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79116ce49cc4f0a1ceea844ee2f9d6d7">&#9670;&nbsp;</a></span>cx_list_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_list_get </td>
          <td>(</td>
          <td class="paramtype">const cx_list *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_list_const_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data at a given iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list. </td></tr>
    <tr><td class="paramname">position</td><td>List position the data is retrieved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object.</dd></dl>
<p>The function returns a reference to the data item stored in the list <em>list</em> at the iterator position <em>position</em>. </p>

</div>
</div>
<a id="ga2ed5712a71ac0896440a650ad1aa7df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ed5712a71ac0896440a650ad1aa7df9">&#9670;&nbsp;</a></span>cx_list_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_list_iterator cx_list_insert </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_list_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into a list at a given iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to update. </td></tr>
    <tr><td class="paramname">position</td><td>List iterator position. </td></tr>
    <tr><td class="paramname">data</td><td>Data item to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List iterator position of the inserted data item.</dd></dl>
<p>The function inserts the data object reference <em>data</em> into the list <em>list</em> at the list position given by the list iterator <em>position</em>. </p>

</div>
</div>
<a id="gaf97a97b515bdd297e55893b2822d952d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf97a97b515bdd297e55893b2822d952d">&#9670;&nbsp;</a></span>cx_list_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_list_max_size </td>
          <td>(</td>
          <td class="paramtype">const cx_list *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum number of list elements possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of elements that can be stored in the list.</dd></dl>
<p>Retrieves the lists capacity, i.e. the maximum possible number of data items a list can hold. </p>

</div>
</div>
<a id="gaceb0b0d01b7e73fc2cc29c64c36a7dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceb0b0d01b7e73fc2cc29c64c36a7dbc">&#9670;&nbsp;</a></span>cx_list_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_list_merge </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_compare_func&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge two sorted lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list1</td><td>First list to merge. </td></tr>
    <tr><td class="paramname">list2</td><td>Second list to merge. </td></tr>
    <tr><td class="paramname">compare</td><td>Function comparing the list elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function combines the two lists <em>list1</em> and <em>list2</em> by moving all elements from <em>list2</em> into <em>list1</em>, so that all elements are still sorted. The function requires that both input lists are already sorted. The sorting order in which the elements of <em>list2</em> are inserted into <em>list1</em> is determined by the comparison function <em>compare</em>. The comparison function <em>compare</em> must return an integer less than, equal or greater than zero if the first argument passed to it is found, respectively, to be less than, match, or be greater than the second argument.</p>
<p>The list <em>list2</em> is consumed by this process, i.e. after the successful merging of the two lists, list <em>list2</em> will be empty. </p>

</div>
</div>
<a id="ga488b31c7553afc4ac5b31b276dda80e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga488b31c7553afc4ac5b31b276dda80e6">&#9670;&nbsp;</a></span>cx_list_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_list* cx_list_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new list without any elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Handle to the newly allocated list.</dd></dl>
<p>The function allocates memory for the list object and initializes it to a empty list. </p>

<p class="reference">References <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab">cx_malloc()</a>.</p>

</div>
</div>
<a id="ga9e53f0d5090624dcb57c088f3dc48b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e53f0d5090624dcb57c088f3dc48b8d">&#9670;&nbsp;</a></span>cx_list_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_list_iterator cx_list_next </td>
          <td>(</td>
          <td class="paramtype">const cx_list *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_list_const_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the next list element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list. </td></tr>
    <tr><td class="paramname">position</td><td>Current iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the next list element.</dd></dl>
<p>The function returns an iterator for the next element in the list <em>list</em> with respect to the current iterator position <em>position</em>. If the list <em>list</em> is empty or <em>position</em> points to the list end the function returns <b><a class="el" href="group__cxlist.html#gab280babf40e0e55382c9951d8ced3550" title="Get an iterator for the position after the last list element.">cx_list_end()</a></b>. </p>

</div>
</div>
<a id="ga91966ea34eb6c39fba77164c961cb920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91966ea34eb6c39fba77164c961cb920">&#9670;&nbsp;</a></span>cx_list_pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_list_pop_back </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the last element of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to update.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object previously stored as the last list element.</dd></dl>
<p>The function removes the last element from the list <em>list</em> returning a handle to the previously stored data.</p>
<p>It is equivalent to the statement </p><div class="fragment"><div class="line"><a class="code" href="group__cxlist.html#ga9148f04fdd7b544a7d5ff830022cbcec">cx_list_extract</a>(list, <a class="code" href="group__cxlist.html#ga5f7028b32c68bcbeb6b7e21881135f8c">cx_list_previous</a>(list, <a class="code" href="group__cxlist.html#gab280babf40e0e55382c9951d8ced3550">cx_list_end</a>(list)));</div>
</div><!-- fragment --><p>Calling this function with an empty list is an invalid operation, and the result is undefined. </p>

<p class="reference">References <a class="el" href="group__cxlist.html#gae1c062fa908d78dd45de918899b15208">cx_list_empty()</a>.</p>

</div>
</div>
<a id="gade04529f7309c819a4fffba4758692fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade04529f7309c819a4fffba4758692fc">&#9670;&nbsp;</a></span>cx_list_pop_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_list_pop_front </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the first list element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to update.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object previously stored as the first list element.</dd></dl>
<p>The function removes the first element from the list <em>list</em> returning a handle to the previously stored data.</p>
<p>It is equivalent to the statement </p><div class="fragment"><div class="line"><a class="code" href="group__cxlist.html#ga9148f04fdd7b544a7d5ff830022cbcec">cx_list_extract</a>(list, <a class="code" href="group__cxlist.html#ga7dd1ce7935f90a6c240040a8b7946e9d">cx_list_begin</a>(list));</div>
</div><!-- fragment --><p>Calling this function with an empty list is an invalid operation, and the result is undefined. </p>

<p class="reference">References <a class="el" href="group__cxlist.html#gae1c062fa908d78dd45de918899b15208">cx_list_empty()</a>.</p>

</div>
</div>
<a id="ga5f7028b32c68bcbeb6b7e21881135f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f7028b32c68bcbeb6b7e21881135f8c">&#9670;&nbsp;</a></span>cx_list_previous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_list_iterator cx_list_previous </td>
          <td>(</td>
          <td class="paramtype">const cx_list *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_list_const_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the previous list element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list. </td></tr>
    <tr><td class="paramname">position</td><td>Current iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the previous list element.</dd></dl>
<p>The function returns an iterator for the previous element in the list <em>list</em> with respect to the current iterator position <em>position</em>. If the list <em>list</em> is empty or <em>position</em> points to the beginning of the list the function returns <b><a class="el" href="group__cxlist.html#gab280babf40e0e55382c9951d8ced3550" title="Get an iterator for the position after the last list element.">cx_list_end()</a></b>. </p>

</div>
</div>
<a id="gacd0abcb9ca9ccf2fc863bf9fd60e0e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd0abcb9ca9ccf2fc863bf9fd60e0e7d">&#9670;&nbsp;</a></span>cx_list_push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_list_push_back </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append data at the end of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to update. </td></tr>
    <tr><td class="paramname">data</td><td>Data to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The data <em>data</em> is inserted into the list <em>list</em> after the last element, so that it becomes the new list tail.</p>
<p>It is equivalent to the statement </p><div class="fragment"><div class="line"><a class="code" href="group__cxlist.html#ga2ed5712a71ac0896440a650ad1aa7df9">cx_list_insert</a>(list, <a class="code" href="group__cxlist.html#gab280babf40e0e55382c9951d8ced3550">cx_list_end</a>(list), data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga737c2b5c766a5ec80fe372deea43a12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga737c2b5c766a5ec80fe372deea43a12a">&#9670;&nbsp;</a></span>cx_list_push_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_list_push_front </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data at the beginning of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to update. </td></tr>
    <tr><td class="paramname">data</td><td>Data to add to the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The data <em>data</em> is inserted into the list <em>list</em> before the first element of the list, so that it becomes the new list head.</p>
<p>It is equivalent to the statement </p><div class="fragment"><div class="line"><a class="code" href="group__cxlist.html#ga2ed5712a71ac0896440a650ad1aa7df9">cx_list_insert</a>(list, <a class="code" href="group__cxlist.html#ga7dd1ce7935f90a6c240040a8b7946e9d">cx_list_begin</a>(list), data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaf8ce5b82d46b8998d8213c589e75aa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8ce5b82d46b8998d8213c589e75aa2a">&#9670;&nbsp;</a></span>cx_list_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_list_remove </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements with a given value from a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list object. </td></tr>
    <tr><td class="paramname">data</td><td>Data to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The value <em>data</em> is searched in the list <em>list</em>. If the data is found it is removed from the list. The data object itself is not deallocated. </p>

<p class="reference">References <a class="el" href="group__cxlist.html#ga7dd1ce7935f90a6c240040a8b7946e9d">cx_list_begin()</a>.</p>

</div>
</div>
<a id="ga0336d894ad1a48777a236032a1f465c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0336d894ad1a48777a236032a1f465c3">&#9670;&nbsp;</a></span>cx_list_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_list_reverse </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the order of all list elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to reverse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The order of the elements of the list <em>list</em> is reversed. </p>

</div>
</div>
<a id="gaf3417fcbb2b6a3045dd8f1f6847e2f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3417fcbb2b6a3045dd8f1f6847e2f34">&#9670;&nbsp;</a></span>cx_list_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_list_size </td>
          <td>(</td>
          <td class="paramtype">const cx_list *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the actual number of list elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current number of elements the list contains, or 0 if the list is empty.</dd></dl>
<p>Retrieves the number of elements currently stored in the list <em>list</em>. </p>

</div>
</div>
<a id="ga310b8510df135f4dea6e6a2b489a58f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga310b8510df135f4dea6e6a2b489a58f4">&#9670;&nbsp;</a></span>cx_list_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_list_sort </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_compare_func&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort all elements of a list using the given comparison function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to sort. </td></tr>
    <tr><td class="paramname">compare</td><td>Function comparing the list elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The input list <em>list</em> is sorted using the comparison function <em>compare</em> to determine the order of two list elements. The comparison function <em>compare</em> must return an integer less than, equal or greater than zero if the first argument passed to it is found, respectively, to be less than, match, or be greater than the second argument. </p>

</div>
</div>
<a id="ga259d8cf49e7224cc9f52f13bec59fa25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga259d8cf49e7224cc9f52f13bec59fa25">&#9670;&nbsp;</a></span>cx_list_splice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_list_splice </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>tlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_list_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>slist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_list_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_list_iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a range of list elements in front of a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tlist</td><td>Target list. </td></tr>
    <tr><td class="paramname">position</td><td>Target iterator position. </td></tr>
    <tr><td class="paramname">slist</td><td>Source list. </td></tr>
    <tr><td class="paramname">first</td><td>Position of the first element to move. </td></tr>
    <tr><td class="paramname">last</td><td>Position of the last element to move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The range of list elements from the iterator position <em>first</em> to <em>last</em>, but not including <em>last</em>, is moved from the source list <em>slist</em> in front of the position <em>position</em> of the target list <em>tlist</em>. Target and source list may be identical, provided that the target position <em>position</em> does not fall within the range of list elements to move. </p>

</div>
</div>
<a id="gae9f165b45758ae6d15aa69ad58afc759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9f165b45758ae6d15aa69ad58afc759">&#9670;&nbsp;</a></span>cx_list_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_list_swap </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the data of two lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list1</td><td>First list. </td></tr>
    <tr><td class="paramname">list2</td><td>Second list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The contents of the first list <em>list1</em> will be moved to the second list <em>list2</em>, while the contents of <em>list2</em> is moved to <em>list1</em>. </p>

</div>
</div>
<a id="ga27dd296207560af9669c16123f4034a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27dd296207560af9669c16123f4034a0">&#9670;&nbsp;</a></span>cx_list_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_list_unique </td>
          <td>(</td>
          <td class="paramtype">cx_list *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_compare_func&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove duplicates of consecutive elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list. </td></tr>
    <tr><td class="paramname">compare</td><td>Function comparing the list elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function removes duplicates of consecutive list elements, i.e. list elements with the same value, from the list <em>list</em>. The equality of the list elements is checked using the comparison function <em>compare</em>. The comparison function <em>compare</em> must return an integer less than, equal or greater than zero if the first argument passed to it is found, respectively, to be less than, match, or be greater than the second argument. </p>

<p class="reference">References <a class="el" href="group__cxlist.html#gae1c062fa908d78dd45de918899b15208">cx_list_empty()</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__cxlist_html_ga9148f04fdd7b544a7d5ff830022cbcec"><div class="ttname"><a href="group__cxlist.html#ga9148f04fdd7b544a7d5ff830022cbcec">cx_list_extract</a></div><div class="ttdeci">cxptr cx_list_extract(cx_list *list, cx_list_iterator position)</div><div class="ttdoc">Extract a list element.</div><div class="ttdef"><b>Definition:</b> cxlist.c:1123</div></div>
<div class="ttc" id="agroup__cxlist_html_gaf3417fcbb2b6a3045dd8f1f6847e2f34"><div class="ttname"><a href="group__cxlist.html#gaf3417fcbb2b6a3045dd8f1f6847e2f34">cx_list_size</a></div><div class="ttdeci">cxsize cx_list_size(const cx_list *list)</div><div class="ttdoc">Get the actual number of list elements.</div><div class="ttdef"><b>Definition:</b> cxlist.c:787</div></div>
<div class="ttc" id="agroup__cxlist_html_ga2ed5712a71ac0896440a650ad1aa7df9"><div class="ttname"><a href="group__cxlist.html#ga2ed5712a71ac0896440a650ad1aa7df9">cx_list_insert</a></div><div class="ttdeci">cx_list_iterator cx_list_insert(cx_list *list, cx_list_iterator position, cxcptr data)</div><div class="ttdoc">Insert data into a list at a given iterator position.</div><div class="ttdef"><b>Definition:</b> cxlist.c:992</div></div>
<div class="ttc" id="agroup__cxlist_html_gab280babf40e0e55382c9951d8ced3550"><div class="ttname"><a href="group__cxlist.html#gab280babf40e0e55382c9951d8ced3550">cx_list_end</a></div><div class="ttdeci">cx_list_iterator cx_list_end(const cx_list *list)</div><div class="ttdoc">Get an iterator for the position after the last list element.</div><div class="ttdef"><b>Definition:</b> cxlist.c:566</div></div>
<div class="ttc" id="agroup__cxlist_html_ga7dd1ce7935f90a6c240040a8b7946e9d"><div class="ttname"><a href="group__cxlist.html#ga7dd1ce7935f90a6c240040a8b7946e9d">cx_list_begin</a></div><div class="ttdeci">cx_list_iterator cx_list_begin(const cx_list *list)</div><div class="ttdoc">Get an iterator for the first list element.</div><div class="ttdef"><b>Definition:</b> cxlist.c:542</div></div>
<div class="ttc" id="agroup__cxlist_html_ga5f7028b32c68bcbeb6b7e21881135f8c"><div class="ttname"><a href="group__cxlist.html#ga5f7028b32c68bcbeb6b7e21881135f8c">cx_list_previous</a></div><div class="ttdeci">cx_list_iterator cx_list_previous(const cx_list *list, cx_list_const_iterator position)</div><div class="ttdoc">Get an iterator for the previous list element.</div><div class="ttdef"><b>Definition:</b> cxlist.c:620</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
