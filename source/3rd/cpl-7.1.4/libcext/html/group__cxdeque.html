<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Standard Library Extensions: Double-ended queue.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C Standard Library Extensions
   &#160;<span id="projectnumber">1.2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Double-ended queue.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga08414696dbbe9888ae5f8d1e346e94c8"><td class="memItemLeft" align="right" valign="top">cx_deque *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga08414696dbbe9888ae5f8d1e346e94c8">cx_deque_new</a> (void)</td></tr>
<tr class="memdesc:ga08414696dbbe9888ae5f8d1e346e94c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new deque without any elements.  <a href="group__cxdeque.html#ga08414696dbbe9888ae5f8d1e346e94c8">More...</a><br /></td></tr>
<tr class="separator:ga08414696dbbe9888ae5f8d1e346e94c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccc454dff4ccc6be34f54427f7cbd44a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#gaccc454dff4ccc6be34f54427f7cbd44a">cx_deque_delete</a> (cx_deque *deque)</td></tr>
<tr class="memdesc:gaccc454dff4ccc6be34f54427f7cbd44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a deque.  <a href="group__cxdeque.html#gaccc454dff4ccc6be34f54427f7cbd44a">More...</a><br /></td></tr>
<tr class="separator:gaccc454dff4ccc6be34f54427f7cbd44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2fc80632e4d71a70b41ad428b725fd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#gaa2fc80632e4d71a70b41ad428b725fd2">cx_deque_destroy</a> (cx_deque *deque, cx_free_func deallocate)</td></tr>
<tr class="memdesc:gaa2fc80632e4d71a70b41ad428b725fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a deque and all its elements.  <a href="group__cxdeque.html#gaa2fc80632e4d71a70b41ad428b725fd2">More...</a><br /></td></tr>
<tr class="separator:gaa2fc80632e4d71a70b41ad428b725fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a3a8e35681c3553e40b980e30d333f7"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga5a3a8e35681c3553e40b980e30d333f7">cx_deque_size</a> (const cx_deque *deque)</td></tr>
<tr class="memdesc:ga5a3a8e35681c3553e40b980e30d333f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual number of deque elements.  <a href="group__cxdeque.html#ga5a3a8e35681c3553e40b980e30d333f7">More...</a><br /></td></tr>
<tr class="separator:ga5a3a8e35681c3553e40b980e30d333f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76b0d1a0364b2fc9ae0eec8bab7e53b"><td class="memItemLeft" align="right" valign="top">cxbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#gac76b0d1a0364b2fc9ae0eec8bab7e53b">cx_deque_empty</a> (const cx_deque *deque)</td></tr>
<tr class="memdesc:gac76b0d1a0364b2fc9ae0eec8bab7e53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a deque is empty.  <a href="group__cxdeque.html#gac76b0d1a0364b2fc9ae0eec8bab7e53b">More...</a><br /></td></tr>
<tr class="separator:gac76b0d1a0364b2fc9ae0eec8bab7e53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd5474fc6be1684f6b964ae71626b0b"><td class="memItemLeft" align="right" valign="top">cxsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga8fd5474fc6be1684f6b964ae71626b0b">cx_deque_max_size</a> (const cx_deque *deque)</td></tr>
<tr class="memdesc:ga8fd5474fc6be1684f6b964ae71626b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of deque elements possible.  <a href="group__cxdeque.html#ga8fd5474fc6be1684f6b964ae71626b0b">More...</a><br /></td></tr>
<tr class="separator:ga8fd5474fc6be1684f6b964ae71626b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1468b31126cccf70990247bf1629d7b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga1468b31126cccf70990247bf1629d7b5">cx_deque_swap</a> (cx_deque *deque, cx_deque *other)</td></tr>
<tr class="memdesc:ga1468b31126cccf70990247bf1629d7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the data of two deques.  <a href="group__cxdeque.html#ga1468b31126cccf70990247bf1629d7b5">More...</a><br /></td></tr>
<tr class="separator:ga1468b31126cccf70990247bf1629d7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c9278302d630b0cd955f71553f02a92"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga9c9278302d630b0cd955f71553f02a92">cx_deque_assign</a> (cx_deque *deque, cx_deque_iterator position, cxptr data)</td></tr>
<tr class="memdesc:ga9c9278302d630b0cd955f71553f02a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign data to a deque element.  <a href="group__cxdeque.html#ga9c9278302d630b0cd955f71553f02a92">More...</a><br /></td></tr>
<tr class="separator:ga9c9278302d630b0cd955f71553f02a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc972ac99ddbca0a82ca4133fa5ff1ed"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#gadc972ac99ddbca0a82ca4133fa5ff1ed">cx_deque_front</a> (const cx_deque *deque)</td></tr>
<tr class="memdesc:gadc972ac99ddbca0a82ca4133fa5ff1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first element of a deque.  <a href="group__cxdeque.html#gadc972ac99ddbca0a82ca4133fa5ff1ed">More...</a><br /></td></tr>
<tr class="separator:gadc972ac99ddbca0a82ca4133fa5ff1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45a29a6526f9d754289b3fe2a42d4a8e"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga45a29a6526f9d754289b3fe2a42d4a8e">cx_deque_back</a> (const cx_deque *deque)</td></tr>
<tr class="memdesc:ga45a29a6526f9d754289b3fe2a42d4a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last element of a deque.  <a href="group__cxdeque.html#ga45a29a6526f9d754289b3fe2a42d4a8e">More...</a><br /></td></tr>
<tr class="separator:ga45a29a6526f9d754289b3fe2a42d4a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fd04264fec944999d39d62a48a09fc"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga30fd04264fec944999d39d62a48a09fc">cx_deque_get</a> (const cx_deque *deque, cx_deque_const_iterator position)</td></tr>
<tr class="memdesc:ga30fd04264fec944999d39d62a48a09fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an element from a deque.  <a href="group__cxdeque.html#ga30fd04264fec944999d39d62a48a09fc">More...</a><br /></td></tr>
<tr class="separator:ga30fd04264fec944999d39d62a48a09fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad29871e44bf1e90a9ec77a1b8f353182"><td class="memItemLeft" align="right" valign="top">cx_deque_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#gad29871e44bf1e90a9ec77a1b8f353182">cx_deque_begin</a> (const cx_deque *deque)</td></tr>
<tr class="memdesc:gad29871e44bf1e90a9ec77a1b8f353182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the first deque element.  <a href="group__cxdeque.html#gad29871e44bf1e90a9ec77a1b8f353182">More...</a><br /></td></tr>
<tr class="separator:gad29871e44bf1e90a9ec77a1b8f353182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ba79d19e01d953a4a249f57836f9c1"><td class="memItemLeft" align="right" valign="top">cx_deque_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga24ba79d19e01d953a4a249f57836f9c1">cx_deque_end</a> (const cx_deque *deque)</td></tr>
<tr class="memdesc:ga24ba79d19e01d953a4a249f57836f9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the position after the last deque element.  <a href="group__cxdeque.html#ga24ba79d19e01d953a4a249f57836f9c1">More...</a><br /></td></tr>
<tr class="separator:ga24ba79d19e01d953a4a249f57836f9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac615671b4a9ba93eafdc37a8641a40d0"><td class="memItemLeft" align="right" valign="top">cx_deque_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#gac615671b4a9ba93eafdc37a8641a40d0">cx_deque_next</a> (const cx_deque *deque, cx_deque_const_iterator position)</td></tr>
<tr class="memdesc:gac615671b4a9ba93eafdc37a8641a40d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the next deque element.  <a href="group__cxdeque.html#gac615671b4a9ba93eafdc37a8641a40d0">More...</a><br /></td></tr>
<tr class="separator:gac615671b4a9ba93eafdc37a8641a40d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85b439c6ddfa9f73cb89b968286ff996"><td class="memItemLeft" align="right" valign="top">cx_deque_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga85b439c6ddfa9f73cb89b968286ff996">cx_deque_previous</a> (const cx_deque *deque, cx_deque_const_iterator position)</td></tr>
<tr class="memdesc:ga85b439c6ddfa9f73cb89b968286ff996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator for the previous deque element.  <a href="group__cxdeque.html#ga85b439c6ddfa9f73cb89b968286ff996">More...</a><br /></td></tr>
<tr class="separator:ga85b439c6ddfa9f73cb89b968286ff996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf93f33c892ead7b2ced1c7417ec3076a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#gaf93f33c892ead7b2ced1c7417ec3076a">cx_deque_push_front</a> (cx_deque *deque, cxcptr data)</td></tr>
<tr class="memdesc:gaf93f33c892ead7b2ced1c7417ec3076a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data at the beginning of a deque.  <a href="group__cxdeque.html#gaf93f33c892ead7b2ced1c7417ec3076a">More...</a><br /></td></tr>
<tr class="separator:gaf93f33c892ead7b2ced1c7417ec3076a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ee348bdd3fb6a09488bf1867381d2a"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga28ee348bdd3fb6a09488bf1867381d2a">cx_deque_pop_front</a> (cx_deque *deque)</td></tr>
<tr class="memdesc:ga28ee348bdd3fb6a09488bf1867381d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first deque element.  <a href="group__cxdeque.html#ga28ee348bdd3fb6a09488bf1867381d2a">More...</a><br /></td></tr>
<tr class="separator:ga28ee348bdd3fb6a09488bf1867381d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75310934211aac1916975a5c0a5db654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga75310934211aac1916975a5c0a5db654">cx_deque_push_back</a> (cx_deque *deque, cxcptr data)</td></tr>
<tr class="memdesc:ga75310934211aac1916975a5c0a5db654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append data at the end of a deque.  <a href="group__cxdeque.html#ga75310934211aac1916975a5c0a5db654">More...</a><br /></td></tr>
<tr class="separator:ga75310934211aac1916975a5c0a5db654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f3183c0256c05f86ac94ece2cfec9bb"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga4f3183c0256c05f86ac94ece2cfec9bb">cx_deque_pop_back</a> (cx_deque *deque)</td></tr>
<tr class="memdesc:ga4f3183c0256c05f86ac94ece2cfec9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last deque element.  <a href="group__cxdeque.html#ga4f3183c0256c05f86ac94ece2cfec9bb">More...</a><br /></td></tr>
<tr class="separator:ga4f3183c0256c05f86ac94ece2cfec9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce86c4fc6ecbfd0642cf01ba7417716"><td class="memItemLeft" align="right" valign="top">cx_deque_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga2ce86c4fc6ecbfd0642cf01ba7417716">cx_deque_insert</a> (cx_deque *deque, cx_deque_iterator position, cxcptr data)</td></tr>
<tr class="memdesc:ga2ce86c4fc6ecbfd0642cf01ba7417716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into a deque at a given iterator position.  <a href="group__cxdeque.html#ga2ce86c4fc6ecbfd0642cf01ba7417716">More...</a><br /></td></tr>
<tr class="separator:ga2ce86c4fc6ecbfd0642cf01ba7417716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f6812a711e91faa4549f815c1c8a17"><td class="memItemLeft" align="right" valign="top">cx_deque_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga19f6812a711e91faa4549f815c1c8a17">cx_deque_erase</a> (cx_deque *deque, cx_deque_iterator position, cx_free_func deallocate)</td></tr>
<tr class="memdesc:ga19f6812a711e91faa4549f815c1c8a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a deque element.  <a href="group__cxdeque.html#ga19f6812a711e91faa4549f815c1c8a17">More...</a><br /></td></tr>
<tr class="separator:ga19f6812a711e91faa4549f815c1c8a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f346315cb2fba4efe3e5978f65edf5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga6f346315cb2fba4efe3e5978f65edf5e">cx_deque_clear</a> (cx_deque *deque)</td></tr>
<tr class="memdesc:ga6f346315cb2fba4efe3e5978f65edf5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from a deque.  <a href="group__cxdeque.html#ga6f346315cb2fba4efe3e5978f65edf5e">More...</a><br /></td></tr>
<tr class="separator:ga6f346315cb2fba4efe3e5978f65edf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6b6977bbddfd9ce593caadfe6055b55"><td class="memItemLeft" align="right" valign="top">cxptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#gaa6b6977bbddfd9ce593caadfe6055b55">cx_deque_extract</a> (cx_deque *deque, cx_deque_iterator position)</td></tr>
<tr class="memdesc:gaa6b6977bbddfd9ce593caadfe6055b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a deque element.  <a href="group__cxdeque.html#gaa6b6977bbddfd9ce593caadfe6055b55">More...</a><br /></td></tr>
<tr class="separator:gaa6b6977bbddfd9ce593caadfe6055b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf7b04e8acb40fbbd1f3727c7ae5981"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga0cf7b04e8acb40fbbd1f3727c7ae5981">cx_deque_remove</a> (cx_deque *deque, cxcptr data)</td></tr>
<tr class="memdesc:ga0cf7b04e8acb40fbbd1f3727c7ae5981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements with a given value from a deque.  <a href="group__cxdeque.html#ga0cf7b04e8acb40fbbd1f3727c7ae5981">More...</a><br /></td></tr>
<tr class="separator:ga0cf7b04e8acb40fbbd1f3727c7ae5981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ca9af2987ea657a140ad084979abad0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga2ca9af2987ea657a140ad084979abad0">cx_deque_unique</a> (cx_deque *deque, cx_compare_func compare)</td></tr>
<tr class="memdesc:ga2ca9af2987ea657a140ad084979abad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicates of consecutive elements.  <a href="group__cxdeque.html#ga2ca9af2987ea657a140ad084979abad0">More...</a><br /></td></tr>
<tr class="separator:ga2ca9af2987ea657a140ad084979abad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462895062b73db7aebb3d1b4e01960f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga462895062b73db7aebb3d1b4e01960f8">cx_deque_splice</a> (cx_deque *deque, cx_deque_iterator position, cx_deque *other, cx_deque_iterator first, cx_deque_iterator last)</td></tr>
<tr class="memdesc:ga462895062b73db7aebb3d1b4e01960f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a range of elements in front of a given position.  <a href="group__cxdeque.html#ga462895062b73db7aebb3d1b4e01960f8">More...</a><br /></td></tr>
<tr class="separator:ga462895062b73db7aebb3d1b4e01960f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a1a134e57f98d00273d3b7c061c9d47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga7a1a134e57f98d00273d3b7c061c9d47">cx_deque_merge</a> (cx_deque *deque, cx_deque *other, cx_compare_func compare)</td></tr>
<tr class="memdesc:ga7a1a134e57f98d00273d3b7c061c9d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two sorted deques.  <a href="group__cxdeque.html#ga7a1a134e57f98d00273d3b7c061c9d47">More...</a><br /></td></tr>
<tr class="separator:ga7a1a134e57f98d00273d3b7c061c9d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0fd66397386847260275b8b43649d55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#gab0fd66397386847260275b8b43649d55">cx_deque_sort</a> (cx_deque *deque, cx_compare_func compare)</td></tr>
<tr class="memdesc:gab0fd66397386847260275b8b43649d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all elements of a deque using the given comparison function.  <a href="group__cxdeque.html#gab0fd66397386847260275b8b43649d55">More...</a><br /></td></tr>
<tr class="separator:gab0fd66397386847260275b8b43649d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f823cbda988974e970cd228bb8dcea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxdeque.html#ga8f823cbda988974e970cd228bb8dcea2">cx_deque_reverse</a> (cx_deque *deque)</td></tr>
<tr class="memdesc:ga8f823cbda988974e970cd228bb8dcea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the order of all deque elements.  <a href="group__cxdeque.html#ga8f823cbda988974e970cd228bb8dcea2">More...</a><br /></td></tr>
<tr class="separator:ga8f823cbda988974e970cd228bb8dcea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The module implements a double-ended queue. This is a linear list which is optimized for insertions and deletions that are made at the ends of the list.</p>
<dl class="section user"><dt>Synopsis:</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cxdeque.h&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9c9278302d630b0cd955f71553f02a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c9278302d630b0cd955f71553f02a92">&#9670;&nbsp;</a></span>cx_deque_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_deque_assign </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_deque_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign data to a deque element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>A deque. </td></tr>
    <tr><td class="paramname">position</td><td>Position of the deque element where the data will be stored. </td></tr>
    <tr><td class="paramname">data</td><td>Data to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the previously stored data object.</dd></dl>
<p>The function assigns the data object reference <em>data</em> to the iterator position <em>position</em> of the deque <em>deque</em>. </p>

</div>
</div>
<a id="ga45a29a6526f9d754289b3fe2a42d4a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45a29a6526f9d754289b3fe2a42d4a8e">&#9670;&nbsp;</a></span>cx_deque_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_deque_back </td>
          <td>(</td>
          <td class="paramtype">const cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last element of a deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>The deque to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object stored in the last deque element.</dd></dl>
<p>The function returns a reference to the last data item in the deque <em>deque</em>. </p>

</div>
</div>
<a id="gad29871e44bf1e90a9ec77a1b8f353182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad29871e44bf1e90a9ec77a1b8f353182">&#9670;&nbsp;</a></span>cx_deque_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_deque_iterator cx_deque_begin </td>
          <td>(</td>
          <td class="paramtype">const cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the first deque element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>A deque.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the first element in the deque or <b><a class="el" href="group__cxdeque.html#ga24ba79d19e01d953a4a249f57836f9c1" title="Get an iterator for the position after the last deque element.">cx_deque_end()</a></b> if the deque is empty.</dd></dl>
<p>The function returns a handle to the first element of <em>deque</em>. The handle cannot be used directly to access the element data, but only through the appropriate functions. </p>

</div>
</div>
<a id="ga6f346315cb2fba4efe3e5978f65edf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f346315cb2fba4efe3e5978f65edf5e">&#9670;&nbsp;</a></span>cx_deque_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_deque_clear </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements from a deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>Deque to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The deque <em>deque</em> is cleared, i.e. all elements are removed from the deque. The removed data objects are left untouched, in particular they are not deallocated. It is the responsibility of the caller to ensure that there are still other references to the removed data objects. After calling <b><a class="el" href="group__cxdeque.html#ga6f346315cb2fba4efe3e5978f65edf5e" title="Remove all elements from a deque.">cx_deque_clear()</a></b> the deque <em>deque</em> is empty. </p>

</div>
</div>
<a id="gaccc454dff4ccc6be34f54427f7cbd44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccc454dff4ccc6be34f54427f7cbd44a">&#9670;&nbsp;</a></span>cx_deque_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_deque_delete </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>The deque to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function deallocates the deque object, but not the data objects currently stored in the deque. </p>

</div>
</div>
<a id="gaa2fc80632e4d71a70b41ad428b725fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2fc80632e4d71a70b41ad428b725fd2">&#9670;&nbsp;</a></span>cx_deque_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_deque_destroy </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_free_func&#160;</td>
          <td class="paramname"><em>deallocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a deque and all its elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>Deque container to destroy. </td></tr>
    <tr><td class="paramname">deallocate</td><td>Data deallocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function deallocates all data objects referenced by <em>deque</em> using the data deallocation function <em>deallocate</em> and finally deallocates the deque object itself. </p>

</div>
</div>
<a id="gac76b0d1a0364b2fc9ae0eec8bab7e53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac76b0d1a0364b2fc9ae0eec8bab7e53b">&#9670;&nbsp;</a></span>cx_deque_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxbool cx_deque_empty </td>
          <td>(</td>
          <td class="paramtype">const cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a deque is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>A deque.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <code>TRUE</code> if the deque is empty, and <code>FALSE</code> otherwise.</dd></dl>
<p>The function tests if the deque <em>deque</em> contains data. </p>

</div>
</div>
<a id="ga24ba79d19e01d953a4a249f57836f9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24ba79d19e01d953a4a249f57836f9c1">&#9670;&nbsp;</a></span>cx_deque_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_deque_iterator cx_deque_end </td>
          <td>(</td>
          <td class="paramtype">const cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the position after the last deque element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>A deque.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the end of the deque.</dd></dl>
<p>The function returns an iterator for the position one past the last element of the deque <em>deque</em>. The handle cannot be used to directly access the element data, but only through the appropriate functions. </p>

</div>
</div>
<a id="ga19f6812a711e91faa4549f815c1c8a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19f6812a711e91faa4549f815c1c8a17">&#9670;&nbsp;</a></span>cx_deque_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_deque_iterator cx_deque_erase </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_deque_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_free_func&#160;</td>
          <td class="paramname"><em>deallocate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a deque element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>The deque to update. </td></tr>
    <tr><td class="paramname">position</td><td>Deque iterator position. </td></tr>
    <tr><td class="paramname">deallocate</td><td>Data deallocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator for the deque position after <em>position</em>.</dd></dl>
<p>The function removes the data object stored at position <em>position</em> from the deque <em>deque</em>. The data object itself is deallocated by calling the data deallocator <em>deallocate</em>. </p>

</div>
</div>
<a id="gaa6b6977bbddfd9ce593caadfe6055b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6b6977bbddfd9ce593caadfe6055b55">&#9670;&nbsp;</a></span>cx_deque_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_deque_extract </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_deque_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a deque element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>A deque. </td></tr>
    <tr><td class="paramname">position</td><td>Deque iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the previously stored data object.</dd></dl>
<p>The function removes a data object from the deque <em>deque</em> located at the iterator position <em>position</em> without destroying the data object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cxdeque.html#ga19f6812a711e91faa4549f815c1c8a17" title="Erase a deque element.">cx_deque_erase()</a>, <a class="el" href="group__cxdeque.html#ga0cf7b04e8acb40fbbd1f3727c7ae5981" title="Remove all elements with a given value from a deque.">cx_deque_remove()</a> </dd></dl>

</div>
</div>
<a id="gadc972ac99ddbca0a82ca4133fa5ff1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc972ac99ddbca0a82ca4133fa5ff1ed">&#9670;&nbsp;</a></span>cx_deque_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_deque_front </td>
          <td>(</td>
          <td class="paramtype">const cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first element of a deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>The deque to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object stored in the first deque element.</dd></dl>
<p>The function returns a reference to the first data item in the deque <em>deque</em>. </p>

</div>
</div>
<a id="ga30fd04264fec944999d39d62a48a09fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30fd04264fec944999d39d62a48a09fc">&#9670;&nbsp;</a></span>cx_deque_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_deque_get </td>
          <td>(</td>
          <td class="paramtype">const cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_deque_const_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an element from a deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>The deque to query. </td></tr>
    <tr><td class="paramname">position</td><td>The position of the element to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the data object.</dd></dl>
<p>The function returns a reference to the data item stored in the deque <em>deque</em> at the iterator position <em>position</em>. </p>

</div>
</div>
<a id="ga2ce86c4fc6ecbfd0642cf01ba7417716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ce86c4fc6ecbfd0642cf01ba7417716">&#9670;&nbsp;</a></span>cx_deque_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_deque_iterator cx_deque_insert </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_deque_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into a deque at a given iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>The deque to update. </td></tr>
    <tr><td class="paramname">position</td><td>List iterator position. </td></tr>
    <tr><td class="paramname">data</td><td>Data item to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Deque iterator position of the inserted data item.</dd></dl>
<p>The function inserts the data object reference <em>data</em> into the deque <em>deque</em> at the position given by the deque iterator <em>position</em>. </p>

</div>
</div>
<a id="ga8fd5474fc6be1684f6b964ae71626b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fd5474fc6be1684f6b964ae71626b0b">&#9670;&nbsp;</a></span>cx_deque_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_deque_max_size </td>
          <td>(</td>
          <td class="paramtype">const cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum number of deque elements possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>A deque.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of elements that can be stored in the deque.</dd></dl>
<p>Retrieves the deques capacity, i.e. the maximum possible number of data items a deque can hold. </p>

</div>
</div>
<a id="ga7a1a134e57f98d00273d3b7c061c9d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a1a134e57f98d00273d3b7c061c9d47">&#9670;&nbsp;</a></span>cx_deque_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_deque_merge </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_compare_func&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge two sorted deques. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>Target deque of the merge operation. </td></tr>
    <tr><td class="paramname">other</td><td>The deque to merge into the target. </td></tr>
    <tr><td class="paramname">compare</td><td>Function comparing the deque elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function combines the two deques <em>deque</em> and <em>other</em> by moving all elements from <em>other</em> into <em>deque</em>, so that all elements are still sorted. The function requires that both input deques are already sorted. The sorting order in which the elements of <em>other</em> are inserted into <em>deque</em> is determined by the comparison function <em>compare</em>. The comparison function <em>compare</em> must return an integer less than, equal or greater than zero if the first argument passed to it is found, respectively, to be less than, match, or be greater than the second argument.</p>
<p>The deque <em>other</em> is consumed by this process, i.e. after the successful merging of the two deques, deque <em>other</em> will be empty. </p>

</div>
</div>
<a id="ga08414696dbbe9888ae5f8d1e346e94c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08414696dbbe9888ae5f8d1e346e94c8">&#9670;&nbsp;</a></span>cx_deque_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_deque* cx_deque_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new deque without any elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Handle to the newly allocated deque.</dd></dl>
<p>The function allocates memory for a deque object and initializes it to an empty deque. </p>

<p class="reference">References <a class="el" href="group__cxmemory.html#ga7ae1df2916d7231b1959cebcf4acafab">cx_malloc()</a>.</p>

</div>
</div>
<a id="gac615671b4a9ba93eafdc37a8641a40d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac615671b4a9ba93eafdc37a8641a40d0">&#9670;&nbsp;</a></span>cx_deque_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_deque_iterator cx_deque_next </td>
          <td>(</td>
          <td class="paramtype">const cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_deque_const_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the next deque element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>A deque. </td></tr>
    <tr><td class="paramname">position</td><td>Current iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the next deque element.</dd></dl>
<p>The function returns an iterator for the next element in the deque <em>deque</em> with respect to the current iterator position <em>position</em>. If the deque <em>deque</em> is empty or <em>position</em> points to the deque end the function returns <b><a class="el" href="group__cxdeque.html#ga24ba79d19e01d953a4a249f57836f9c1" title="Get an iterator for the position after the last deque element.">cx_deque_end()</a></b>. </p>

</div>
</div>
<a id="ga4f3183c0256c05f86ac94ece2cfec9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f3183c0256c05f86ac94ece2cfec9bb">&#9670;&nbsp;</a></span>cx_deque_pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_deque_pop_back </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the last deque element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>The deque to update.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object previously stored as the last deque element.</dd></dl>
<p>The function removes the last element from the deque <em>deque</em> returning a handle to the previously stored data.</p>
<p>It is equivalent to the statement </p><div class="fragment"><div class="line"><a class="code" href="group__cxdeque.html#gaa6b6977bbddfd9ce593caadfe6055b55">cx_deque_extract</a>(deque, <a class="code" href="group__cxdeque.html#ga85b439c6ddfa9f73cb89b968286ff996">cx_deque_previous</a>(deque, <a class="code" href="group__cxdeque.html#ga24ba79d19e01d953a4a249f57836f9c1">cx_deque_end</a>(deque)));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga28ee348bdd3fb6a09488bf1867381d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28ee348bdd3fb6a09488bf1867381d2a">&#9670;&nbsp;</a></span>cx_deque_pop_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxptr cx_deque_pop_front </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the first deque element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>The deque to update.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the data object previously stored as the first deque element.</dd></dl>
<p>The function removes the first element from the deque <em>deque</em> returning a handle to the previously stored data.</p>
<p>It is equivalent to the statement </p><div class="fragment"><div class="line"><a class="code" href="group__cxdeque.html#gaa6b6977bbddfd9ce593caadfe6055b55">cx_deque_extract</a>(deque, <a class="code" href="group__cxdeque.html#gad29871e44bf1e90a9ec77a1b8f353182">cx_deque_begin</a>(deque));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga85b439c6ddfa9f73cb89b968286ff996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85b439c6ddfa9f73cb89b968286ff996">&#9670;&nbsp;</a></span>cx_deque_previous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cx_deque_iterator cx_deque_previous </td>
          <td>(</td>
          <td class="paramtype">const cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_deque_const_iterator&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator for the previous deque element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>A deque. </td></tr>
    <tr><td class="paramname">position</td><td>Current iterator position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator for the previous deque element.</dd></dl>
<p>The function returns an iterator for the previous element in the deque <em>deque</em> with respect to the current iterator position <em>position</em>. If the deque <em>deque</em> is empty or <em>position</em> points to the beginning of the deque the function returns <b><a class="el" href="group__cxdeque.html#ga24ba79d19e01d953a4a249f57836f9c1" title="Get an iterator for the position after the last deque element.">cx_deque_end()</a></b>. </p>

</div>
</div>
<a id="ga75310934211aac1916975a5c0a5db654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75310934211aac1916975a5c0a5db654">&#9670;&nbsp;</a></span>cx_deque_push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_deque_push_back </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append data at the end of a deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>The deque to update. </td></tr>
    <tr><td class="paramname">data</td><td>Data to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The data <em>data</em> is inserted into the deque <em>deque</em> after the last element, so that it becomes the new deque tail.</p>
<p>It is equivalent to the statement </p><div class="fragment"><div class="line"><a class="code" href="group__cxdeque.html#ga2ce86c4fc6ecbfd0642cf01ba7417716">cx_deque_insert</a>(deque, <a class="code" href="group__cxdeque.html#ga24ba79d19e01d953a4a249f57836f9c1">cx_deque_end</a>(deque), data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaf93f33c892ead7b2ced1c7417ec3076a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf93f33c892ead7b2ced1c7417ec3076a">&#9670;&nbsp;</a></span>cx_deque_push_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_deque_push_front </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data at the beginning of a deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>The deque to update. </td></tr>
    <tr><td class="paramname">data</td><td>Data to add to the deque.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The data <em>data</em> is inserted into the deque <em>deque</em> before the first element of the deque, so that it becomes the new deque head.</p>
<p>It is equivalent to the statement </p><div class="fragment"><div class="line"><a class="code" href="group__cxdeque.html#ga2ce86c4fc6ecbfd0642cf01ba7417716">cx_deque_insert</a>(deque, <a class="code" href="group__cxdeque.html#gad29871e44bf1e90a9ec77a1b8f353182">cx_deque_begin</a>(deque), data);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga0cf7b04e8acb40fbbd1f3727c7ae5981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cf7b04e8acb40fbbd1f3727c7ae5981">&#9670;&nbsp;</a></span>cx_deque_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_deque_remove </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxcptr&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements with a given value from a deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>A deque. </td></tr>
    <tr><td class="paramname">data</td><td>Data to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The value <em>data</em> is searched in the deque <em>deque</em>. If the data is found it is removed from the deque. The data object itself is not deallocated. </p>

</div>
</div>
<a id="ga8f823cbda988974e970cd228bb8dcea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f823cbda988974e970cd228bb8dcea2">&#9670;&nbsp;</a></span>cx_deque_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_deque_reverse </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the order of all deque elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>The deque to reverse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The order of the elements of the deque <em>deque</em> is reversed. </p>

</div>
</div>
<a id="ga5a3a8e35681c3553e40b980e30d333f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a3a8e35681c3553e40b980e30d333f7">&#9670;&nbsp;</a></span>cx_deque_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsize cx_deque_size </td>
          <td>(</td>
          <td class="paramtype">const cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the actual number of deque elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>A deque.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current number of elements the deque contains, or 0 if the deque is empty.</dd></dl>
<p>Retrieves the number of elements currently stored in the deque <em>deque</em>. </p>

</div>
</div>
<a id="gab0fd66397386847260275b8b43649d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0fd66397386847260275b8b43649d55">&#9670;&nbsp;</a></span>cx_deque_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_deque_sort </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_compare_func&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort all elements of a deque using the given comparison function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>The deque to sort. </td></tr>
    <tr><td class="paramname">compare</td><td>Function comparing the deque elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The input deque <em>deque</em> is sorted using the comparison function <em>compare</em> to determine the order of two deque elements. The comparison function <em>compare</em> must return an integer less than, equal or greater than zero if the first argument passed to it is found, respectively, to be less than, equal, or be greater than the second argument. This function uses the stdlib function qsort(). </p>

</div>
</div>
<a id="ga462895062b73db7aebb3d1b4e01960f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga462895062b73db7aebb3d1b4e01960f8">&#9670;&nbsp;</a></span>cx_deque_splice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_deque_splice </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_deque_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_deque_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_deque_iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a range of elements in front of a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>Target deque. </td></tr>
    <tr><td class="paramname">position</td><td>Target iterator position. </td></tr>
    <tr><td class="paramname">other</td><td>Source deque. </td></tr>
    <tr><td class="paramname">first</td><td>Position of the first element to move. </td></tr>
    <tr><td class="paramname">last</td><td>Position of the last element to move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The range of deque elements from the iterator position <em>first</em> to <em>last</em>, but not including <em>last</em>, is moved from the source deque <em>other</em> in front of the position <em>position</em> of the target deque <em>deque</em>. Target and source deque may be identical, provided that the target position <em>position</em> does not fall within the range of deque elements to move. </p>

</div>
</div>
<a id="ga1468b31126cccf70990247bf1629d7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1468b31126cccf70990247bf1629d7b5">&#9670;&nbsp;</a></span>cx_deque_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_deque_swap </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the data of two deques. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>The first deque. </td></tr>
    <tr><td class="paramname">other</td><td>The second deque.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The contents of the deque <em>other</em> will be moved to the deque <em>deque</em>, while the contents of <em>deque</em> is moved to <em>other</em>. </p>

</div>
</div>
<a id="ga2ca9af2987ea657a140ad084979abad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ca9af2987ea657a140ad084979abad0">&#9670;&nbsp;</a></span>cx_deque_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cx_deque_unique </td>
          <td>(</td>
          <td class="paramtype">cx_deque *&#160;</td>
          <td class="paramname"><em>deque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cx_compare_func&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove duplicates of consecutive elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deque</td><td>A deque. </td></tr>
    <tr><td class="paramname">compare</td><td>Function comparing the deque elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The function removes duplicates of consecutive deque elements, i.e. deque elements with the same value, from the deque <em>deque</em>. The equality of the deque elements is checked using the comparison function <em>compare</em>. The comparison function <em>compare</em> must return an integer less than, equal or greater than zero if the first argument passed to it is found, respectively, to be less than, match, or be greater than the second argument. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__cxdeque_html_gaa6b6977bbddfd9ce593caadfe6055b55"><div class="ttname"><a href="group__cxdeque.html#gaa6b6977bbddfd9ce593caadfe6055b55">cx_deque_extract</a></div><div class="ttdeci">cxptr cx_deque_extract(cx_deque *deque, cx_deque_iterator position)</div><div class="ttdoc">Extract a deque element.</div><div class="ttdef"><b>Definition:</b> cxdeque.c:1447</div></div>
<div class="ttc" id="agroup__cxdeque_html_ga2ce86c4fc6ecbfd0642cf01ba7417716"><div class="ttname"><a href="group__cxdeque.html#ga2ce86c4fc6ecbfd0642cf01ba7417716">cx_deque_insert</a></div><div class="ttdeci">cx_deque_iterator cx_deque_insert(cx_deque *deque, cx_deque_iterator position, cxcptr data)</div><div class="ttdoc">Insert data into a deque at a given iterator position.</div><div class="ttdef"><b>Definition:</b> cxdeque.c:1339</div></div>
<div class="ttc" id="agroup__cxdeque_html_ga24ba79d19e01d953a4a249f57836f9c1"><div class="ttname"><a href="group__cxdeque.html#ga24ba79d19e01d953a4a249f57836f9c1">cx_deque_end</a></div><div class="ttdeci">cx_deque_iterator cx_deque_end(const cx_deque *deque)</div><div class="ttdoc">Get an iterator for the position after the last deque element.</div><div class="ttdef"><b>Definition:</b> cxdeque.c:1125</div></div>
<div class="ttc" id="agroup__cxdeque_html_gad29871e44bf1e90a9ec77a1b8f353182"><div class="ttname"><a href="group__cxdeque.html#gad29871e44bf1e90a9ec77a1b8f353182">cx_deque_begin</a></div><div class="ttdeci">cx_deque_iterator cx_deque_begin(const cx_deque *deque)</div><div class="ttdoc">Get an iterator for the first deque element.</div><div class="ttdef"><b>Definition:</b> cxdeque.c:1102</div></div>
<div class="ttc" id="agroup__cxdeque_html_ga85b439c6ddfa9f73cb89b968286ff996"><div class="ttname"><a href="group__cxdeque.html#ga85b439c6ddfa9f73cb89b968286ff996">cx_deque_previous</a></div><div class="ttdeci">cx_deque_iterator cx_deque_previous(const cx_deque *deque, cx_deque_const_iterator position)</div><div class="ttdoc">Get an iterator for the previous deque element.</div><div class="ttdef"><b>Definition:</b> cxdeque.c:1175</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
