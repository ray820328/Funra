<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Common Pipeline Library Reference Manual: Arrays</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cpl.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Common Pipeline Library Reference Manual
   &#160;<span id="projectnumber">7.1.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Arrays</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga312e71fd365e79ef0359a2fa5fecdb77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga312e71fd365e79ef0359a2fa5fecdb77">cpl_array_abs</a> (cpl_array *array)</td></tr>
<tr class="memdesc:ga312e71fd365e79ef0359a2fa5fecdb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of array elements.  <a href="group__cpl__array.html#ga312e71fd365e79ef0359a2fa5fecdb77">More...</a><br /></td></tr>
<tr class="separator:ga312e71fd365e79ef0359a2fa5fecdb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e0451f31e2bb26c18981b50c32611b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga34e0451f31e2bb26c18981b50c32611b">cpl_array_add</a> (cpl_array *to_array, const cpl_array *from_array)</td></tr>
<tr class="memdesc:ga34e0451f31e2bb26c18981b50c32611b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the values of two numeric or complex arrays.  <a href="group__cpl__array.html#ga34e0451f31e2bb26c18981b50c32611b">More...</a><br /></td></tr>
<tr class="separator:ga34e0451f31e2bb26c18981b50c32611b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0deeffe5d0f37e99dbc27ed308ce0a63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga0deeffe5d0f37e99dbc27ed308ce0a63">cpl_array_add_scalar</a> (cpl_array *array, double value)</td></tr>
<tr class="memdesc:ga0deeffe5d0f37e99dbc27ed308ce0a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constant value to a numerical array.  <a href="group__cpl__array.html#ga0deeffe5d0f37e99dbc27ed308ce0a63">More...</a><br /></td></tr>
<tr class="separator:ga0deeffe5d0f37e99dbc27ed308ce0a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga696c3b50d6f7dd191f3c3b9adcc1ef5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga696c3b50d6f7dd191f3c3b9adcc1ef5c">cpl_array_add_scalar_complex</a> (cpl_array *array, double complex value)</td></tr>
<tr class="memdesc:ga696c3b50d6f7dd191f3c3b9adcc1ef5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constant complex value to a complex array.  <a href="group__cpl__array.html#ga696c3b50d6f7dd191f3c3b9adcc1ef5c">More...</a><br /></td></tr>
<tr class="separator:ga696c3b50d6f7dd191f3c3b9adcc1ef5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c93e4c252bc6392e0e3a2046f8425d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga0c93e4c252bc6392e0e3a2046f8425d6">cpl_array_arg</a> (cpl_array *array)</td></tr>
<tr class="memdesc:ga0c93e4c252bc6392e0e3a2046f8425d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the phase angle value of array elements.  <a href="group__cpl__array.html#ga0c93e4c252bc6392e0e3a2046f8425d6">More...</a><br /></td></tr>
<tr class="separator:ga0c93e4c252bc6392e0e3a2046f8425d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d816900ddde0f301f4c6d764ddd065d"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga5d816900ddde0f301f4c6d764ddd065d">cpl_array_cast</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a> type)</td></tr>
<tr class="memdesc:ga5d816900ddde0f301f4c6d764ddd065d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a numeric array to a new numeric type array.  <a href="group__cpl__array.html#ga5d816900ddde0f301f4c6d764ddd065d">More...</a><br /></td></tr>
<tr class="separator:ga5d816900ddde0f301f4c6d764ddd065d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5770d80a31e02a2e60f357f546da16d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga5770d80a31e02a2e60f357f546da16d8">cpl_array_copy_data</a> (cpl_array *array, const double *data)</td></tr>
<tr class="memdesc:ga5770d80a31e02a2e60f357f546da16d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy buffer of numerical data to a numerical array.  <a href="group__cpl__array.html#ga5770d80a31e02a2e60f357f546da16d8">More...</a><br /></td></tr>
<tr class="separator:ga5770d80a31e02a2e60f357f546da16d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146a768f68b5b2f3eb3af2bbe692f531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga146a768f68b5b2f3eb3af2bbe692f531">cpl_array_copy_data_complex</a> (cpl_array *array, const double complex *data)</td></tr>
<tr class="memdesc:ga146a768f68b5b2f3eb3af2bbe692f531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy buffer of complex data to a complex array.  <a href="group__cpl__array.html#ga146a768f68b5b2f3eb3af2bbe692f531">More...</a><br /></td></tr>
<tr class="separator:ga146a768f68b5b2f3eb3af2bbe692f531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1df1328e2f8bc974db5ca33ec80d59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga0d1df1328e2f8bc974db5ca33ec80d59">cpl_array_copy_data_cplsize</a> (cpl_array *array, const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *data)</td></tr>
<tr class="memdesc:ga0d1df1328e2f8bc974db5ca33ec80d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a <em>cpl_size</em> array.  <a href="group__cpl__array.html#ga0d1df1328e2f8bc974db5ca33ec80d59">More...</a><br /></td></tr>
<tr class="separator:ga0d1df1328e2f8bc974db5ca33ec80d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade072cdd9ee37177e02bb06da1739fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gade072cdd9ee37177e02bb06da1739fb6">cpl_array_copy_data_double</a> (cpl_array *array, const double *data)</td></tr>
<tr class="memdesc:gade072cdd9ee37177e02bb06da1739fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a <em>double</em> array.  <a href="group__cpl__array.html#gade072cdd9ee37177e02bb06da1739fb6">More...</a><br /></td></tr>
<tr class="separator:gade072cdd9ee37177e02bb06da1739fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab410794547ed8e4cf6b4c2a27f8861f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gab410794547ed8e4cf6b4c2a27f8861f0">cpl_array_copy_data_double_complex</a> (cpl_array *array, const double complex *data)</td></tr>
<tr class="memdesc:gab410794547ed8e4cf6b4c2a27f8861f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a <em>double</em> complex array.  <a href="group__cpl__array.html#gab410794547ed8e4cf6b4c2a27f8861f0">More...</a><br /></td></tr>
<tr class="separator:gab410794547ed8e4cf6b4c2a27f8861f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29d6454f60e77c9fd179ed7782718d8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga29d6454f60e77c9fd179ed7782718d8e">cpl_array_copy_data_float</a> (cpl_array *array, const float *data)</td></tr>
<tr class="memdesc:ga29d6454f60e77c9fd179ed7782718d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a <em>float</em> array.  <a href="group__cpl__array.html#ga29d6454f60e77c9fd179ed7782718d8e">More...</a><br /></td></tr>
<tr class="separator:ga29d6454f60e77c9fd179ed7782718d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1745e7d37e7ee5a410a27598db499633"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga1745e7d37e7ee5a410a27598db499633">cpl_array_copy_data_float_complex</a> (cpl_array *array, const float complex *data)</td></tr>
<tr class="memdesc:ga1745e7d37e7ee5a410a27598db499633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a <em>float</em> complex array.  <a href="group__cpl__array.html#ga1745e7d37e7ee5a410a27598db499633">More...</a><br /></td></tr>
<tr class="separator:ga1745e7d37e7ee5a410a27598db499633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d82d5bb1920256901f41114a5c5ab84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga4d82d5bb1920256901f41114a5c5ab84">cpl_array_copy_data_int</a> (cpl_array *array, const int *data)</td></tr>
<tr class="memdesc:ga4d82d5bb1920256901f41114a5c5ab84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to an <em>integer</em> array.  <a href="group__cpl__array.html#ga4d82d5bb1920256901f41114a5c5ab84">More...</a><br /></td></tr>
<tr class="separator:ga4d82d5bb1920256901f41114a5c5ab84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac39674e8f2d41417f26fdb5919f9e5f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gac39674e8f2d41417f26fdb5919f9e5f7">cpl_array_copy_data_long</a> (cpl_array *array, const long *data)</td></tr>
<tr class="memdesc:gac39674e8f2d41417f26fdb5919f9e5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a <em>long</em> <em>integer</em> array.  <a href="group__cpl__array.html#gac39674e8f2d41417f26fdb5919f9e5f7">More...</a><br /></td></tr>
<tr class="separator:gac39674e8f2d41417f26fdb5919f9e5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48dc79ded7abe6d6f6360869f218fb8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga48dc79ded7abe6d6f6360869f218fb8d">cpl_array_copy_data_long_long</a> (cpl_array *array, const long long *data)</td></tr>
<tr class="memdesc:ga48dc79ded7abe6d6f6360869f218fb8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a <em>long</em> <em>long</em> <em>integer</em> array.  <a href="group__cpl__array.html#ga48dc79ded7abe6d6f6360869f218fb8d">More...</a><br /></td></tr>
<tr class="separator:ga48dc79ded7abe6d6f6360869f218fb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a3af94c72bbc926aabb761892228917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga5a3af94c72bbc926aabb761892228917">cpl_array_copy_data_string</a> (cpl_array *array, const char **data)</td></tr>
<tr class="memdesc:ga5a3af94c72bbc926aabb761892228917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a <em>string</em> array.  <a href="group__cpl__array.html#ga5a3af94c72bbc926aabb761892228917">More...</a><br /></td></tr>
<tr class="separator:ga5a3af94c72bbc926aabb761892228917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2bb9c166dc45fe02114a2a6fdaaaf90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaa2bb9c166dc45fe02114a2a6fdaaaf90">cpl_array_count_invalid</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:gaa2bb9c166dc45fe02114a2a6fdaaaf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count number of invalid elements in an array.  <a href="group__cpl__array.html#gaa2bb9c166dc45fe02114a2a6fdaaaf90">More...</a><br /></td></tr>
<tr class="separator:gaa2bb9c166dc45fe02114a2a6fdaaaf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bffcca34e6751f1e5c2db6497be2074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074">cpl_array_delete</a> (cpl_array *array)</td></tr>
<tr class="memdesc:ga6bffcca34e6751f1e5c2db6497be2074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an array.  <a href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074">More...</a><br /></td></tr>
<tr class="separator:ga6bffcca34e6751f1e5c2db6497be2074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b0f15f7afb9e90c914bb8707f85df2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga5b0f15f7afb9e90c914bb8707f85df2a">cpl_array_divide</a> (cpl_array *to_array, const cpl_array *from_array)</td></tr>
<tr class="memdesc:ga5b0f15f7afb9e90c914bb8707f85df2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide the values of two numeric or complex arrays.  <a href="group__cpl__array.html#ga5b0f15f7afb9e90c914bb8707f85df2a">More...</a><br /></td></tr>
<tr class="separator:ga5b0f15f7afb9e90c914bb8707f85df2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga761a432ecee2da8cf9a01c0713cc2f04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga761a432ecee2da8cf9a01c0713cc2f04">cpl_array_divide_scalar</a> (cpl_array *array, double value)</td></tr>
<tr class="memdesc:ga761a432ecee2da8cf9a01c0713cc2f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a numerical array by a constant value.  <a href="group__cpl__array.html#ga761a432ecee2da8cf9a01c0713cc2f04">More...</a><br /></td></tr>
<tr class="separator:ga761a432ecee2da8cf9a01c0713cc2f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76554f2fb30f9e618fe06035d8ccada"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gab76554f2fb30f9e618fe06035d8ccada">cpl_array_divide_scalar_complex</a> (cpl_array *array, double complex value)</td></tr>
<tr class="memdesc:gab76554f2fb30f9e618fe06035d8ccada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a complex array by a constant complex value.  <a href="group__cpl__array.html#gab76554f2fb30f9e618fe06035d8ccada">More...</a><br /></td></tr>
<tr class="separator:gab76554f2fb30f9e618fe06035d8ccada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae34bfd342242da76465bac08133d6552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gae34bfd342242da76465bac08133d6552">cpl_array_dump</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, FILE *stream)</td></tr>
<tr class="memdesc:gae34bfd342242da76465bac08133d6552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an array.  <a href="group__cpl__array.html#gae34bfd342242da76465bac08133d6552">More...</a><br /></td></tr>
<tr class="separator:gae34bfd342242da76465bac08133d6552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d257aed16ec2f5a3035fb6c8697a1af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga9d257aed16ec2f5a3035fb6c8697a1af">cpl_array_dump_structure</a> (const cpl_array *array, FILE *stream)</td></tr>
<tr class="memdesc:ga9d257aed16ec2f5a3035fb6c8697a1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describe the structure and the contents of an array.  <a href="group__cpl__array.html#ga9d257aed16ec2f5a3035fb6c8697a1af">More...</a><br /></td></tr>
<tr class="separator:ga9d257aed16ec2f5a3035fb6c8697a1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d2bbefc13a4c4d7d03a3413202653db"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga4d2bbefc13a4c4d7d03a3413202653db">cpl_array_duplicate</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:ga4d2bbefc13a4c4d7d03a3413202653db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of an array.  <a href="group__cpl__array.html#ga4d2bbefc13a4c4d7d03a3413202653db">More...</a><br /></td></tr>
<tr class="separator:ga4d2bbefc13a4c4d7d03a3413202653db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d697433645b215307214fd890985089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga0d697433645b215307214fd890985089">cpl_array_erase_window</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count)</td></tr>
<tr class="memdesc:ga0d697433645b215307214fd890985089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a segment of an array.  <a href="group__cpl__array.html#ga0d697433645b215307214fd890985089">More...</a><br /></td></tr>
<tr class="separator:ga0d697433645b215307214fd890985089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a11ecf7268ea476a68fcbe9cfdfd285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga3a11ecf7268ea476a68fcbe9cfdfd285">cpl_array_exponential</a> (cpl_array *array, double base)</td></tr>
<tr class="memdesc:ga3a11ecf7268ea476a68fcbe9cfdfd285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of array elements.  <a href="group__cpl__array.html#ga3a11ecf7268ea476a68fcbe9cfdfd285">More...</a><br /></td></tr>
<tr class="separator:ga3a11ecf7268ea476a68fcbe9cfdfd285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e311edd18e037607ecb2122c42d418"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gad4e311edd18e037607ecb2122c42d418">cpl_array_extract</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count)</td></tr>
<tr class="memdesc:gad4e311edd18e037607ecb2122c42d418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array from a section of another array.  <a href="group__cpl__array.html#gad4e311edd18e037607ecb2122c42d418">More...</a><br /></td></tr>
<tr class="separator:gad4e311edd18e037607ecb2122c42d418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefa4c3310c7c836abc695d797705aa62"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaefa4c3310c7c836abc695d797705aa62">cpl_array_extract_imag</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:gaefa4c3310c7c836abc695d797705aa62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the imaginary value of array elements.  <a href="group__cpl__array.html#gaefa4c3310c7c836abc695d797705aa62">More...</a><br /></td></tr>
<tr class="separator:gaefa4c3310c7c836abc695d797705aa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8fd08e7b11baf6a3f44ec0c1060c1ef"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaa8fd08e7b11baf6a3f44ec0c1060c1ef">cpl_array_extract_real</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:gaa8fd08e7b11baf6a3f44ec0c1060c1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the real value of array elements.  <a href="group__cpl__array.html#gaa8fd08e7b11baf6a3f44ec0c1060c1ef">More...</a><br /></td></tr>
<tr class="separator:gaa8fd08e7b11baf6a3f44ec0c1060c1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f215dd3642ac04434dc11f19cfb531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga83f215dd3642ac04434dc11f19cfb531">cpl_array_fill_window</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, double value)</td></tr>
<tr class="memdesc:ga83f215dd3642ac04434dc11f19cfb531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the same value within a numerical array segment.  <a href="group__cpl__array.html#ga83f215dd3642ac04434dc11f19cfb531">More...</a><br /></td></tr>
<tr class="separator:ga83f215dd3642ac04434dc11f19cfb531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc1db4e5939deba92ee2d0445bb0473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga6fc1db4e5939deba92ee2d0445bb0473">cpl_array_fill_window_complex</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, double complex value)</td></tr>
<tr class="memdesc:ga6fc1db4e5939deba92ee2d0445bb0473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the same value within a complex array segment.  <a href="group__cpl__array.html#ga6fc1db4e5939deba92ee2d0445bb0473">More...</a><br /></td></tr>
<tr class="separator:ga6fc1db4e5939deba92ee2d0445bb0473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90e880102fcc9c695272b1b197673ebc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga90e880102fcc9c695272b1b197673ebc">cpl_array_fill_window_cplsize</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> value)</td></tr>
<tr class="memdesc:ga90e880102fcc9c695272b1b197673ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the same value within a <em>cpl_size</em> array segment.  <a href="group__cpl__array.html#ga90e880102fcc9c695272b1b197673ebc">More...</a><br /></td></tr>
<tr class="separator:ga90e880102fcc9c695272b1b197673ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae48974a884287d4b83b6f1f6df39cf32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gae48974a884287d4b83b6f1f6df39cf32">cpl_array_fill_window_double</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, double value)</td></tr>
<tr class="memdesc:gae48974a884287d4b83b6f1f6df39cf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the same value within a <em>double</em> array segment.  <a href="group__cpl__array.html#gae48974a884287d4b83b6f1f6df39cf32">More...</a><br /></td></tr>
<tr class="separator:gae48974a884287d4b83b6f1f6df39cf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad57ef869111e8368c937ae0d7fe21b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gad57ef869111e8368c937ae0d7fe21b06">cpl_array_fill_window_double_complex</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, double complex value)</td></tr>
<tr class="memdesc:gad57ef869111e8368c937ae0d7fe21b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the same value within a <em>double</em> complex array segment.  <a href="group__cpl__array.html#gad57ef869111e8368c937ae0d7fe21b06">More...</a><br /></td></tr>
<tr class="separator:gad57ef869111e8368c937ae0d7fe21b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga741fa062e3a68cb111fb4bcf4d1e59b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga741fa062e3a68cb111fb4bcf4d1e59b0">cpl_array_fill_window_float</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, float value)</td></tr>
<tr class="memdesc:ga741fa062e3a68cb111fb4bcf4d1e59b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the same value within a <em>float</em> array segment.  <a href="group__cpl__array.html#ga741fa062e3a68cb111fb4bcf4d1e59b0">More...</a><br /></td></tr>
<tr class="separator:ga741fa062e3a68cb111fb4bcf4d1e59b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58a801bf2758aba8f39017ac04188476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga58a801bf2758aba8f39017ac04188476">cpl_array_fill_window_float_complex</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, float complex value)</td></tr>
<tr class="memdesc:ga58a801bf2758aba8f39017ac04188476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the same value within a <em>float</em> complex array segment.  <a href="group__cpl__array.html#ga58a801bf2758aba8f39017ac04188476">More...</a><br /></td></tr>
<tr class="separator:ga58a801bf2758aba8f39017ac04188476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf83bacd759bb90887ca113ea42047c92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaf83bacd759bb90887ca113ea42047c92">cpl_array_fill_window_int</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, int value)</td></tr>
<tr class="memdesc:gaf83bacd759bb90887ca113ea42047c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the same value within an <em>integer</em> array segment.  <a href="group__cpl__array.html#gaf83bacd759bb90887ca113ea42047c92">More...</a><br /></td></tr>
<tr class="separator:gaf83bacd759bb90887ca113ea42047c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2">cpl_array_fill_window_invalid</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count)</td></tr>
<tr class="memdesc:ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an array segment to NULL.  <a href="group__cpl__array.html#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2">More...</a><br /></td></tr>
<tr class="separator:ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e69bb6fb617ecb546ac6d864427a17d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga9e69bb6fb617ecb546ac6d864427a17d">cpl_array_fill_window_long</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, long value)</td></tr>
<tr class="memdesc:ga9e69bb6fb617ecb546ac6d864427a17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the same value within a <em>long</em> <em>integer</em> array segment.  <a href="group__cpl__array.html#ga9e69bb6fb617ecb546ac6d864427a17d">More...</a><br /></td></tr>
<tr class="separator:ga9e69bb6fb617ecb546ac6d864427a17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59d3b674bdca51f6a754dde2ecc4186c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga59d3b674bdca51f6a754dde2ecc4186c">cpl_array_fill_window_long_long</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, long long value)</td></tr>
<tr class="memdesc:ga59d3b674bdca51f6a754dde2ecc4186c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the same value within a <em>long</em> <em>long</em> <em>integer</em> array segment.  <a href="group__cpl__array.html#ga59d3b674bdca51f6a754dde2ecc4186c">More...</a><br /></td></tr>
<tr class="separator:ga59d3b674bdca51f6a754dde2ecc4186c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c61b18495db4c5c990076f791ff33d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga8c61b18495db4c5c990076f791ff33d9">cpl_array_fill_window_string</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, const char *value)</td></tr>
<tr class="memdesc:ga8c61b18495db4c5c990076f791ff33d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a string to a string array segment.  <a href="group__cpl__array.html#ga8c61b18495db4c5c990076f791ff33d9">More...</a><br /></td></tr>
<tr class="separator:ga8c61b18495db4c5c990076f791ff33d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1639e3c0603907ad879cccb607ea93ce"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga1639e3c0603907ad879cccb607ea93ce">cpl_array_get</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, int *null)</td></tr>
<tr class="memdesc:ga1639e3c0603907ad879cccb607ea93ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a numerical array.  <a href="group__cpl__array.html#ga1639e3c0603907ad879cccb607ea93ce">More...</a><br /></td></tr>
<tr class="separator:ga1639e3c0603907ad879cccb607ea93ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf94fdf2504a9cd7f31b3b151c8736ef8"><td class="memItemLeft" align="right" valign="top">double complex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaf94fdf2504a9cd7f31b3b151c8736ef8">cpl_array_get_complex</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, int *null)</td></tr>
<tr class="memdesc:gaf94fdf2504a9cd7f31b3b151c8736ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a complex array.  <a href="group__cpl__array.html#gaf94fdf2504a9cd7f31b3b151c8736ef8">More...</a><br /></td></tr>
<tr class="separator:gaf94fdf2504a9cd7f31b3b151c8736ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fff5accef0f29506e7591f80770d2aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga3fff5accef0f29506e7591f80770d2aa">cpl_array_get_cplsize</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, int *null)</td></tr>
<tr class="memdesc:ga3fff5accef0f29506e7591f80770d2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>cpl_size</em> array.  <a href="group__cpl__array.html#ga3fff5accef0f29506e7591f80770d2aa">More...</a><br /></td></tr>
<tr class="separator:ga3fff5accef0f29506e7591f80770d2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb15b7dfc7335f0e3aa0758349ab01cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gabb15b7dfc7335f0e3aa0758349ab01cb">cpl_array_get_data_cplsize</a> (cpl_array *array)</td></tr>
<tr class="memdesc:gabb15b7dfc7335f0e3aa0758349ab01cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <code>cpl_size</code> array data.  <a href="group__cpl__array.html#gabb15b7dfc7335f0e3aa0758349ab01cb">More...</a><br /></td></tr>
<tr class="separator:gabb15b7dfc7335f0e3aa0758349ab01cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d80e50313eed1d8cbfd4d260cb1b0e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gac3d80e50313eed1d8cbfd4d260cb1b0e">cpl_array_get_data_cplsize_const</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:gac3d80e50313eed1d8cbfd4d260cb1b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <code>cpl_size</code> array data.  <a href="group__cpl__array.html#gac3d80e50313eed1d8cbfd4d260cb1b0e">More...</a><br /></td></tr>
<tr class="separator:gac3d80e50313eed1d8cbfd4d260cb1b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65acfed522e9a1aa7e3a0ecae0ed0a81"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga65acfed522e9a1aa7e3a0ecae0ed0a81">cpl_array_get_data_double</a> (cpl_array *array)</td></tr>
<tr class="memdesc:ga65acfed522e9a1aa7e3a0ecae0ed0a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <code>double</code> array data.  <a href="group__cpl__array.html#ga65acfed522e9a1aa7e3a0ecae0ed0a81">More...</a><br /></td></tr>
<tr class="separator:ga65acfed522e9a1aa7e3a0ecae0ed0a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b284ffb554d127566b89f369a7a631a"><td class="memItemLeft" align="right" valign="top">double complex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga3b284ffb554d127566b89f369a7a631a">cpl_array_get_data_double_complex</a> (cpl_array *array)</td></tr>
<tr class="memdesc:ga3b284ffb554d127566b89f369a7a631a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <code>double</code> complex array data.  <a href="group__cpl__array.html#ga3b284ffb554d127566b89f369a7a631a">More...</a><br /></td></tr>
<tr class="separator:ga3b284ffb554d127566b89f369a7a631a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfd3e8cba2adf3fd507dd8ddb1d9e75b"><td class="memItemLeft" align="right" valign="top">const double complex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gabfd3e8cba2adf3fd507dd8ddb1d9e75b">cpl_array_get_data_double_complex_const</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:gabfd3e8cba2adf3fd507dd8ddb1d9e75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <em>double</em> complex array data.  <a href="group__cpl__array.html#gabfd3e8cba2adf3fd507dd8ddb1d9e75b">More...</a><br /></td></tr>
<tr class="separator:gabfd3e8cba2adf3fd507dd8ddb1d9e75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf4a7775ab84a3d776f0be5e19ac5576"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gacf4a7775ab84a3d776f0be5e19ac5576">cpl_array_get_data_double_const</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:gacf4a7775ab84a3d776f0be5e19ac5576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <em>double</em> array data.  <a href="group__cpl__array.html#gacf4a7775ab84a3d776f0be5e19ac5576">More...</a><br /></td></tr>
<tr class="separator:gacf4a7775ab84a3d776f0be5e19ac5576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga955975ecb1d288fdfa98b1a0050f6c1c"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga955975ecb1d288fdfa98b1a0050f6c1c">cpl_array_get_data_float</a> (cpl_array *array)</td></tr>
<tr class="memdesc:ga955975ecb1d288fdfa98b1a0050f6c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <code>float</code> array data.  <a href="group__cpl__array.html#ga955975ecb1d288fdfa98b1a0050f6c1c">More...</a><br /></td></tr>
<tr class="separator:ga955975ecb1d288fdfa98b1a0050f6c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62687ba5ce9e57fde647669cfbe56e87"><td class="memItemLeft" align="right" valign="top">float complex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga62687ba5ce9e57fde647669cfbe56e87">cpl_array_get_data_float_complex</a> (cpl_array *array)</td></tr>
<tr class="memdesc:ga62687ba5ce9e57fde647669cfbe56e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <code>float</code> complex array data.  <a href="group__cpl__array.html#ga62687ba5ce9e57fde647669cfbe56e87">More...</a><br /></td></tr>
<tr class="separator:ga62687ba5ce9e57fde647669cfbe56e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee80bcffeabaa8b6f3171c14d30d726"><td class="memItemLeft" align="right" valign="top">const float complex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga0ee80bcffeabaa8b6f3171c14d30d726">cpl_array_get_data_float_complex_const</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:ga0ee80bcffeabaa8b6f3171c14d30d726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <em>float</em> complex array data.  <a href="group__cpl__array.html#ga0ee80bcffeabaa8b6f3171c14d30d726">More...</a><br /></td></tr>
<tr class="separator:ga0ee80bcffeabaa8b6f3171c14d30d726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a54d6a52aedffe4638c195e04155ef3"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga6a54d6a52aedffe4638c195e04155ef3">cpl_array_get_data_float_const</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:ga6a54d6a52aedffe4638c195e04155ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <em>float</em> array data.  <a href="group__cpl__array.html#ga6a54d6a52aedffe4638c195e04155ef3">More...</a><br /></td></tr>
<tr class="separator:ga6a54d6a52aedffe4638c195e04155ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6ce495b8cff38332106ba3242a2c9f"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f">cpl_array_get_data_int</a> (cpl_array *array)</td></tr>
<tr class="memdesc:gaef6ce495b8cff38332106ba3242a2c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <code>integer</code> array data.  <a href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f">More...</a><br /></td></tr>
<tr class="separator:gaef6ce495b8cff38332106ba3242a2c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e4d679ec9d58e631b69eae7990ab19f"><td class="memItemLeft" align="right" valign="top">const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga7e4d679ec9d58e631b69eae7990ab19f">cpl_array_get_data_int_const</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:ga7e4d679ec9d58e631b69eae7990ab19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <code>integer</code> array data.  <a href="group__cpl__array.html#ga7e4d679ec9d58e631b69eae7990ab19f">More...</a><br /></td></tr>
<tr class="separator:ga7e4d679ec9d58e631b69eae7990ab19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb021d47e58301128a299e4284bffe0"><td class="memItemLeft" align="right" valign="top">long *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga2bb021d47e58301128a299e4284bffe0">cpl_array_get_data_long</a> (cpl_array *array)</td></tr>
<tr class="memdesc:ga2bb021d47e58301128a299e4284bffe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <code>long</code> <code>integer</code> array data.  <a href="group__cpl__array.html#ga2bb021d47e58301128a299e4284bffe0">More...</a><br /></td></tr>
<tr class="separator:ga2bb021d47e58301128a299e4284bffe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad88006e3171971a573cebd0b8822a787"><td class="memItemLeft" align="right" valign="top">const long *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gad88006e3171971a573cebd0b8822a787">cpl_array_get_data_long_const</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:gad88006e3171971a573cebd0b8822a787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <code>long</code> <code>integer</code> array data.  <a href="group__cpl__array.html#gad88006e3171971a573cebd0b8822a787">More...</a><br /></td></tr>
<tr class="separator:gad88006e3171971a573cebd0b8822a787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa14294d46199c6223755c56d6f7ccec3"><td class="memItemLeft" align="right" valign="top">long long *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaa14294d46199c6223755c56d6f7ccec3">cpl_array_get_data_long_long</a> (cpl_array *array)</td></tr>
<tr class="memdesc:gaa14294d46199c6223755c56d6f7ccec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <code>long</code> <code>long</code> <code>integer</code> array data.  <a href="group__cpl__array.html#gaa14294d46199c6223755c56d6f7ccec3">More...</a><br /></td></tr>
<tr class="separator:gaa14294d46199c6223755c56d6f7ccec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga362760c465f162cc54759dc51319977d"><td class="memItemLeft" align="right" valign="top">const long long *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga362760c465f162cc54759dc51319977d">cpl_array_get_data_long_long_const</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:ga362760c465f162cc54759dc51319977d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <code>long</code> <code>long</code> <code>integer</code> array data.  <a href="group__cpl__array.html#ga362760c465f162cc54759dc51319977d">More...</a><br /></td></tr>
<tr class="separator:ga362760c465f162cc54759dc51319977d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e5d705ae246e2580532d51589f979c5"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga0e5d705ae246e2580532d51589f979c5">cpl_array_get_data_string</a> (cpl_array *array)</td></tr>
<tr class="memdesc:ga0e5d705ae246e2580532d51589f979c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <em>string</em> array data.  <a href="group__cpl__array.html#ga0e5d705ae246e2580532d51589f979c5">More...</a><br /></td></tr>
<tr class="separator:ga0e5d705ae246e2580532d51589f979c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93bda9cdd017058efd32b1b16c74c130"><td class="memItemLeft" align="right" valign="top">const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga93bda9cdd017058efd32b1b16c74c130">cpl_array_get_data_string_const</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:ga93bda9cdd017058efd32b1b16c74c130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <em>string</em> array data.  <a href="group__cpl__array.html#ga93bda9cdd017058efd32b1b16c74c130">More...</a><br /></td></tr>
<tr class="separator:ga93bda9cdd017058efd32b1b16c74c130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8546b4a102b65be32f7a2dd729b2c6a8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga8546b4a102b65be32f7a2dd729b2c6a8">cpl_array_get_double</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, int *null)</td></tr>
<tr class="memdesc:ga8546b4a102b65be32f7a2dd729b2c6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>double</em> array.  <a href="group__cpl__array.html#ga8546b4a102b65be32f7a2dd729b2c6a8">More...</a><br /></td></tr>
<tr class="separator:ga8546b4a102b65be32f7a2dd729b2c6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59f2936cbd4d132bc5a4079a0a7452f4"><td class="memItemLeft" align="right" valign="top">double complex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga59f2936cbd4d132bc5a4079a0a7452f4">cpl_array_get_double_complex</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, int *null)</td></tr>
<tr class="memdesc:ga59f2936cbd4d132bc5a4079a0a7452f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>double</em> complex array.  <a href="group__cpl__array.html#ga59f2936cbd4d132bc5a4079a0a7452f4">More...</a><br /></td></tr>
<tr class="separator:ga59f2936cbd4d132bc5a4079a0a7452f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b787dac49b4e871facf32cbfc9ef2ac"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga1b787dac49b4e871facf32cbfc9ef2ac">cpl_array_get_float</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, int *null)</td></tr>
<tr class="memdesc:ga1b787dac49b4e871facf32cbfc9ef2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>float</em> array.  <a href="group__cpl__array.html#ga1b787dac49b4e871facf32cbfc9ef2ac">More...</a><br /></td></tr>
<tr class="separator:ga1b787dac49b4e871facf32cbfc9ef2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0f08d3d7a28457b75c286db7e175661"><td class="memItemLeft" align="right" valign="top">float complex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gae0f08d3d7a28457b75c286db7e175661">cpl_array_get_float_complex</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, int *null)</td></tr>
<tr class="memdesc:gae0f08d3d7a28457b75c286db7e175661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>float</em> complex array.  <a href="group__cpl__array.html#gae0f08d3d7a28457b75c286db7e175661">More...</a><br /></td></tr>
<tr class="separator:gae0f08d3d7a28457b75c286db7e175661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga884166ba564f1408eb22c3343c250e5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga884166ba564f1408eb22c3343c250e5e">cpl_array_get_int</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, int *null)</td></tr>
<tr class="memdesc:ga884166ba564f1408eb22c3343c250e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from an <em>integer</em> array.  <a href="group__cpl__array.html#ga884166ba564f1408eb22c3343c250e5e">More...</a><br /></td></tr>
<tr class="separator:ga884166ba564f1408eb22c3343c250e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa46641dd92c5310500201a0c3cd324da"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaa46641dd92c5310500201a0c3cd324da">cpl_array_get_long</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, int *null)</td></tr>
<tr class="memdesc:gaa46641dd92c5310500201a0c3cd324da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>long</em> <em>integer</em> array.  <a href="group__cpl__array.html#gaa46641dd92c5310500201a0c3cd324da">More...</a><br /></td></tr>
<tr class="separator:gaa46641dd92c5310500201a0c3cd324da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa885f4eb60de528e5729187a3bd46931"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaa885f4eb60de528e5729187a3bd46931">cpl_array_get_long_long</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, int *null)</td></tr>
<tr class="memdesc:gaa885f4eb60de528e5729187a3bd46931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>long</em> <em>long</em> <em>integer</em> array.  <a href="group__cpl__array.html#gaa885f4eb60de528e5729187a3bd46931">More...</a><br /></td></tr>
<tr class="separator:gaa885f4eb60de528e5729187a3bd46931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade748bc7779401890bdafd535a0bd725"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gade748bc7779401890bdafd535a0bd725">cpl_array_get_max</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:gade748bc7779401890bdafd535a0bd725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum value in a numerical array.  <a href="group__cpl__array.html#gade748bc7779401890bdafd535a0bd725">More...</a><br /></td></tr>
<tr class="separator:gade748bc7779401890bdafd535a0bd725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ee812e57ebbd25fbdc6fbb048f70ddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga2ee812e57ebbd25fbdc6fbb048f70ddc">cpl_array_get_maxpos</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *indx)</td></tr>
<tr class="memdesc:ga2ee812e57ebbd25fbdc6fbb048f70ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get position of maximum in a numerical array.  <a href="group__cpl__array.html#ga2ee812e57ebbd25fbdc6fbb048f70ddc">More...</a><br /></td></tr>
<tr class="separator:ga2ee812e57ebbd25fbdc6fbb048f70ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab31e5e9631e4b9d1d945c3e6c55ab626"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gab31e5e9631e4b9d1d945c3e6c55ab626">cpl_array_get_mean</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:gab31e5e9631e4b9d1d945c3e6c55ab626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean value of a numeric array.  <a href="group__cpl__array.html#gab31e5e9631e4b9d1d945c3e6c55ab626">More...</a><br /></td></tr>
<tr class="separator:gab31e5e9631e4b9d1d945c3e6c55ab626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa21e07016678174db5c804486293cdc0"><td class="memItemLeft" align="right" valign="top">double complex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaa21e07016678174db5c804486293cdc0">cpl_array_get_mean_complex</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:gaa21e07016678174db5c804486293cdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean value of a complex array.  <a href="group__cpl__array.html#gaa21e07016678174db5c804486293cdc0">More...</a><br /></td></tr>
<tr class="separator:gaa21e07016678174db5c804486293cdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8ffc287daa729d7b04e4945cfa9a5f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga9a8ffc287daa729d7b04e4945cfa9a5f">cpl_array_get_median</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:ga9a8ffc287daa729d7b04e4945cfa9a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the median of a numeric array.  <a href="group__cpl__array.html#ga9a8ffc287daa729d7b04e4945cfa9a5f">More...</a><br /></td></tr>
<tr class="separator:ga9a8ffc287daa729d7b04e4945cfa9a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fa45fb65475bcbdea9ffee181f3565"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga54fa45fb65475bcbdea9ffee181f3565">cpl_array_get_min</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:ga54fa45fb65475bcbdea9ffee181f3565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum value in a numerical array.  <a href="group__cpl__array.html#ga54fa45fb65475bcbdea9ffee181f3565">More...</a><br /></td></tr>
<tr class="separator:ga54fa45fb65475bcbdea9ffee181f3565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2744fb182287b915fbc9747d57b11c75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga2744fb182287b915fbc9747d57b11c75">cpl_array_get_minpos</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *indx)</td></tr>
<tr class="memdesc:ga2744fb182287b915fbc9747d57b11c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get position of minimum in a numerical array.  <a href="group__cpl__array.html#ga2744fb182287b915fbc9747d57b11c75">More...</a><br /></td></tr>
<tr class="separator:ga2744fb182287b915fbc9747d57b11c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e801eed015223aa6ebdf157896cc164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga8e801eed015223aa6ebdf157896cc164">cpl_array_get_size</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:ga8e801eed015223aa6ebdf157896cc164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of an array.  <a href="group__cpl__array.html#ga8e801eed015223aa6ebdf157896cc164">More...</a><br /></td></tr>
<tr class="separator:ga8e801eed015223aa6ebdf157896cc164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf59b99b6053ebd06c052ca5c2f619a08"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaf59b99b6053ebd06c052ca5c2f619a08">cpl_array_get_stdev</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:gaf59b99b6053ebd06c052ca5c2f619a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation of a numeric array.  <a href="group__cpl__array.html#gaf59b99b6053ebd06c052ca5c2f619a08">More...</a><br /></td></tr>
<tr class="separator:gaf59b99b6053ebd06c052ca5c2f619a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93e096fb44e739a98a76159e762af10d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga93e096fb44e739a98a76159e762af10d">cpl_array_get_string</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx)</td></tr>
<tr class="memdesc:ga93e096fb44e739a98a76159e762af10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a string array.  <a href="group__cpl__array.html#ga93e096fb44e739a98a76159e762af10d">More...</a><br /></td></tr>
<tr class="separator:ga93e096fb44e739a98a76159e762af10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga011b1c53a1081956c531eb65116b3e35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga011b1c53a1081956c531eb65116b3e35">cpl_array_get_type</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:ga011b1c53a1081956c531eb65116b3e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of an array.  <a href="group__cpl__array.html#ga011b1c53a1081956c531eb65116b3e35">More...</a><br /></td></tr>
<tr class="separator:ga011b1c53a1081956c531eb65116b3e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc4a7c53d3a81c79d7efc473e645d6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaedc4a7c53d3a81c79d7efc473e645d6b">cpl_array_has_invalid</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:gaedc4a7c53d3a81c79d7efc473e645d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an array contains at least one invalid element.  <a href="group__cpl__array.html#gaedc4a7c53d3a81c79d7efc473e645d6b">More...</a><br /></td></tr>
<tr class="separator:gaedc4a7c53d3a81c79d7efc473e645d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce90cb02dfff8e66e6b0b1bc5481988"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga2ce90cb02dfff8e66e6b0b1bc5481988">cpl_array_has_valid</a> (const cpl_array *array)</td></tr>
<tr class="memdesc:ga2ce90cb02dfff8e66e6b0b1bc5481988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an array contains at least one valid value.  <a href="group__cpl__array.html#ga2ce90cb02dfff8e66e6b0b1bc5481988">More...</a><br /></td></tr>
<tr class="separator:ga2ce90cb02dfff8e66e6b0b1bc5481988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga485d2592300376ef0262fafcd4377f96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga485d2592300376ef0262fafcd4377f96">cpl_array_insert</a> (cpl_array *target_array, const cpl_array *insert_array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start)</td></tr>
<tr class="memdesc:ga485d2592300376ef0262fafcd4377f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two arrays.  <a href="group__cpl__array.html#ga485d2592300376ef0262fafcd4377f96">More...</a><br /></td></tr>
<tr class="separator:ga485d2592300376ef0262fafcd4377f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49123832ee037a186c21936ba5325bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga49123832ee037a186c21936ba5325bf0">cpl_array_insert_window</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count)</td></tr>
<tr class="memdesc:ga49123832ee037a186c21936ba5325bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a segment of new elements into array.  <a href="group__cpl__array.html#ga49123832ee037a186c21936ba5325bf0">More...</a><br /></td></tr>
<tr class="separator:ga49123832ee037a186c21936ba5325bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cb5ae549a41473e838c5158b7bf7cec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga8cb5ae549a41473e838c5158b7bf7cec">cpl_array_is_valid</a> (const cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx)</td></tr>
<tr class="memdesc:ga8cb5ae549a41473e838c5158b7bf7cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an array element is valid.  <a href="group__cpl__array.html#ga8cb5ae549a41473e838c5158b7bf7cec">More...</a><br /></td></tr>
<tr class="separator:ga8cb5ae549a41473e838c5158b7bf7cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2e8a5596a0d6a02eec584f78c123ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga2d2e8a5596a0d6a02eec584f78c123ac">cpl_array_logarithm</a> (cpl_array *array, double base)</td></tr>
<tr class="memdesc:ga2d2e8a5596a0d6a02eec584f78c123ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logarithm of array elements.  <a href="group__cpl__array.html#ga2d2e8a5596a0d6a02eec584f78c123ac">More...</a><br /></td></tr>
<tr class="separator:ga2d2e8a5596a0d6a02eec584f78c123ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d15805f1fe6e64371c1424309c94352"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga1d15805f1fe6e64371c1424309c94352">cpl_array_multiply</a> (cpl_array *to_array, const cpl_array *from_array)</td></tr>
<tr class="memdesc:ga1d15805f1fe6e64371c1424309c94352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply the values of two numeric or complex arrays.  <a href="group__cpl__array.html#ga1d15805f1fe6e64371c1424309c94352">More...</a><br /></td></tr>
<tr class="separator:ga1d15805f1fe6e64371c1424309c94352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab35b721f5a41d90343587d50c566622a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gab35b721f5a41d90343587d50c566622a">cpl_array_multiply_scalar</a> (cpl_array *array, double value)</td></tr>
<tr class="memdesc:gab35b721f5a41d90343587d50c566622a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a numerical array by a constant value.  <a href="group__cpl__array.html#gab35b721f5a41d90343587d50c566622a">More...</a><br /></td></tr>
<tr class="separator:gab35b721f5a41d90343587d50c566622a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99777185033e7aeb317d0c0c4be5fa9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga99777185033e7aeb317d0c0c4be5fa9c">cpl_array_multiply_scalar_complex</a> (cpl_array *array, double complex value)</td></tr>
<tr class="memdesc:ga99777185033e7aeb317d0c0c4be5fa9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a complex array by a constant complex value.  <a href="group__cpl__array.html#ga99777185033e7aeb317d0c0c4be5fa9c">More...</a><br /></td></tr>
<tr class="separator:ga99777185033e7aeb317d0c0c4be5fa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d187111491f2d3a8b50fff01fbad17"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaf7d187111491f2d3a8b50fff01fbad17">cpl_array_new</a> (<a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> length, <a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a> type)</td></tr>
<tr class="memdesc:gaf7d187111491f2d3a8b50fff01fbad17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new array of given type.  <a href="group__cpl__array.html#gaf7d187111491f2d3a8b50fff01fbad17">More...</a><br /></td></tr>
<tr class="separator:gaf7d187111491f2d3a8b50fff01fbad17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga925ed048a796cbbf9227ea559d444aac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga925ed048a796cbbf9227ea559d444aac">cpl_array_power</a> (cpl_array *array, double exponent)</td></tr>
<tr class="memdesc:ga925ed048a796cbbf9227ea559d444aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the power of numerical array elements.  <a href="group__cpl__array.html#ga925ed048a796cbbf9227ea559d444aac">More...</a><br /></td></tr>
<tr class="separator:ga925ed048a796cbbf9227ea559d444aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a49d38713759c91a6b6da7c0f9671f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga9a49d38713759c91a6b6da7c0f9671f8">cpl_array_power_complex</a> (cpl_array *array, double complex exponent)</td></tr>
<tr class="memdesc:ga9a49d38713759c91a6b6da7c0f9671f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex power of complex, numerical array elements.  <a href="group__cpl__array.html#ga9a49d38713759c91a6b6da7c0f9671f8">More...</a><br /></td></tr>
<tr class="separator:ga9a49d38713759c91a6b6da7c0f9671f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a4ec7768577c9dc688fbbd2eb9d902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga39a4ec7768577c9dc688fbbd2eb9d902">cpl_array_set</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, double value)</td></tr>
<tr class="memdesc:ga39a4ec7768577c9dc688fbbd2eb9d902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a numerical array element.  <a href="group__cpl__array.html#ga39a4ec7768577c9dc688fbbd2eb9d902">More...</a><br /></td></tr>
<tr class="separator:ga39a4ec7768577c9dc688fbbd2eb9d902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35533db8e2f12890899b4d1b81a9971a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga35533db8e2f12890899b4d1b81a9971a">cpl_array_set_complex</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, double complex value)</td></tr>
<tr class="memdesc:ga35533db8e2f12890899b4d1b81a9971a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a complex array element.  <a href="group__cpl__array.html#ga35533db8e2f12890899b4d1b81a9971a">More...</a><br /></td></tr>
<tr class="separator:ga35533db8e2f12890899b4d1b81a9971a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac80deea31ca4980a98437e0c2e854297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gac80deea31ca4980a98437e0c2e854297">cpl_array_set_cplsize</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> value)</td></tr>
<tr class="memdesc:gac80deea31ca4980a98437e0c2e854297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>cpl_size</em> array element.  <a href="group__cpl__array.html#gac80deea31ca4980a98437e0c2e854297">More...</a><br /></td></tr>
<tr class="separator:gac80deea31ca4980a98437e0c2e854297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87673fd4db91c71d3c97e4b70c58d527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga87673fd4db91c71d3c97e4b70c58d527">cpl_array_set_double</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, double value)</td></tr>
<tr class="memdesc:ga87673fd4db91c71d3c97e4b70c58d527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>double</em> array element.  <a href="group__cpl__array.html#ga87673fd4db91c71d3c97e4b70c58d527">More...</a><br /></td></tr>
<tr class="separator:ga87673fd4db91c71d3c97e4b70c58d527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0e22a2666e451ed4ad9c9aa8e284be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga8a0e22a2666e451ed4ad9c9aa8e284be">cpl_array_set_double_complex</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, double complex value)</td></tr>
<tr class="memdesc:ga8a0e22a2666e451ed4ad9c9aa8e284be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>double</em> complex array element.  <a href="group__cpl__array.html#ga8a0e22a2666e451ed4ad9c9aa8e284be">More...</a><br /></td></tr>
<tr class="separator:ga8a0e22a2666e451ed4ad9c9aa8e284be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8fd0fc8aa341ee85a6ac4a88a71fabd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gad8fd0fc8aa341ee85a6ac4a88a71fabd">cpl_array_set_float</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, float value)</td></tr>
<tr class="memdesc:gad8fd0fc8aa341ee85a6ac4a88a71fabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>float</em> array element.  <a href="group__cpl__array.html#gad8fd0fc8aa341ee85a6ac4a88a71fabd">More...</a><br /></td></tr>
<tr class="separator:gad8fd0fc8aa341ee85a6ac4a88a71fabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e60726014688cebcc9f73ebe5e3162e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga0e60726014688cebcc9f73ebe5e3162e">cpl_array_set_float_complex</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, float complex value)</td></tr>
<tr class="memdesc:ga0e60726014688cebcc9f73ebe5e3162e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>float</em> complex array element.  <a href="group__cpl__array.html#ga0e60726014688cebcc9f73ebe5e3162e">More...</a><br /></td></tr>
<tr class="separator:ga0e60726014688cebcc9f73ebe5e3162e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53699ec9f0933202dc67c46211f5f4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga53699ec9f0933202dc67c46211f5f4c6">cpl_array_set_int</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, int value)</td></tr>
<tr class="memdesc:ga53699ec9f0933202dc67c46211f5f4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to an <em>integer</em> array element.  <a href="group__cpl__array.html#ga53699ec9f0933202dc67c46211f5f4c6">More...</a><br /></td></tr>
<tr class="separator:ga53699ec9f0933202dc67c46211f5f4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf177c5261df07eeecdbdd5b9fb0638eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb">cpl_array_set_invalid</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx)</td></tr>
<tr class="memdesc:gaf177c5261df07eeecdbdd5b9fb0638eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate an array element.  <a href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb">More...</a><br /></td></tr>
<tr class="separator:gaf177c5261df07eeecdbdd5b9fb0638eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd532736900c8973bdf5bbb960f9158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gafdd532736900c8973bdf5bbb960f9158">cpl_array_set_long</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, long value)</td></tr>
<tr class="memdesc:gafdd532736900c8973bdf5bbb960f9158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>long</em> <em>integer</em> array element.  <a href="group__cpl__array.html#gafdd532736900c8973bdf5bbb960f9158">More...</a><br /></td></tr>
<tr class="separator:gafdd532736900c8973bdf5bbb960f9158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039525d1b2bb566dcf9f653f94f06154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga039525d1b2bb566dcf9f653f94f06154">cpl_array_set_long_long</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, long long value)</td></tr>
<tr class="memdesc:ga039525d1b2bb566dcf9f653f94f06154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>long</em> <em>long</em> <em>integer</em> array element.  <a href="group__cpl__array.html#ga039525d1b2bb566dcf9f653f94f06154">More...</a><br /></td></tr>
<tr class="separator:ga039525d1b2bb566dcf9f653f94f06154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4515ab30836eb6793514ed0b37dbb2ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga4515ab30836eb6793514ed0b37dbb2ba">cpl_array_set_size</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> new_length)</td></tr>
<tr class="memdesc:ga4515ab30836eb6793514ed0b37dbb2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize an array.  <a href="group__cpl__array.html#ga4515ab30836eb6793514ed0b37dbb2ba">More...</a><br /></td></tr>
<tr class="separator:ga4515ab30836eb6793514ed0b37dbb2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdcddf97688e725811a4c8e7b7abfc01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gafdcddf97688e725811a4c8e7b7abfc01">cpl_array_set_string</a> (cpl_array *array, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx, const char *string)</td></tr>
<tr class="memdesc:gafdcddf97688e725811a4c8e7b7abfc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a character string to a string array element.  <a href="group__cpl__array.html#gafdcddf97688e725811a4c8e7b7abfc01">More...</a><br /></td></tr>
<tr class="separator:gafdcddf97688e725811a4c8e7b7abfc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28267bc350ae578b495a67fd63e12e6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga28267bc350ae578b495a67fd63e12e6c">cpl_array_subtract</a> (cpl_array *to_array, const cpl_array *from_array)</td></tr>
<tr class="memdesc:ga28267bc350ae578b495a67fd63e12e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the values of two numeric or complex arrays.  <a href="group__cpl__array.html#ga28267bc350ae578b495a67fd63e12e6c">More...</a><br /></td></tr>
<tr class="separator:ga28267bc350ae578b495a67fd63e12e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad37320b72a4aca2911d5fac11002fd71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gad37320b72a4aca2911d5fac11002fd71">cpl_array_subtract_scalar</a> (cpl_array *array, double value)</td></tr>
<tr class="memdesc:gad37320b72a4aca2911d5fac11002fd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant value from a numerical array.  <a href="group__cpl__array.html#gad37320b72a4aca2911d5fac11002fd71">More...</a><br /></td></tr>
<tr class="separator:gad37320b72a4aca2911d5fac11002fd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0675ff2c7e86d847869e56636e3016a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gab0675ff2c7e86d847869e56636e3016a">cpl_array_subtract_scalar_complex</a> (cpl_array *array, double complex value)</td></tr>
<tr class="memdesc:gab0675ff2c7e86d847869e56636e3016a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant complex value from a complex array.  <a href="group__cpl__array.html#gab0675ff2c7e86d847869e56636e3016a">More...</a><br /></td></tr>
<tr class="separator:gab0675ff2c7e86d847869e56636e3016a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d1dd093082f040d23a745d49c20a17"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga72d1dd093082f040d23a745d49c20a17">cpl_array_unwrap</a> (cpl_array *array)</td></tr>
<tr class="memdesc:ga72d1dd093082f040d23a745d49c20a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an array, without losing the data buffer.  <a href="group__cpl__array.html#ga72d1dd093082f040d23a745d49c20a17">More...</a><br /></td></tr>
<tr class="separator:ga72d1dd093082f040d23a745d49c20a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb37d9c4565e61ab7bca94316156373e"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gabb37d9c4565e61ab7bca94316156373e">cpl_array_wrap_cplsize</a> (<a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *data, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> length)</td></tr>
<tr class="memdesc:gabb37d9c4565e61ab7bca94316156373e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>cpl_size</em> array from existing data.  <a href="group__cpl__array.html#gabb37d9c4565e61ab7bca94316156373e">More...</a><br /></td></tr>
<tr class="separator:gabb37d9c4565e61ab7bca94316156373e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0efd9f5da20935d8a98859c31d71f935"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga0efd9f5da20935d8a98859c31d71f935">cpl_array_wrap_double</a> (double *data, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> length)</td></tr>
<tr class="memdesc:ga0efd9f5da20935d8a98859c31d71f935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>double</em> array from existing data.  <a href="group__cpl__array.html#ga0efd9f5da20935d8a98859c31d71f935">More...</a><br /></td></tr>
<tr class="separator:ga0efd9f5da20935d8a98859c31d71f935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa547ddac50c2483d2e8a0e7925aa8adf"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaa547ddac50c2483d2e8a0e7925aa8adf">cpl_array_wrap_double_complex</a> (double complex *data, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> length)</td></tr>
<tr class="memdesc:gaa547ddac50c2483d2e8a0e7925aa8adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>double</em> complex array from existing data.  <a href="group__cpl__array.html#gaa547ddac50c2483d2e8a0e7925aa8adf">More...</a><br /></td></tr>
<tr class="separator:gaa547ddac50c2483d2e8a0e7925aa8adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152869e1ce45155939477ec414a63fe2"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga152869e1ce45155939477ec414a63fe2">cpl_array_wrap_float</a> (float *data, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> length)</td></tr>
<tr class="memdesc:ga152869e1ce45155939477ec414a63fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>float</em> array from existing data.  <a href="group__cpl__array.html#ga152869e1ce45155939477ec414a63fe2">More...</a><br /></td></tr>
<tr class="separator:ga152869e1ce45155939477ec414a63fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff22a9a5c3a8716dc4aa15126b5905e8"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gaff22a9a5c3a8716dc4aa15126b5905e8">cpl_array_wrap_float_complex</a> (float complex *data, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> length)</td></tr>
<tr class="memdesc:gaff22a9a5c3a8716dc4aa15126b5905e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>float</em> complex array from existing data.  <a href="group__cpl__array.html#gaff22a9a5c3a8716dc4aa15126b5905e8">More...</a><br /></td></tr>
<tr class="separator:gaff22a9a5c3a8716dc4aa15126b5905e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc7eaabc5ae95aaa957353af9d1eed48"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#gabc7eaabc5ae95aaa957353af9d1eed48">cpl_array_wrap_int</a> (int *data, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> length)</td></tr>
<tr class="memdesc:gabc7eaabc5ae95aaa957353af9d1eed48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>integer</em> array from existing data.  <a href="group__cpl__array.html#gabc7eaabc5ae95aaa957353af9d1eed48">More...</a><br /></td></tr>
<tr class="separator:gabc7eaabc5ae95aaa957353af9d1eed48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72210e435f31ae6c4b6f451bbc1841b3"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga72210e435f31ae6c4b6f451bbc1841b3">cpl_array_wrap_long</a> (long *data, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> length)</td></tr>
<tr class="memdesc:ga72210e435f31ae6c4b6f451bbc1841b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>long</em> <em>integer</em> array from existing data.  <a href="group__cpl__array.html#ga72210e435f31ae6c4b6f451bbc1841b3">More...</a><br /></td></tr>
<tr class="separator:ga72210e435f31ae6c4b6f451bbc1841b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4266345a71a328b697a33048109cbd1c"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga4266345a71a328b697a33048109cbd1c">cpl_array_wrap_long_long</a> (long long *data, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> length)</td></tr>
<tr class="memdesc:ga4266345a71a328b697a33048109cbd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>long</em> <em>long</em> <em>integer</em> array from existing data.  <a href="group__cpl__array.html#ga4266345a71a328b697a33048109cbd1c">More...</a><br /></td></tr>
<tr class="separator:ga4266345a71a328b697a33048109cbd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73860f67710e47e722a150f8e2936351"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__array.html#ga73860f67710e47e722a150f8e2936351">cpl_array_wrap_string</a> (char **data, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> length)</td></tr>
<tr class="memdesc:ga73860f67710e47e722a150f8e2936351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new character string array from existing data.  <a href="group__cpl__array.html#ga73860f67710e47e722a150f8e2936351">More...</a><br /></td></tr>
<tr class="separator:ga73860f67710e47e722a150f8e2936351"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module provides functions to create, destroy and use a <em>cpl_array</em>.</p>
<dl class="section user"><dt>Synopsis:</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cpl_array.h&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga312e71fd365e79ef0359a2fa5fecdb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga312e71fd365e79ef0359a2fa5fecdb77">&#9670;&nbsp;</a></span>cpl_array_abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_abs </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the absolute value of array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>Each array element is replaced by its absolute value. Invalid elements are not modified by this operation. If the array is complex, its type will be turned to real (CPL_TYPE_FLOAT_COMPLEX will be changed into CPL_TYPE_FLOAT, and CPL_TYPE_DOUBLE_COMPLEX will be changed into CPL_TYPE_DOUBLE), and any pointer retrieved by calling <code><a class="el" href="group__cpl__array.html#ga955975ecb1d288fdfa98b1a0050f6c1c" title="Get a pointer to float array data.">cpl_array_get_data_float()</a></code>, <code><a class="el" href="group__cpl__array.html#ga3b284ffb554d127566b89f369a7a631a" title="Get a pointer to double complex array data.">cpl_array_get_data_double_complex()</a></code>, etc., should be discarded. </p>

<p class="reference">References <a class="el" href="group__cpl__array.html#ga011b1c53a1081956c531eb65116b3e35">cpl_array_get_type()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086afdb64c4139e093575cc20d6abc35eaf8">CPL_TYPE_COMPLEX</a>.</p>

</div>
</div>
<a id="ga34e0451f31e2bb26c18981b50c32611b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34e0451f31e2bb26c18981b50c32611b">&#9670;&nbsp;</a></span>cpl_array_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_add </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>to_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>from_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the values of two numeric or complex arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_array</td><td>Target array. </td></tr>
    <tr><td class="paramname">from_array</td><td>Source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INCOMPATIBLE_INPUT </td><td class="ecr">The input arrays have different sizes.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">Any specified array is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>The arrays are summed element by element, and the result of the sum is stored in the target array. The arrays' types may differ, and in that case the operation would be performed using the standard C upcasting rules, with a final cast of the result to the target array type. Invalid elements are propagated consistently: if either or both members of the sum are invalid, the result will be invalid too. Underflows and overflows are ignored. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga0deeffe5d0f37e99dbc27ed308ce0a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0deeffe5d0f37e99dbc27ed308ce0a63">&#9670;&nbsp;</a></span>cpl_array_add_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_add_scalar </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a constant value to a numerical array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Target array </td></tr>
    <tr><td class="paramname">value</td><td>Value to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The input array is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>The operation is always performed in double precision, with a final cast of the result to the target array type. Invalid elements are are not modified by this operation. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga696c3b50d6f7dd191f3c3b9adcc1ef5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga696c3b50d6f7dd191f3c3b9adcc1ef5c">&#9670;&nbsp;</a></span>cpl_array_add_scalar_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_add_scalar_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a constant complex value to a complex array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Target array </td></tr>
    <tr><td class="paramname">value</td><td>Value to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The input array is not complex.   </td></tr>
</table>
</dd>
</dl>
<p>The operation is always performed in double precision, with a final cast of the result to the target array type. Invalid elements are are not modified by this operation. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga0c93e4c252bc6392e0e3a2046f8425d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c93e4c252bc6392e0e3a2046f8425d6">&#9670;&nbsp;</a></span>cpl_array_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_arg </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the phase angle value of array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>Each array element is replaced by its phase angle value. The phase angle will be in the range of [-pi,pi]. Invalid elements are not modified by this operation. If the array is complex, its type will be turned to real (CPL_TYPE_FLOAT_COMPLEX will be changed into CPL_TYPE_FLOAT, and CPL_TYPE_DOUBLE_COMPLEX will be changed into CPL_TYPE_DOUBLE), and any pointer retrieved by calling <code><a class="el" href="group__cpl__array.html#ga955975ecb1d288fdfa98b1a0050f6c1c" title="Get a pointer to float array data.">cpl_array_get_data_float()</a></code>, <code><a class="el" href="group__cpl__array.html#ga3b284ffb554d127566b89f369a7a631a" title="Get a pointer to double complex array data.">cpl_array_get_data_double_complex()</a></code>, etc., should be discarded. </p>

<p class="reference">References <a class="el" href="group__cpl__array.html#ga011b1c53a1081956c531eb65116b3e35">cpl_array_get_type()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086afdb64c4139e093575cc20d6abc35eaf8">CPL_TYPE_COMPLEX</a>.</p>

</div>
</div>
<a id="ga5d816900ddde0f301f4c6d764ddd065d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d816900ddde0f301f4c6d764ddd065d">&#9670;&nbsp;</a></span>cpl_array_cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_cast </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast a numeric array to a new numeric type array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array. </td></tr>
    <tr><td class="paramname">type</td><td>Type of new array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New array.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is not numerical.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The specified <em>type</em> is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>A new array of the specified type is created, and the content of the input numeric array is cast to the new type. If the input array type is identical to the specified type the array is duplicated as is done by the function <code><a class="el" href="group__cpl__array.html#ga4d2bbefc13a4c4d7d03a3413202653db" title="Make a copy of an array.">cpl_array_duplicate()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a4923f03f3a673edd344b0d81835ca69e">CPL_TYPE_DOUBLE</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086afc7205e8b040bdfdee6011685cfe4345">CPL_TYPE_DOUBLE_COMPLEX</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086aa44c37e26b9040a96e3a49b405946942">CPL_TYPE_FLOAT</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086ab2ab0f96a382011a38ee9446626fe1e0">CPL_TYPE_FLOAT_COMPLEX</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086ae333db5ccea0813ccd892525b4ba1345">CPL_TYPE_INT</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a53e9a61e6c21933902298f9a9d1b2faf">CPL_TYPE_LONG</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086acea0fe783323e91b754bf20915d7038b">CPL_TYPE_LONG_LONG</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a46fa44e4ea49bfa00a5c11f1a52228a6">CPL_TYPE_SIZE</a>.</p>

</div>
</div>
<a id="ga5770d80a31e02a2e60f357f546da16d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5770d80a31e02a2e60f357f546da16d8">&#9670;&nbsp;</a></span>cpl_array_copy_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_copy_data </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy buffer of numerical data to a numerical array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Existing array. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If the array is not numerical, a <code>CPL_ERROR_INVALID_TYPE</code> is returned. At any <code>NULL</code> input pointer a <code>CPL_ERROR_NULL_INPUT</code> would be returned.</dd></dl>
<p>The input data are copied into the specified array. If the type of the accessed array is not <em>CPL_TYPE_DOUBLE</em>, the data values will be truncated according to C casting rules. The size of the input data buffer is not checked in any way, and the values are all considered valid: invalid values should be marked using the functions <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. If <em>N</em> is the length of the array, the first <em>N</em> values of the input data buffer would be copied to the column buffer. If the array had length zero, no values would be copied. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga146a768f68b5b2f3eb3af2bbe692f531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga146a768f68b5b2f3eb3af2bbe692f531">&#9670;&nbsp;</a></span>cpl_array_copy_data_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_copy_data_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy buffer of complex data to a complex array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Existing array. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If the array is not complex, a <code>CPL_ERROR_INVALID_TYPE</code> is returned. At any <code>NULL</code> input pointer a <code>CPL_ERROR_NULL_INPUT</code> would be returned.</dd></dl>
<p>The input data are copied into the specified array. If the type of the accessed array is not <em>CPL_TYPE_DOUBLE</em>, the data values will be truncated according to C casting rules. The size of the input data buffer is not checked in any way, and the values are all considered valid: invalid values should be marked using the functions <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. If <em>N</em> is the length of the array, the first <em>N</em> values of the input data buffer would be copied to the column buffer. If the array had length zero, no values would be copied. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga0d1df1328e2f8bc974db5ca33ec80d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d1df1328e2f8bc974db5ca33ec80d59">&#9670;&nbsp;</a></span>cpl_array_copy_data_cplsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_copy_data_cplsize </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a <em>cpl_size</em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Existing array. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If the input array is not of type <code>CPL_TYPE_SIZE</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. At any <code>NULL</code> input pointer a <code>CPL_ERROR_NULL_INPUT</code> would be returned.</dd></dl>
<p>The input data are copied into the specified array. The size of the input data buffer is not checked in any way, and the data values are all considered valid: invalid values should be marked using the functions <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. If <em>N</em> is the length of the array, the first <em>N</em> values of the input data buffer would be copied to the array buffer. If the array had length zero, no values would be copied. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gade072cdd9ee37177e02bb06da1739fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade072cdd9ee37177e02bb06da1739fb6">&#9670;&nbsp;</a></span>cpl_array_copy_data_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_copy_data_double </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a <em>double</em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Existing array. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If the input array is not of type <code>CPL_TYPE_DOUBLE</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. At any <code>NULL</code> input pointer a <code>CPL_ERROR_NULL_INPUT</code> would be returned.</dd></dl>
<p>See documentation of function <code><a class="el" href="group__cpl__array.html#ga4d82d5bb1920256901f41114a5c5ab84" title="Copy existing data to an integer array.">cpl_array_copy_data_int()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gab410794547ed8e4cf6b4c2a27f8861f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab410794547ed8e4cf6b4c2a27f8861f0">&#9670;&nbsp;</a></span>cpl_array_copy_data_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_copy_data_double_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a <em>double</em> complex array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Existing array. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If the input array is not of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. At any <code>NULL</code> input pointer a <code>CPL_ERROR_NULL_INPUT</code> would be returned.</dd></dl>
<p>See documentation of function <code><a class="el" href="group__cpl__array.html#ga4d82d5bb1920256901f41114a5c5ab84" title="Copy existing data to an integer array.">cpl_array_copy_data_int()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga29d6454f60e77c9fd179ed7782718d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29d6454f60e77c9fd179ed7782718d8e">&#9670;&nbsp;</a></span>cpl_array_copy_data_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_copy_data_float </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a <em>float</em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Existing array. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If the input array is not of type <code>CPL_TYPE_FLOAT</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. At any <code>NULL</code> input pointer a <code>CPL_ERROR_NULL_INPUT</code> would be returned.</dd></dl>
<p>See documentation of function <code><a class="el" href="group__cpl__array.html#ga4d82d5bb1920256901f41114a5c5ab84" title="Copy existing data to an integer array.">cpl_array_copy_data_int()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga1745e7d37e7ee5a410a27598db499633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1745e7d37e7ee5a410a27598db499633">&#9670;&nbsp;</a></span>cpl_array_copy_data_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_copy_data_float_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float complex *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a <em>float</em> complex array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Existing array. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If the input array is not of type <code>CPL_TYPE_FLOAT_COMPLEX</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. At any <code>NULL</code> input pointer a <code>CPL_ERROR_NULL_INPUT</code> would be returned.</dd></dl>
<p>See documentation of function <code><a class="el" href="group__cpl__array.html#ga4d82d5bb1920256901f41114a5c5ab84" title="Copy existing data to an integer array.">cpl_array_copy_data_int()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga4d82d5bb1920256901f41114a5c5ab84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d82d5bb1920256901f41114a5c5ab84">&#9670;&nbsp;</a></span>cpl_array_copy_data_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_copy_data_int </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to an <em>integer</em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Existing array. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If the input array is not of type <code>CPL_TYPE_INT</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. At any <code>NULL</code> input pointer a <code>CPL_ERROR_NULL_INPUT</code> would be returned.</dd></dl>
<p>The input data are copied into the specified array. The size of the input data buffer is not checked in any way, and the data values are all considered valid: invalid values should be marked using the functions <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. If <em>N</em> is the length of the array, the first <em>N</em> values of the input data buffer would be copied to the array buffer. If the array had length zero, no values would be copied. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gac39674e8f2d41417f26fdb5919f9e5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac39674e8f2d41417f26fdb5919f9e5f7">&#9670;&nbsp;</a></span>cpl_array_copy_data_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_copy_data_long </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a <em>long</em> <em>integer</em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Existing array. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If the input array is not of type <code>CPL_TYPE_LONG</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. At any <code>NULL</code> input pointer a <code>CPL_ERROR_NULL_INPUT</code> would be returned.</dd></dl>
<p>The input data are copied into the specified array. The size of the input data buffer is not checked in any way, and the data values are all considered valid: invalid values should be marked using the functions <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. If <em>N</em> is the length of the array, the first <em>N</em> values of the input data buffer would be copied to the array buffer. If the array had length zero, no values would be copied. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga48dc79ded7abe6d6f6360869f218fb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48dc79ded7abe6d6f6360869f218fb8d">&#9670;&nbsp;</a></span>cpl_array_copy_data_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_copy_data_long_long </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a <em>long</em> <em>long</em> <em>integer</em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Existing array. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If the input array is not of type <code>CPL_TYPE_LONG_LONG</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. At any <code>NULL</code> input pointer a <code>CPL_ERROR_NULL_INPUT</code> would be returned.</dd></dl>
<p>The input data are copied into the specified array. The size of the input data buffer is not checked in any way, and the data values are all considered valid: invalid values should be marked using the functions <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. If <em>N</em> is the length of the array, the first <em>N</em> values of the input data buffer would be copied to the array buffer. If the array had length zero, no values would be copied. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga5a3af94c72bbc926aabb761892228917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a3af94c72bbc926aabb761892228917">&#9670;&nbsp;</a></span>cpl_array_copy_data_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_copy_data_string </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a <em>string</em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Existing array. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If the input array is not of type <code>CPL_TYPE_STRING</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. At any <code>NULL</code> input pointer a <code>CPL_ERROR_NULL_INPUT</code> would be returned.</dd></dl>
<p>See documentation of function <code><a class="el" href="group__cpl__array.html#ga4d82d5bb1920256901f41114a5c5ab84" title="Copy existing data to an integer array.">cpl_array_copy_data_int()</a></code>.</p>
<p>The input data are copied into the specified array. The size of the input buffer is not checked in any way. The strings pointed by the input buffer are all duplicated, while the strings contained in the array are released before being overwritten. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gaa2bb9c166dc45fe02114a2a6fdaaaf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2bb9c166dc45fe02114a2a6fdaaaf90">&#9670;&nbsp;</a></span>cpl_array_count_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_array_count_invalid </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count number of invalid elements in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to inquire.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of invalid elements in an array. -1 is always returned in case of error.</dd></dl>
<p>Count number of invalid elements in an array. If the array itself is a <code>NULL</code> pointer, an error <code>CPL_ERROR_NULL_INPUT</code> is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga6bffcca34e6751f1e5c2db6497be2074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bffcca34e6751f1e5c2db6497be2074">&#9670;&nbsp;</a></span>cpl_array_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpl_array_delete </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function deletes an array. If the input array is <code>NULL</code>, nothing is done, and no error is set. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__array.html#gad4e311edd18e037607ecb2122c42d418">cpl_array_extract()</a>, <a class="el" href="group__cpl__fit.html#ga8004d897c449d503c56f14ca99cf475b">cpl_fit_image_gaussian()</a>, <a class="el" href="group__cpl__table.html#gad3d6e80aaaa6c23a6ea33e5b4a3446a3">cpl_table_compare_structure()</a>, <a class="el" href="group__cpl__wcs.html#ga3e6e2597917be71afeb5de2d957a659a">cpl_wcs_convert()</a>, <a class="el" href="group__cpl__wcs.html#gad3c5f9a87cfe66226c1690953539f46b">cpl_wcs_delete()</a>, and <a class="el" href="group__cpl__wcs.html#gaef2a2ad1e5206d26175ab95f81afb58c">cpl_wcs_platesol()</a>.</p>

</div>
</div>
<a id="ga5b0f15f7afb9e90c914bb8707f85df2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b0f15f7afb9e90c914bb8707f85df2a">&#9670;&nbsp;</a></span>cpl_array_divide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_divide </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>to_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>from_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide the values of two numeric or complex arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_array</td><td>Target array. </td></tr>
    <tr><td class="paramname">from_array</td><td>Source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INCOMPATIBLE_INPUT </td><td class="ecr">The input arrays have different sizes.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">Any specified array is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>The arrays are divided element by element, and the result is stored in the target array. See the documentation of the function <code><a class="el" href="group__cpl__array.html#ga34e0451f31e2bb26c18981b50c32611b" title="Add the values of two numeric or complex arrays.">cpl_array_add()</a></code> for further details. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga761a432ecee2da8cf9a01c0713cc2f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga761a432ecee2da8cf9a01c0713cc2f04">&#9670;&nbsp;</a></span>cpl_array_divide_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_divide_scalar </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide a numerical array by a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Target array </td></tr>
    <tr><td class="paramname">value</td><td>Divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The input <em>array</em> is not numerical.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DIVISION_BY_ZERO </td><td class="ecr">The input <em>value</em> is zero.   </td></tr>
</table>
</dd>
</dl>
<p>The operation is always performed in double precision, with a final cast of the result to the target array type. Invalid elements are not modified by this operation. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gab76554f2fb30f9e618fe06035d8ccada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab76554f2fb30f9e618fe06035d8ccada">&#9670;&nbsp;</a></span>cpl_array_divide_scalar_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_divide_scalar_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide a complex array by a constant complex value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Target array </td></tr>
    <tr><td class="paramname">value</td><td>Divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The input <em>array</em> is not complex.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DIVISION_BY_ZERO </td><td class="ecr">The input <em>value</em> is zero.   </td></tr>
</table>
</dd>
</dl>
<p>The operation is always performed in double precision, with a final cast of the result to the target array type. Invalid elements are not modified by this operation. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gae34bfd342242da76465bac08133d6552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae34bfd342242da76465bac08133d6552">&#9670;&nbsp;</a></span>cpl_array_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpl_array_dump </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array </td></tr>
    <tr><td class="paramname">start</td><td>First element to print </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements to print </td></tr>
    <tr><td class="paramname">stream</td><td>The output stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function is mainly intended for debug purposes. Array elements are counted from 0, and their sequence number is printed at the left of each element. Invalid elements are represented as a sequence of "-" as wide as the field occupied by the array. Specifying a <em>start</em> beyond the array boundaries, or a non-positive <em>count</em>, would generate a warning message, but no error would be set. The specified number of elements to print may exceed the array end, and in that case the array would be printed up to its last element. If the specified stream is <code>NULL</code>, it is set to <em>stdout</em>. The function used for printing is the standard C <code>fprintf()</code>. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>, <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>, <a class="el" href="group__cpl__memory.html#gac884edcb0a592489c65239d0e5d08785">cpl_malloc()</a>, <a class="el" href="group__cpl__type.html#ga4f6c44a14bbc3aea87b1f47acf8dfd02">CPL_SIZE_FORMAT</a>, <a class="el" href="group__cpl__memory.html#ga3182acba4528fb26736337aadfb839de">cpl_sprintf()</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a4923f03f3a673edd344b0d81835ca69e">CPL_TYPE_DOUBLE</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086afc7205e8b040bdfdee6011685cfe4345">CPL_TYPE_DOUBLE_COMPLEX</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086aa44c37e26b9040a96e3a49b405946942">CPL_TYPE_FLOAT</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086ab2ab0f96a382011a38ee9446626fe1e0">CPL_TYPE_FLOAT_COMPLEX</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086ae333db5ccea0813ccd892525b4ba1345">CPL_TYPE_INT</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a53e9a61e6c21933902298f9a9d1b2faf">CPL_TYPE_LONG</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086acea0fe783323e91b754bf20915d7038b">CPL_TYPE_LONG_LONG</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a46fa44e4ea49bfa00a5c11f1a52228a6">CPL_TYPE_SIZE</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8c58196493fdac6c0424560417cd6bf8">CPL_TYPE_STRING</a>.</p>

</div>
</div>
<a id="ga9d257aed16ec2f5a3035fb6c8697a1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d257aed16ec2f5a3035fb6c8697a1af">&#9670;&nbsp;</a></span>cpl_array_dump_structure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpl_array_dump_structure </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describe the structure and the contents of an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array. </td></tr>
    <tr><td class="paramname">stream</td><td>The output stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function is mainly intended for debug purposes. Some information about the structure of an array and its contents is printed to terminal:</p>
<ul>
<li>Data type of the array</li>
<li>Number of elements</li>
<li>Number of invalid elements</li>
</ul>
<p>If the specified stream is <code>NULL</code>, it is set to <em>stdout</em>. The function used for printing is the standard C <code>fprintf()</code>. </p>

<p class="reference">References <a class="el" href="group__cpl__type.html#ga4f6c44a14bbc3aea87b1f47acf8dfd02">CPL_SIZE_FORMAT</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a4923f03f3a673edd344b0d81835ca69e">CPL_TYPE_DOUBLE</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086afc7205e8b040bdfdee6011685cfe4345">CPL_TYPE_DOUBLE_COMPLEX</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086aa44c37e26b9040a96e3a49b405946942">CPL_TYPE_FLOAT</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086ab2ab0f96a382011a38ee9446626fe1e0">CPL_TYPE_FLOAT_COMPLEX</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086ae333db5ccea0813ccd892525b4ba1345">CPL_TYPE_INT</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a53e9a61e6c21933902298f9a9d1b2faf">CPL_TYPE_LONG</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086acea0fe783323e91b754bf20915d7038b">CPL_TYPE_LONG_LONG</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a46fa44e4ea49bfa00a5c11f1a52228a6">CPL_TYPE_SIZE</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8c58196493fdac6c0424560417cd6bf8">CPL_TYPE_STRING</a>.</p>

</div>
</div>
<a id="ga4d2bbefc13a4c4d7d03a3413202653db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d2bbefc13a4c4d7d03a3413202653db">&#9670;&nbsp;</a></span>cpl_array_duplicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_duplicate </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a copy of an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be duplicated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new array, or <code>NULL</code> in case of error.</dd></dl>
<p>If the input <em>array</em> is a <code>NULL</code> pointer, a <code>CPL_ERROR_NULL_INPUT</code> is returned. Copy is "in depth": in the case of a <em>string</em> array, also the string elements are duplicated. </p>

<p class="reference">References <a class="el" href="group__cpl__array.html#ga8e801eed015223aa6ebdf157896cc164">cpl_array_get_size()</a>, <a class="el" href="group__cpl__array.html#ga011b1c53a1081956c531eb65116b3e35">cpl_array_get_type()</a>, <a class="el" href="group__cpl__array.html#gaf7d187111491f2d3a8b50fff01fbad17">cpl_array_new()</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga0d697433645b215307214fd890985089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d697433645b215307214fd890985089">&#9670;&nbsp;</a></span>cpl_array_erase_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_erase_window </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a segment of an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Input array </td></tr>
    <tr><td class="paramname">start</td><td>First element to delete. </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr"><em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input array has length zero, or <em>start</em> is outside the table range.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
</table>
</dd>
</dl>
<p>A portion of the array data is physically removed. The pointers to data may change, therefore pointers previously retrieved by calling <code><a class="el" href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f" title="Get a pointer to integer array data.">cpl_array_get_data_int()</a></code>, <code><a class="el" href="group__cpl__array.html#ga0e5d705ae246e2580532d51589f979c5" title="Get a pointer to string array data.">cpl_array_get_data_string()</a></code>, etc., should be discarded. The specified segment can extend beyond the end of the array, and in that case elements will be removed up to the end of the array. </p>

<p class="reference">References <a class="el" href="group__cpl__array.html#ga8e801eed015223aa6ebdf157896cc164">cpl_array_get_size()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga3a11ecf7268ea476a68fcbe9cfdfd285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a11ecf7268ea476a68fcbe9cfdfd285">&#9670;&nbsp;</a></span>cpl_array_exponential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_exponential </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the exponential of array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array. </td></tr>
    <tr><td class="paramname">base</td><td>Exponential base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not numerical or complex.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The input <em>base</em> is not positive.   </td></tr>
</table>
</dd>
</dl>
<p>Each column element is replaced by its exponential in the specified base. The operation is always performed in double precision, with a final cast of the result to the array type. Invalid elements are not modified by this operation. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gad4e311edd18e037607ecb2122c42d418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4e311edd18e037607ecb2122c42d418">&#9670;&nbsp;</a></span>cpl_array_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_extract </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an array from a section of another array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Input array </td></tr>
    <tr><td class="paramname">start</td><td>First element to be copied to new array. </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new array, or <code>NULL</code> in case or error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>array</em> has zero length, or <em>start</em> is outside the array boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
</table>
</dd>
</dl>
<p>A number of consecutive elements are copied from an input array to a newly created array. If the sum of <em>start</em> and <em>count</em> goes beyond the end of the input array, elements are copied up to the end. </p>

<p class="reference">References <a class="el" href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074">cpl_array_delete()</a>, <a class="el" href="group__cpl__array.html#ga8e801eed015223aa6ebdf157896cc164">cpl_array_get_size()</a>, <a class="el" href="group__cpl__array.html#ga011b1c53a1081956c531eb65116b3e35">cpl_array_get_type()</a>, <a class="el" href="group__cpl__array.html#gaf7d187111491f2d3a8b50fff01fbad17">cpl_array_new()</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gaefa4c3310c7c836abc695d797705aa62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefa4c3310c7c836abc695d797705aa62">&#9670;&nbsp;</a></span>cpl_array_extract_imag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_extract_imag </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the imaginary value of array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New array with imaginary part of input array elements.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>A new array is created with the imaginary part of all input array elements. If the input array is complex, the output type will be CPL_TYPE_FLOAT if input is CPL_TYPE_FLOAT_COMPLEX, and CPL_TYPE_DOUBLE if input is CPL_TYPE_DOUBLE_COMPLEX). </p>

<p class="reference">References <a class="el" href="group__cpl__array.html#ga011b1c53a1081956c531eb65116b3e35">cpl_array_get_type()</a>, <a class="el" href="group__cpl__array.html#gaf7d187111491f2d3a8b50fff01fbad17">cpl_array_new()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086afdb64c4139e093575cc20d6abc35eaf8">CPL_TYPE_COMPLEX</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086aa44c37e26b9040a96e3a49b405946942">CPL_TYPE_FLOAT</a>.</p>

</div>
</div>
<a id="gaa8fd08e7b11baf6a3f44ec0c1060c1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8fd08e7b11baf6a3f44ec0c1060c1ef">&#9670;&nbsp;</a></span>cpl_array_extract_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_extract_real </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the real value of array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New array with real part of input array elements.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>A new array is created with the real part of all input array elements. If the input array is complex, the output type will be CPL_TYPE_FLOAT if input is CPL_TYPE_FLOAT_COMPLEX, and CPL_TYPE_DOUBLE if input is CPL_TYPE_DOUBLE_COMPLEX). </p>

<p class="reference">References <a class="el" href="group__cpl__array.html#ga011b1c53a1081956c531eb65116b3e35">cpl_array_get_type()</a>, <a class="el" href="group__cpl__array.html#gaf7d187111491f2d3a8b50fff01fbad17">cpl_array_new()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086afdb64c4139e093575cc20d6abc35eaf8">CPL_TYPE_COMPLEX</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086aa44c37e26b9040a96e3a49b405946942">CPL_TYPE_FLOAT</a>.</p>

</div>
</div>
<a id="ga83f215dd3642ac04434dc11f19cfb531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83f215dd3642ac04434dc11f19cfb531">&#9670;&nbsp;</a></span>cpl_array_fill_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_fill_window </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the same value within a numerical array segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin write value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of numerical type, a <code>CPL_ERROR_INVALID_TYPE</code> is returned. If <em>start</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned.</dd></dl>
<p>Write the same value to a numerical array segment. The value is cast to the accessed array type. The written values are automatically flagged as valid. To invalidate an array interval use <code><a class="el" href="group__cpl__array.html#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2" title="Set an array segment to NULL.">cpl_array_fill_window_invalid()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#gabbcd8712863836e78e6960722ae1ab96">cpl_table_where_selected()</a>.</p>

</div>
</div>
<a id="ga6fc1db4e5939deba92ee2d0445bb0473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fc1db4e5939deba92ee2d0445bb0473">&#9670;&nbsp;</a></span>cpl_array_fill_window_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_fill_window_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the same value within a complex array segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin write value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of numerical type, a <code>CPL_ERROR_INVALID_TYPE</code> is returned. If <em>start</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned.</dd></dl>
<p>Write the same value to a complex array segment. The value is cast to the accessed array type. The written values are automatically flagged as valid. To invalidate an array interval use <code><a class="el" href="group__cpl__array.html#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2" title="Set an array segment to NULL.">cpl_array_fill_window_invalid()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga90e880102fcc9c695272b1b197673ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90e880102fcc9c695272b1b197673ebc">&#9670;&nbsp;</a></span>cpl_array_fill_window_cplsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_fill_window_cplsize </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the same value within a <em>cpl_size</em> array segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin write value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. If <em>start</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the error <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned. If <em>count</em> is negative, a <code>CPL_ERROR_ILLEGAL_INPUT</code> is returned.</dd></dl>
<p>Write the same value to a <em>cpl_size</em> array segment. The written values are automatically flagged as valid. To invalidate an array interval use <code><a class="el" href="group__cpl__array.html#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2" title="Set an array segment to NULL.">cpl_array_fill_window_invalid()</a></code>. The <em>count</em> argument can go beyond the array end, and in that case the specified <em>value</em> will be written just up to the end of the array. If <em>count</em> is zero, the array is not modified and no error is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gae48974a884287d4b83b6f1f6df39cf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae48974a884287d4b83b6f1f6df39cf32">&#9670;&nbsp;</a></span>cpl_array_fill_window_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_fill_window_double </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the same value within a <em>double</em> array segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin write value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. If <em>start</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the error <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned. If <em>count</em> is negative, a <code>CPL_ERROR_ILLEGAL_INPUT</code> is returned.</dd></dl>
<p>Write the same value to a <em>double</em> array segment. The written values are automatically flagged as valid. To invalidate an array interval use <code><a class="el" href="group__cpl__array.html#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2" title="Set an array segment to NULL.">cpl_array_fill_window_invalid()</a></code>. The <em>count</em> argument can go beyond the array end, and in that case the specified <em>value</em> will be written just up to the end of the array. If <em>count</em> is zero, the array is not modified and no error is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gad57ef869111e8368c937ae0d7fe21b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad57ef869111e8368c937ae0d7fe21b06">&#9670;&nbsp;</a></span>cpl_array_fill_window_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_fill_window_double_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the same value within a <em>double</em> complex array segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin write value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. If <em>start</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the error <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned. If <em>count</em> is negative, a <code>CPL_ERROR_ILLEGAL_INPUT</code> is returned.</dd></dl>
<p>Write the same value to a <em>double</em> complex array segment. The written values are automatically flagged as valid. To invalidate an array interval use <code><a class="el" href="group__cpl__array.html#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2" title="Set an array segment to NULL.">cpl_array_fill_window_invalid()</a></code>. The <em>count</em> argument can go beyond the array end, and in that case the specified <em>value</em> will be written just up to the end of the array. If <em>count</em> is zero, the array is not modified and no error is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga741fa062e3a68cb111fb4bcf4d1e59b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga741fa062e3a68cb111fb4bcf4d1e59b0">&#9670;&nbsp;</a></span>cpl_array_fill_window_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_fill_window_float </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the same value within a <em>float</em> array segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin write value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. If <em>start</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the error <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned. If <em>count</em> is negative, a <code>CPL_ERROR_ILLEGAL_INPUT</code> is returned.</dd></dl>
<p>Write the same value to a <em>float</em> array segment. The written values are automatically flagged as valid. To invalidate an array interval use <code><a class="el" href="group__cpl__array.html#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2" title="Set an array segment to NULL.">cpl_array_fill_window_invalid()</a></code>. The <em>count</em> argument can go beyond the array end, and in that case the specified <em>value</em> will be written just up to the end of the array. If <em>count</em> is zero, the array is not modified and no error is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga58a801bf2758aba8f39017ac04188476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58a801bf2758aba8f39017ac04188476">&#9670;&nbsp;</a></span>cpl_array_fill_window_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_fill_window_float_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the same value within a <em>float</em> complex array segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin write value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. If <em>start</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the error <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned. If <em>count</em> is negative, a <code>CPL_ERROR_ILLEGAL_INPUT</code> is returned.</dd></dl>
<p>Write the same value to a <em>float</em> complex array segment. The written values are automatically flagged as valid. To invalidate an array interval use <code><a class="el" href="group__cpl__array.html#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2" title="Set an array segment to NULL.">cpl_array_fill_window_invalid()</a></code>. The <em>count</em> argument can go beyond the array end, and in that case the specified <em>value</em> will be written just up to the end of the array. If <em>count</em> is zero, the array is not modified and no error is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gaf83bacd759bb90887ca113ea42047c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf83bacd759bb90887ca113ea42047c92">&#9670;&nbsp;</a></span>cpl_array_fill_window_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_fill_window_int </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the same value within an <em>integer</em> array segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin write value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. If <em>start</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the error <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned. If <em>count</em> is negative, a <code>CPL_ERROR_ILLEGAL_INPUT</code> is returned.</dd></dl>
<p>Write the same value to an <em>integer</em> array segment. The written values are automatically flagged as valid. To invalidate an array interval use <code><a class="el" href="group__cpl__array.html#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2" title="Set an array segment to NULL.">cpl_array_fill_window_invalid()</a></code>. The <em>count</em> argument can go beyond the array end, and in that case the specified <em>value</em> will be written just up to the end of the array. If <em>count</em> is zero, the array is not modified and no error is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2">&#9670;&nbsp;</a></span>cpl_array_fill_window_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_fill_window_invalid </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an array segment to NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to start writing NULLs. </td></tr>
    <tr><td class="paramname">count</td><td>Number of column elements to set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If <em>start</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the error <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned. If <em>count</em> is negative, a <code>CPL_ERROR_ILLEGAL_INPUT</code> is returned.</dd></dl>
<p>Invalidate values contained in an array segment. The <em>count</em> argument can go beyond the array end, and in that case the values will be invalidated up to the end of the array. If <em>count</em> is zero, the array is not modified and no error is set. In the case of a <em>string</em> array, the invalidated strings are set free and their pointers are set to <code>NULL</code>; for other data types, the corresponding elements are flagged as invalid. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga9e69bb6fb617ecb546ac6d864427a17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e69bb6fb617ecb546ac6d864427a17d">&#9670;&nbsp;</a></span>cpl_array_fill_window_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_fill_window_long </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the same value within a <em>long</em> <em>integer</em> array segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin write value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. If <em>start</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the error <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned. If <em>count</em> is negative, a <code>CPL_ERROR_ILLEGAL_INPUT</code> is returned.</dd></dl>
<p>Write the same value to a <em>long</em> <em>integer</em> array segment. The written values are automatically flagged as valid. To invalidate an array interval use <code><a class="el" href="group__cpl__array.html#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2" title="Set an array segment to NULL.">cpl_array_fill_window_invalid()</a></code>. The <em>count</em> argument can go beyond the array end, and in that case the specified <em>value</em> will be written just up to the end of the array. If <em>count</em> is zero, the array is not modified and no error is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga59d3b674bdca51f6a754dde2ecc4186c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59d3b674bdca51f6a754dde2ecc4186c">&#9670;&nbsp;</a></span>cpl_array_fill_window_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_fill_window_long_long </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the same value within a <em>long</em> <em>long</em> <em>integer</em> array segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin write value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. If <em>start</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the error <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned. If <em>count</em> is negative, a <code>CPL_ERROR_ILLEGAL_INPUT</code> is returned.</dd></dl>
<p>Write the same value to a <em>long</em> <em>long</em> <em>integer</em> array segment. The written values are automatically flagged as valid. To invalidate an array interval use <code><a class="el" href="group__cpl__array.html#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2" title="Set an array segment to NULL.">cpl_array_fill_window_invalid()</a></code>. The <em>count</em> argument can go beyond the array end, and in that case the specified <em>value</em> will be written just up to the end of the array. If <em>count</em> is zero, the array is not modified and no error is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga8c61b18495db4c5c990076f791ff33d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c61b18495db4c5c990076f791ff33d9">&#9670;&nbsp;</a></span>cpl_array_fill_window_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_fill_window_string </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a string to a string array segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin write value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. If <em>start</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the error <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned. If <em>count</em> is negative, a <code>CPL_ERROR_ILLEGAL_INPUT</code> is returned.</dd></dl>
<p>Copy the same string to a string array segment. If the input string is not a <code>NULL</code> pointer, it is duplicated for each accessed array element. If the input string is <code>NULL</code>, this call is equivalent to <code><a class="el" href="group__cpl__array.html#ga5cf66a6cdd3a4bfd5ea6f52cc5fb99a2" title="Set an array segment to NULL.">cpl_array_fill_window_invalid()</a></code>. The <em>count</em> argument can go beyond the array end, and in that case the specified <em>value</em> will be copied just up to the end of the array. If <em>count</em> is zero, the array is not modified and no error is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga1639e3c0603907ad879cccb607ea93ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1639e3c0603907ad879cccb607ea93ce">&#9670;&nbsp;</a></span>cpl_array_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_array_get </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a numerical array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating null values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value read. In case of an invalid array element, or in case of error, 0.0 is returned.</dd></dl>
<p>Read a value from a numerical array. A <code>CPL_ERROR_NULL_INPUT</code> is set in case <em>array</em> is a <code>NULL</code> pointer. A <code>CPL_ERROR_INVALID_TYPE</code> is set in case a non-numerical array is accessed. <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is set if the <em>indx</em> is outside the array range. Indexes are counted starting from 0. If the input array has length zero, <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always set. The <em>null</em> flag is used to indicate whether the accessed array element is valid (0) or invalid (1). The null flag also signals an error condition (-1). The <em>null</em> argument can be left to <code>NULL</code>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="gaf94fdf2504a9cd7f31b3b151c8736ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf94fdf2504a9cd7f31b3b151c8736ef8">&#9670;&nbsp;</a></span>cpl_array_get_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double complex cpl_array_get_complex </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a complex array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating null values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value read. In case of an invalid array element, or in case of error, 0.0 is returned.</dd></dl>
<p>Read a value from a complex array. A <code>CPL_ERROR_NULL_INPUT</code> is set in case <em>array</em> is a <code>NULL</code> pointer. A <code>CPL_ERROR_INVALID_TYPE</code> is set in case a non-complex array is accessed. <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is set if the <em>indx</em> is outside the array range. Indexes are counted starting from 0. If the input array has length zero, <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always set. The <em>null</em> flag is used to indicate whether the accessed array element is valid (0) or invalid (1). The null flag also signals an error condition (-1). The <em>null</em> argument can be left to <code>NULL</code>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="ga3fff5accef0f29506e7591f80770d2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fff5accef0f29506e7591f80770d2aa">&#9670;&nbsp;</a></span>cpl_array_get_cplsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_array_get_cplsize </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>cpl_size</em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating null values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cpl_size value read. In case of an invalid array element, or in case of error, 0 is returned.</dd></dl>
<p>Read a value from an array of type <code>CPL_TYPE_SIZE</code>. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is set. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is set. Indexes are counted starting from 0. If the input array has length zero, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always set. If the <em>null</em> flag is a valid pointer, it is used to indicate whether the accessed array element is valid (0) or invalid (1). The null flag also signals an error condition (-1). </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="gabb15b7dfc7335f0e3aa0758349ab01cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb15b7dfc7335f0e3aa0758349ab01cb">&#9670;&nbsp;</a></span>cpl_array_get_data_cplsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>* cpl_array_get_data_cplsize </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <code>cpl_size</code> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <code>cpl_size</code> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_SIZE</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<dl class="section note"><dt>Note</dt><dd>Use at your own risk: direct manipulation of array data rules out any check performed by the array object interface, and may introduce inconsistencies between the array information maintained internally and the actual array data. </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#gabbcd8712863836e78e6960722ae1ab96">cpl_table_where_selected()</a>.</p>

</div>
</div>
<a id="gac3d80e50313eed1d8cbfd4d260cb1b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3d80e50313eed1d8cbfd4d260cb1b0e">&#9670;&nbsp;</a></span>cpl_array_get_data_cplsize_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>* cpl_array_get_data_cplsize_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <code>cpl_size</code> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Constant array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant <code>cpl_size</code> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_SIZE</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga65acfed522e9a1aa7e3a0ecae0ed0a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65acfed522e9a1aa7e3a0ecae0ed0a81">&#9670;&nbsp;</a></span>cpl_array_get_data_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* cpl_array_get_data_double </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <code>double</code> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <code>double</code> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_DOUBLE</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<p>See documentation of function <a class="el" href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f" title="Get a pointer to integer array data.">cpl_array_get_data_int()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__wcs.html#ga3e6e2597917be71afeb5de2d957a659a">cpl_wcs_convert()</a>.</p>

</div>
</div>
<a id="ga3b284ffb554d127566b89f369a7a631a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b284ffb554d127566b89f369a7a631a">&#9670;&nbsp;</a></span>cpl_array_get_data_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double complex* cpl_array_get_data_double_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <code>double</code> complex array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <code>double</code> complex array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<p>See documentation of function <a class="el" href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f" title="Get a pointer to integer array data.">cpl_array_get_data_int()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gabfd3e8cba2adf3fd507dd8ddb1d9e75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfd3e8cba2adf3fd507dd8ddb1d9e75b">&#9670;&nbsp;</a></span>cpl_array_get_data_double_complex_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double complex* cpl_array_get_data_double_complex_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <em>double</em> complex array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Constant array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant <em>double</em> complex array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<p>See documentation of function <a class="el" href="group__cpl__array.html#ga7e4d679ec9d58e631b69eae7990ab19f" title="Get a pointer to constant integer array data.">cpl_array_get_data_int_const()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gacf4a7775ab84a3d776f0be5e19ac5576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf4a7775ab84a3d776f0be5e19ac5576">&#9670;&nbsp;</a></span>cpl_array_get_data_double_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* cpl_array_get_data_double_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <em>double</em> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Constant array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant <em>double</em> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_DOUBLE</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<p>See documentation of function <a class="el" href="group__cpl__array.html#ga7e4d679ec9d58e631b69eae7990ab19f" title="Get a pointer to constant integer array data.">cpl_array_get_data_int_const()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__wcs.html#gaef2a2ad1e5206d26175ab95f81afb58c">cpl_wcs_platesol()</a>.</p>

</div>
</div>
<a id="ga955975ecb1d288fdfa98b1a0050f6c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga955975ecb1d288fdfa98b1a0050f6c1c">&#9670;&nbsp;</a></span>cpl_array_get_data_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* cpl_array_get_data_float </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <code>float</code> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <code>float</code> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_FLOAT</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<p>See documentation of function <a class="el" href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f" title="Get a pointer to integer array data.">cpl_array_get_data_int()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga62687ba5ce9e57fde647669cfbe56e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62687ba5ce9e57fde647669cfbe56e87">&#9670;&nbsp;</a></span>cpl_array_get_data_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float complex* cpl_array_get_data_float_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <code>float</code> complex array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <code>float</code> complex array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_FLOAT_COMPLEX</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<p>See documentation of function <a class="el" href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f" title="Get a pointer to integer array data.">cpl_array_get_data_int()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga0ee80bcffeabaa8b6f3171c14d30d726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ee80bcffeabaa8b6f3171c14d30d726">&#9670;&nbsp;</a></span>cpl_array_get_data_float_complex_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float complex* cpl_array_get_data_float_complex_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <em>float</em> complex array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Constant array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant <em>float</em> complex array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_FLOAT_COMPLEX</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<p>See documentation of function <a class="el" href="group__cpl__array.html#ga7e4d679ec9d58e631b69eae7990ab19f" title="Get a pointer to constant integer array data.">cpl_array_get_data_int_const()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga6a54d6a52aedffe4638c195e04155ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a54d6a52aedffe4638c195e04155ef3">&#9670;&nbsp;</a></span>cpl_array_get_data_float_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float* cpl_array_get_data_float_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <em>float</em> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Constant array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant <em>float</em> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_FLOAT</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<p>See documentation of function <a class="el" href="group__cpl__array.html#ga7e4d679ec9d58e631b69eae7990ab19f" title="Get a pointer to constant integer array data.">cpl_array_get_data_int_const()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gaef6ce495b8cff38332106ba3242a2c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef6ce495b8cff38332106ba3242a2c9f">&#9670;&nbsp;</a></span>cpl_array_get_data_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* cpl_array_get_data_int </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <code>integer</code> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <code>integer</code> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_INT</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<dl class="section note"><dt>Note</dt><dd>Use at your own risk: direct manipulation of array data rules out any check performed by the array object interface, and may introduce inconsistencies between the array information maintained internally and the actual array data. </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__wcs.html#ga3e6e2597917be71afeb5de2d957a659a">cpl_wcs_convert()</a>.</p>

</div>
</div>
<a id="ga7e4d679ec9d58e631b69eae7990ab19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e4d679ec9d58e631b69eae7990ab19f">&#9670;&nbsp;</a></span>cpl_array_get_data_int_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int* cpl_array_get_data_int_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <code>integer</code> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Constant array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant <code>integer</code> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_INT</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga2bb021d47e58301128a299e4284bffe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bb021d47e58301128a299e4284bffe0">&#9670;&nbsp;</a></span>cpl_array_get_data_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long* cpl_array_get_data_long </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <code>long</code> <code>integer</code> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <code>long</code> <code>integer</code> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_LONG</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<dl class="section note"><dt>Note</dt><dd>Use at your own risk: direct manipulation of array data rules out any check performed by the array object interface, and may introduce inconsistencies between the array information maintained internally and the actual array data. </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gad88006e3171971a573cebd0b8822a787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad88006e3171971a573cebd0b8822a787">&#9670;&nbsp;</a></span>cpl_array_get_data_long_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const long* cpl_array_get_data_long_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <code>long</code> <code>integer</code> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Constant array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant <code>long</code> <code>integer</code> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_LONG</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gaa14294d46199c6223755c56d6f7ccec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa14294d46199c6223755c56d6f7ccec3">&#9670;&nbsp;</a></span>cpl_array_get_data_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long* cpl_array_get_data_long_long </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <code>long</code> <code>long</code> <code>integer</code> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <code>long</code> <code>long</code> <code>integer</code> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_LONG_LONG</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<dl class="section note"><dt>Note</dt><dd>Use at your own risk: direct manipulation of array data rules out any check performed by the array object interface, and may introduce inconsistencies between the array information maintained internally and the actual array data. </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga362760c465f162cc54759dc51319977d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga362760c465f162cc54759dc51319977d">&#9670;&nbsp;</a></span>cpl_array_get_data_long_long_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const long long* cpl_array_get_data_long_long_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <code>long</code> <code>long</code> <code>integer</code> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Constant array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant <code>long</code> <code>long</code> <code>integer</code> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_LONG_LONG</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga0e5d705ae246e2580532d51589f979c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e5d705ae246e2580532d51589f979c5">&#9670;&nbsp;</a></span>cpl_array_get_data_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** cpl_array_get_data_string </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <em>string</em> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <em>string</em> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_STRING</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<p>See documentation of function <a class="el" href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f" title="Get a pointer to integer array data.">cpl_array_get_data_int()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga93bda9cdd017058efd32b1b16c74c130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93bda9cdd017058efd32b1b16c74c130">&#9670;&nbsp;</a></span>cpl_array_get_data_string_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char** cpl_array_get_data_string_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <em>string</em> array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Constant array to get the data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant <em>string</em> array data. If <em>array</em> contains no data (zero length), a <code>NULL</code> is returned. If <em>array</em> is a <code>NULL</code>, a <code>NULL</code> is returned, and an error is set.</dd></dl>
<p>If the array is not of type <code>CPL_TYPE_STRING</code>, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set.</p>
<p>See documentation of function <a class="el" href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f" title="Get a pointer to integer array data.">cpl_array_get_data_int()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga8546b4a102b65be32f7a2dd729b2c6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8546b4a102b65be32f7a2dd729b2c6a8">&#9670;&nbsp;</a></span>cpl_array_get_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_array_get_double </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>double</em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating null values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array value read. In case of an invalid array element, or in case of error, 0.0 is returned.</dd></dl>
<p>Read a value from an array of type <code>CPL_TYPE_DOUBLE</code>. See the documentation of the function <a class="el" href="group__cpl__array.html#ga884166ba564f1408eb22c3343c250e5e" title="Read a value from an integer array.">cpl_array_get_int()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__fit.html#ga8004d897c449d503c56f14ca99cf475b">cpl_fit_image_gaussian()</a>, and <a class="el" href="group__cpl__fit.html#ga64cafc2831f6064c34d126ef17397087">cpl_gaussian_eval_2d()</a>.</p>

</div>
</div>
<a id="ga59f2936cbd4d132bc5a4079a0a7452f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59f2936cbd4d132bc5a4079a0a7452f4">&#9670;&nbsp;</a></span>cpl_array_get_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double complex cpl_array_get_double_complex </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>double</em> complex array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating null values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array value read. In case of an invalid array element, or in case of error, 0.0 is returned.</dd></dl>
<p>Read a value from an array of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>. See the documentation of the function <a class="el" href="group__cpl__array.html#ga884166ba564f1408eb22c3343c250e5e" title="Read a value from an integer array.">cpl_array_get_int()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="ga1b787dac49b4e871facf32cbfc9ef2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b787dac49b4e871facf32cbfc9ef2ac">&#9670;&nbsp;</a></span>cpl_array_get_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cpl_array_get_float </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>float</em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating null values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array value read. In case of an invalid array element, or in case of error, 0.0 is returned.</dd></dl>
<p>Read a value from an array of type <code>CPL_TYPE_FLOAT</code>. See the documentation of the function <a class="el" href="group__cpl__array.html#ga884166ba564f1408eb22c3343c250e5e" title="Read a value from an integer array.">cpl_array_get_int()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="gae0f08d3d7a28457b75c286db7e175661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0f08d3d7a28457b75c286db7e175661">&#9670;&nbsp;</a></span>cpl_array_get_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float complex cpl_array_get_float_complex </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>float</em> complex array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating null values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array value read. In case of an invalid array element, or in case of error, 0.0 is returned.</dd></dl>
<p>Read a value from an array of type <code>CPL_TYPE_FLOAT_COMPLEX</code>. See the documentation of the function <a class="el" href="group__cpl__array.html#ga884166ba564f1408eb22c3343c250e5e" title="Read a value from an integer array.">cpl_array_get_int()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="ga884166ba564f1408eb22c3343c250e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga884166ba564f1408eb22c3343c250e5e">&#9670;&nbsp;</a></span>cpl_array_get_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpl_array_get_int </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from an <em>integer</em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating null values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value read. In case of an invalid array element, or in case of error, 0 is returned.</dd></dl>
<p>Read a value from an array of type <code>CPL_TYPE_INT</code>. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is set. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is set. Indexes are counted starting from 0. If the input array has length zero, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always set. If the <em>null</em> flag is a valid pointer, it is used to indicate whether the accessed array element is valid (0) or invalid (1). The null flag also signals an error condition (-1). </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__fit.html#ga8004d897c449d503c56f14ca99cf475b">cpl_fit_image_gaussian()</a>.</p>

</div>
</div>
<a id="gaa46641dd92c5310500201a0c3cd324da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa46641dd92c5310500201a0c3cd324da">&#9670;&nbsp;</a></span>cpl_array_get_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long cpl_array_get_long </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>long</em> <em>integer</em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating null values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Long integer value read. In case of an invalid array element, or in case of error, 0 is returned.</dd></dl>
<p>Read a value from an array of type <code>CPL_TYPE_LONG</code>. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is set. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is set. Indexes are counted starting from 0. If the input array has length zero, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always set. If the <em>null</em> flag is a valid pointer, it is used to indicate whether the accessed array element is valid (0) or invalid (1). The null flag also signals an error condition (-1). </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="gaa885f4eb60de528e5729187a3bd46931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa885f4eb60de528e5729187a3bd46931">&#9670;&nbsp;</a></span>cpl_array_get_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long cpl_array_get_long_long </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>long</em> <em>long</em> <em>integer</em> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating null values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Long long integer value read. In case of an invalid array element, or in case of error, 0 is returned.</dd></dl>
<p>Read a value from an array of type <code>CPL_TYPE_LONG_LONG</code>. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is set. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is set. Indexes are counted starting from 0. If the input array has length zero, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always set. If the <em>null</em> flag is a valid pointer, it is used to indicate whether the accessed array element is valid (0) or invalid (1). The null flag also signals an error condition (-1). </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="gade748bc7779401890bdafd535a0bd725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade748bc7779401890bdafd535a0bd725">&#9670;&nbsp;</a></span>cpl_array_get_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_array_get_max </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get maximum value in a numerical array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Input array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum value. In case of error, this is set to 0.0.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not numerical.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">The specified <em>array</em> has either size zero, or all its elements are invalid.   </td></tr>
</table>
</dd>
</dl>
<p>Array elements marked as invalid are excluded from the search. The array must contain at least one valid value. Arrays of strings or complex are not allowed. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="ga2ee812e57ebbd25fbdc6fbb048f70ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ee812e57ebbd25fbdc6fbb048f70ddc">&#9670;&nbsp;</a></span>cpl_array_get_maxpos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_get_maxpos </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get position of maximum in a numerical array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array. </td></tr>
    <tr><td class="paramname">indx</td><td>Returned position of maximum value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> or <em>indx</em> is <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not numerical.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">The specified <em>array</em> has either size zero, or all its elements are invalid.   </td></tr>
</table>
</dd>
</dl>
<p>Array values marked as invalid are excluded from the search. The <em>indx</em> argument will be assigned the position of the maximum value. Indexes are counted starting from 0. If more than one array element correspond to the max value, the position with the lowest indx is returned. In case of error, <em>indx</em> is set to zero. Arrays of strings or complex are not allowed. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gab31e5e9631e4b9d1d945c3e6c55ab626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab31e5e9631e4b9d1d945c3e6c55ab626">&#9670;&nbsp;</a></span>cpl_array_get_mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_array_get_mean </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean value of a numeric array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Input array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mean value. In case of error, this is set to 0.0.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not numerical.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">The specified <em>array</em> has either size zero, or all its elements are invalid.   </td></tr>
</table>
</dd>
</dl>
<p>Array elements marked as invalid are excluded from the computation. The array must contain at least one valid value. Arrays of strings or complex are not allowed. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="gaa21e07016678174db5c804486293cdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa21e07016678174db5c804486293cdc0">&#9670;&nbsp;</a></span>cpl_array_get_mean_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double complex cpl_array_get_mean_complex </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean value of a complex array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Input array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mean value. In case of error, this is set to 0.0.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not complex.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">The specified <em>array</em> has either size zero, or all its elements are invalid.   </td></tr>
</table>
</dd>
</dl>
<p>Array elements marked as invalid are excluded from the computation. The array must contain at least one valid value. Arrays of strings or numerical are not allowed. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="ga9a8ffc287daa729d7b04e4945cfa9a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a8ffc287daa729d7b04e4945cfa9a5f">&#9670;&nbsp;</a></span>cpl_array_get_median()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_array_get_median </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the median of a numeric array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Input array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Median. In case of error, this is set to 0.0.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not numerical.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">The specified <em>array</em> has either size zero, or all its elements are invalid.   </td></tr>
</table>
</dd>
</dl>
<p>Array elements marked as invalid are excluded from the computation. The array must contain at least one valid value. Arrays of strings or complex are not allowed. </p>

<p class="reference">References <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>.</p>

</div>
</div>
<a id="ga54fa45fb65475bcbdea9ffee181f3565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54fa45fb65475bcbdea9ffee181f3565">&#9670;&nbsp;</a></span>cpl_array_get_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_array_get_min </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get minimum value in a numerical array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Input array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum value. In case of error, this is set to 0.0.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not numerical.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">The specified <em>array</em> has either size zero, or all its elements are invalid.   </td></tr>
</table>
</dd>
</dl>
<p>Array elements marked as invalid are excluded from the search. The array must contain at least one valid value. Arrays of strings or complex are not allowed. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="ga2744fb182287b915fbc9747d57b11c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2744fb182287b915fbc9747d57b11c75">&#9670;&nbsp;</a></span>cpl_array_get_minpos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_get_minpos </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get position of minimum in a numerical array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array. </td></tr>
    <tr><td class="paramname">indx</td><td>Returned position of minimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> or <em>indx</em> is <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not numerical.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">The specified <em>array</em> has either size zero, or all its elements are invalid.   </td></tr>
</table>
</dd>
</dl>
<p>Array values marked as invalid are excluded from the search. The <em>indx</em> argument will be assigned the position of the minimum value. Indexes are counted starting from 0. If more than one array element correspond to the min value, the position with the lowest indx is returned. In case of error, <em>indx</em> is set to zero. Arrays of strings or complex are not allowed. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga8e801eed015223aa6ebdf157896cc164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e801eed015223aa6ebdf157896cc164">&#9670;&nbsp;</a></span>cpl_array_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_array_get_size </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Input array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of array, or zero. The latter case can occur either with an array having zero length, or if a <code>NULL</code> array is passed to the function, but in the latter case a <code>CPL_ERROR_NULL_INPUT</code> is set.</dd></dl>
<p>If the array is <em>NULL</em>, zero is returned. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__array.html#ga4d2bbefc13a4c4d7d03a3413202653db">cpl_array_duplicate()</a>, <a class="el" href="group__cpl__array.html#ga0d697433645b215307214fd890985089">cpl_array_erase_window()</a>, <a class="el" href="group__cpl__array.html#gad4e311edd18e037607ecb2122c42d418">cpl_array_extract()</a>, and <a class="el" href="group__cpl__fit.html#ga64cafc2831f6064c34d126ef17397087">cpl_gaussian_eval_2d()</a>.</p>

</div>
</div>
<a id="gaf59b99b6053ebd06c052ca5c2f619a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf59b99b6053ebd06c052ca5c2f619a08">&#9670;&nbsp;</a></span>cpl_array_get_stdev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_array_get_stdev </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the standard deviation of a numeric array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Input array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard deviation. In case of error, this is set to 0.0.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not numerical.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">The specified <em>array</em> has either size zero, or all its elements are invalid.   </td></tr>
</table>
</dd>
</dl>
<p>Array elements marked as invalid are excluded from the computation. The array must contain at least one valid value. Arrays of strings or complex are not allowed. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="ga93e096fb44e739a98a76159e762af10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93e096fb44e739a98a76159e762af10d">&#9670;&nbsp;</a></span>cpl_array_get_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cpl_array_get_string </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a string array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position of element to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Character string read. In case of an invalid array element, or in case of error, a <code>NULL</code> pointer is returned.</dd></dl>
<p>Read a value from an array of type <code>CPL_TYPE_STRING</code>. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is set. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is set. Indexes are counted starting from 0. If the input array has length zero, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always set.</p>
<dl class="section note"><dt>Note</dt><dd>The returned string is a pointer to an array element, not its copy. Its manipulation will directly affect that array element, while changing that array element using <code><a class="el" href="group__cpl__array.html#gafdcddf97688e725811a4c8e7b7abfc01" title="Write a character string to a string array element.">cpl_array_set_string()</a></code> will turn it into garbage. Therefore, if a real copy of a string array element is required, this function should be called as an argument of the function <code>strdup()</code>. </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#gad3d6e80aaaa6c23a6ea33e5b4a3446a3">cpl_table_compare_structure()</a>.</p>

</div>
</div>
<a id="ga011b1c53a1081956c531eb65116b3e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga011b1c53a1081956c531eb65116b3e35">&#9670;&nbsp;</a></span>cpl_array_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a> cpl_array_get_type </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Input array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type of array, or <code>CPL_TYPE_INVALID</code> if a <code>NULL</code> array is passed to the function.</dd></dl>
<p>If the array is <code>NULL</code>, <code>CPL_ERROR_NULL_INPUT</code> is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__error.html#gad7cf962bbe59df1b5991b17b1a2361a3">cpl_error_set</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a557ce1b89a9acd48254c302ec1eed956">CPL_TYPE_INVALID</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__array.html#ga312e71fd365e79ef0359a2fa5fecdb77">cpl_array_abs()</a>, <a class="el" href="group__cpl__array.html#ga0c93e4c252bc6392e0e3a2046f8425d6">cpl_array_arg()</a>, <a class="el" href="group__cpl__array.html#ga4d2bbefc13a4c4d7d03a3413202653db">cpl_array_duplicate()</a>, <a class="el" href="group__cpl__array.html#gad4e311edd18e037607ecb2122c42d418">cpl_array_extract()</a>, <a class="el" href="group__cpl__array.html#gaefa4c3310c7c836abc695d797705aa62">cpl_array_extract_imag()</a>, <a class="el" href="group__cpl__array.html#gaa8fd08e7b11baf6a3f44ec0c1060c1ef">cpl_array_extract_real()</a>, and <a class="el" href="group__cpl__fit.html#ga8004d897c449d503c56f14ca99cf475b">cpl_fit_image_gaussian()</a>.</p>

</div>
</div>
<a id="gaedc4a7c53d3a81c79d7efc473e645d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedc4a7c53d3a81c79d7efc473e645d6b">&#9670;&nbsp;</a></span>cpl_array_has_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpl_array_has_invalid </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an array contains at least one invalid element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to inquire.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the array contains at least one invalid element, 0 if not, -1 in case of error.</dd></dl>
<p>Check if there are invalid elements in an array. If the input array is a <code>NULL</code> pointer, a <code>CPL_ERROR_NULL_INPUT</code> is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga2ce90cb02dfff8e66e6b0b1bc5481988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ce90cb02dfff8e66e6b0b1bc5481988">&#9670;&nbsp;</a></span>cpl_array_has_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpl_array_has_valid </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an array contains at least one valid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to inquire.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the array contains at least one valid value, 0 if not -1 in case of error.</dd></dl>
<p>Check if there are valid values in an array. If the input array is a <code>NULL</code> pointer, a <code>CPL_ERROR_NULL_INPUT</code> is set. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga485d2592300376ef0262fafcd4377f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga485d2592300376ef0262fafcd4377f96">&#9670;&nbsp;</a></span>cpl_array_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_insert </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>target_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>insert_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge two arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_array</td><td>Target array. </td></tr>
    <tr><td class="paramname">insert_array</td><td>Array to be inserted in the target array. </td></tr>
    <tr><td class="paramname">start</td><td>Element where to insert the insert array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any input array is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr"><em>start</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The input arrays do not have the same type.   </td></tr>
</table>
</dd>
</dl>
<p>The input arrays must have the same type. Data from the <em>insert_array</em> are duplicated and inserted at the specified position of the <em>target_array</em>. If the specified <em>start</em> is not less than the target array length, the second array will be appended to the target array. The pointers to array data in the target array may change, therefore pointers previously retrieved by calling <code><a class="el" href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f" title="Get a pointer to integer array data.">cpl_array_get_data_int()</a></code>, <code><a class="el" href="group__cpl__array.html#ga0e5d705ae246e2580532d51589f979c5" title="Get a pointer to string array data.">cpl_array_get_data_string()</a></code>, etc., should be discarded. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga49123832ee037a186c21936ba5325bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49123832ee037a186c21936ba5325bf0">&#9670;&nbsp;</a></span>cpl_array_insert_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_insert_window </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a segment of new elements into array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Input array </td></tr>
    <tr><td class="paramname">start</td><td>Element where to insert the segment. </td></tr>
    <tr><td class="paramname">count</td><td>Length of the segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr"><em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr"><em>start</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
</table>
</dd>
</dl>
<p>Insert a segment of empty (invalid) elements. Setting <em>start</em> to a number greater than the array length is legal, and has the effect of appending extra elements at the end of the array: this is equivalent to expanding the array using <code><a class="el" href="group__cpl__array.html#ga4515ab30836eb6793514ed0b37dbb2ba" title="Resize an array.">cpl_array_set_size()</a></code>. The input <em>array</em> may also have zero length. The pointers to array data values may change, therefore pointers previously retrieved by calling <code><a class="el" href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f" title="Get a pointer to integer array data.">cpl_array_get_data_int()</a></code>, <code><a class="el" href="group__cpl__array.html#ga0e5d705ae246e2580532d51589f979c5" title="Get a pointer to string array data.">cpl_array_get_data_string()</a></code>, etc., should be discarded. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga8cb5ae549a41473e838c5158b7bf7cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cb5ae549a41473e838c5158b7bf7cec">&#9670;&nbsp;</a></span>cpl_array_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpl_array_is_valid </td>
          <td>(</td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an array element is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array. </td></tr>
    <tr><td class="paramname">indx</td><td>Array element to examine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the array element is valid, 0 if invalid, -1 in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>array</em> has zero length, or <em>indx</em> is outside the array boundaries.   </td></tr>
</table>
</dd>
</dl>
<p>Check if an array element is valid. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>, and <a class="el" href="group__cpl__errorstate.html#gab4487759414dfe1a7403321b86d5b3cd">cpl_errorstate_is_equal()</a>.</p>

</div>
</div>
<a id="ga2d2e8a5596a0d6a02eec584f78c123ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d2e8a5596a0d6a02eec584f78c123ac">&#9670;&nbsp;</a></span>cpl_array_logarithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_logarithm </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the logarithm of array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to array. </td></tr>
    <tr><td class="paramname">base</td><td>Logarithm base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>array</em> is not numerical or complex.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The input <em>base</em> is not positive.   </td></tr>
</table>
</dd>
</dl>
<p>Each array element is replaced by its logarithm in the specified base. The operation is always performed in double precision, with a final cast of the result to the array type. Invalid elements are not modified by this operation, but zero or negative elements are invalidated by this operation. In case of complex numbers, values very close to the origin may cause an overflow. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga1d15805f1fe6e64371c1424309c94352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d15805f1fe6e64371c1424309c94352">&#9670;&nbsp;</a></span>cpl_array_multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_multiply </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>to_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>from_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply the values of two numeric or complex arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_array</td><td>Target array. </td></tr>
    <tr><td class="paramname">from_array</td><td>Source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INCOMPATIBLE_INPUT </td><td class="ecr">The input arrays have different sizes.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">Any specified array is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>The arrays are multiplied element by element, and the result is stored in the target array. See the documentation of the function <code><a class="el" href="group__cpl__array.html#ga34e0451f31e2bb26c18981b50c32611b" title="Add the values of two numeric or complex arrays.">cpl_array_add()</a></code> for further details. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gab35b721f5a41d90343587d50c566622a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab35b721f5a41d90343587d50c566622a">&#9670;&nbsp;</a></span>cpl_array_multiply_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_multiply_scalar </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a numerical array by a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Target array </td></tr>
    <tr><td class="paramname">value</td><td>Factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The input array is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>The operation is always performed in double precision, with a final cast of the result to the target array type. Invalid elements are are not modified by this operation. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga99777185033e7aeb317d0c0c4be5fa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99777185033e7aeb317d0c0c4be5fa9c">&#9670;&nbsp;</a></span>cpl_array_multiply_scalar_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_multiply_scalar_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a complex array by a constant complex value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Target array </td></tr>
    <tr><td class="paramname">value</td><td>Factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The input array is not complex.   </td></tr>
</table>
</dd>
</dl>
<p>The operation is always performed in double precision, with a final cast of the result to the target array type. Invalid elements are are not modified by this operation. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gaf7d187111491f2d3a8b50fff01fbad17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7d187111491f2d3a8b50fff01fbad17">&#9670;&nbsp;</a></span>cpl_array_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new array of given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Number of elements in array. </td></tr>
    <tr><td class="paramname">type</td><td>Type of array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new array, or <code>NULL</code> in case of error.</dd></dl>
<p>This function allocates memory for an array, its type is assigned, and its number of elements is allocated. Only arrays of types <code>CPL_TYPE_INT</code>, <code>CPL_TYPE_FLOAT</code>, <code>CPL_TYPE_DOUBLE</code>, <code>CPL_TYPE_FLOAT_COMPLEX</code>, <code>CPL_TYPE_DOUBLE_COMPLEX</code> and <code>CPL_TYPE_STRING</code>, are supported. An error <code>CPL_ERROR_INVALID_TYPE</code> is set in case other types are specified. All array elements are initially flagged as invalid. If a negative length is specified, an error <code>CPL_ERROR_ILLEGAL_INPUT</code> is set. Zero length arrays are allowed. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7907a24014a3a45aebe5ee1842f0c6f3">CPL_ERROR_INVALID_TYPE</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a4923f03f3a673edd344b0d81835ca69e">CPL_TYPE_DOUBLE</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086afc7205e8b040bdfdee6011685cfe4345">CPL_TYPE_DOUBLE_COMPLEX</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086aa44c37e26b9040a96e3a49b405946942">CPL_TYPE_FLOAT</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086ab2ab0f96a382011a38ee9446626fe1e0">CPL_TYPE_FLOAT_COMPLEX</a>, <a class="el" href="group__cpl__type.html#ga994816f2d7624221964f91e0b9556578">cpl_type_get_name()</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086ae333db5ccea0813ccd892525b4ba1345">CPL_TYPE_INT</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a53e9a61e6c21933902298f9a9d1b2faf">CPL_TYPE_LONG</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086acea0fe783323e91b754bf20915d7038b">CPL_TYPE_LONG_LONG</a>, <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a46fa44e4ea49bfa00a5c11f1a52228a6">CPL_TYPE_SIZE</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8c58196493fdac6c0424560417cd6bf8">CPL_TYPE_STRING</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__array.html#ga4d2bbefc13a4c4d7d03a3413202653db">cpl_array_duplicate()</a>, <a class="el" href="group__cpl__array.html#gad4e311edd18e037607ecb2122c42d418">cpl_array_extract()</a>, <a class="el" href="group__cpl__array.html#gaefa4c3310c7c836abc695d797705aa62">cpl_array_extract_imag()</a>, <a class="el" href="group__cpl__array.html#gaa8fd08e7b11baf6a3f44ec0c1060c1ef">cpl_array_extract_real()</a>, <a class="el" href="group__cpl__fit.html#ga8004d897c449d503c56f14ca99cf475b">cpl_fit_image_gaussian()</a>, <a class="el" href="group__cpl__table.html#gaef76a593a5bfbefdc37553c025537fe8">cpl_table_get_column_names()</a>, <a class="el" href="group__cpl__table.html#gabbcd8712863836e78e6960722ae1ab96">cpl_table_where_selected()</a>, and <a class="el" href="group__cpl__wcs.html#ga3e6e2597917be71afeb5de2d957a659a">cpl_wcs_convert()</a>.</p>

</div>
</div>
<a id="ga925ed048a796cbbf9227ea559d444aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga925ed048a796cbbf9227ea559d444aac">&#9670;&nbsp;</a></span>cpl_array_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_power </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the power of numerical array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to numerical array. </td></tr>
    <tr><td class="paramname">exponent</td><td>Constant exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>pow(), cpow()</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is <code>NULL</code>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The <em>array</em> is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>Each array element is replaced by its power to the specified exponent. Each column element is replaced by its power to the specified exponent. For float and float complex the operation is performed in single precision, otherwise it is performed in double precision and then rounded if the column is of an integer type. Results that would or do cause domain errors or overflow are marked as invalid. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga9a49d38713759c91a6b6da7c0f9671f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a49d38713759c91a6b6da7c0f9671f8">&#9670;&nbsp;</a></span>cpl_array_power_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_power_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the complex power of complex, numerical array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to numerical array. </td></tr>
    <tr><td class="paramname">exponent</td><td>Constant exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__array.html#ga925ed048a796cbbf9227ea559d444aac" title="Compute the power of numerical array elements.">cpl_array_power()</a></dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is <code>NULL</code>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The <em>array</em> is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>Each array element is replaced by its power to the specified exponent. Each column element is replaced by its power to the specified exponent. For float and float complex the operation is performed in single precision, otherwise it is performed in double precision and then rounded if the column is of an integer type. Results that would or do cause domain errors or overflow are marked as invalid. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga39a4ec7768577c9dc688fbbd2eb9d902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39a4ec7768577c9dc688fbbd2eb9d902">&#9670;&nbsp;</a></span>cpl_array_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_set </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a numerical array element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of numerical type, a <code>CPL_ERROR_INVALID_TYPE</code> is returned. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned.</dd></dl>
<p>Write a value to a numerical array element. The value is cast to the accessed array type. The written value is automatically flagged as valid. To invalidate an array value use <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. Array elements are counted starting from 0. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga35533db8e2f12890899b4d1b81a9971a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35533db8e2f12890899b4d1b81a9971a">&#9670;&nbsp;</a></span>cpl_array_set_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_set_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a complex array element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of numerical type, a <code>CPL_ERROR_INVALID_TYPE</code> is returned. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length zero, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned.</dd></dl>
<p>Write a value to a numerical array element. The value is cast to the accessed array type. The written value is automatically flagged as valid. To invalidate an array value use <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. Array elements are counted starting from 0. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gac80deea31ca4980a98437e0c2e854297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac80deea31ca4980a98437e0c2e854297">&#9670;&nbsp;</a></span>cpl_array_set_cplsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_set_cplsize </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>cpl_size</em> array element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length 0, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned.</dd></dl>
<p>Write a value to a <em>cpl_size</em> array element. The written value is automatically flagged as valid. To invalidate an array value use <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. Array elements are counted starting from 0. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga87673fd4db91c71d3c97e4b70c58d527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87673fd4db91c71d3c97e4b70c58d527">&#9670;&nbsp;</a></span>cpl_array_set_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_set_double </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>double</em> array element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length 0, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned.</dd></dl>
<p>Write a value to a <em>double</em> array element. The written value is automatically flagged as valid. To invalidate an array value use <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. Array elements are counted starting from 0. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__fit.html#ga8004d897c449d503c56f14ca99cf475b">cpl_fit_image_gaussian()</a>.</p>

</div>
</div>
<a id="ga8a0e22a2666e451ed4ad9c9aa8e284be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a0e22a2666e451ed4ad9c9aa8e284be">&#9670;&nbsp;</a></span>cpl_array_set_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_set_double_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>double</em> complex array element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length 0, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned.</dd></dl>
<p>Write a value to a <em>double</em> array element. The written value is automatically flagged as valid. To invalidate an array value use <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. Array elements are counted starting from 0. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gad8fd0fc8aa341ee85a6ac4a88a71fabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8fd0fc8aa341ee85a6ac4a88a71fabd">&#9670;&nbsp;</a></span>cpl_array_set_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_set_float </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>float</em> array element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length 0, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned.</dd></dl>
<p>Write a value to a <em>float</em> array element. The written value is automatically flagged as valid. To invalidate an array value use <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. Array elements are counted starting from 0. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga0e60726014688cebcc9f73ebe5e3162e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e60726014688cebcc9f73ebe5e3162e">&#9670;&nbsp;</a></span>cpl_array_set_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_set_float_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>float</em> complex array element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length 0, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned.</dd></dl>
<p>Write a value to a <em>float</em> complex array element. The written value is automatically flagged as valid. To invalidate an array value use <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. Array elements are counted starting from 0. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga53699ec9f0933202dc67c46211f5f4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53699ec9f0933202dc67c46211f5f4c6">&#9670;&nbsp;</a></span>cpl_array_set_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_set_int </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to an <em>integer</em> array element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length 0, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned.</dd></dl>
<p>Write a value to an <em>integer</em> array element. The written value is automatically flagged as valid. To invalidate an array value use <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. Array elements are counted starting from 0. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gaf177c5261df07eeecdbdd5b9fb0638eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf177c5261df07eeecdbdd5b9fb0638eb">&#9670;&nbsp;</a></span>cpl_array_set_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_set_invalid </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate an array element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed </td></tr>
    <tr><td class="paramname">indx</td><td>Position of element to invalidate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is set. If the input array has length 0, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always set.</dd></dl>
<p>In the case of a string array, the string is set free and its pointer is set to <code>NULL</code>; for other data types, the corresponding element of the null flags buffer is flagged. Array elements are counted starting from zero. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__fit.html#ga8004d897c449d503c56f14ca99cf475b">cpl_fit_image_gaussian()</a>.</p>

</div>
</div>
<a id="gafdd532736900c8973bdf5bbb960f9158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdd532736900c8973bdf5bbb960f9158">&#9670;&nbsp;</a></span>cpl_array_set_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_set_long </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>long</em> <em>integer</em> array element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length 0, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned.</dd></dl>
<p>Write a value to a <em>long</em> <em>integer</em> array element. The written value is automatically flagged as valid. To invalidate an array value use <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. Array elements are counted starting from 0. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga039525d1b2bb566dcf9f653f94f06154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga039525d1b2bb566dcf9f653f94f06154">&#9670;&nbsp;</a></span>cpl_array_set_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_set_long_long </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>long</em> <em>long</em> <em>integer</em> array element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is set. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length 0, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned.</dd></dl>
<p>Write a value to a <em>long</em> <em>long</em> <em>integer</em> array element. The written value is automatically flagged as valid. To invalidate an array value use <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. Array elements are counted starting from 0. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga4515ab30836eb6793514ed0b37dbb2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4515ab30836eb6793514ed0b37dbb2ba">&#9670;&nbsp;</a></span>cpl_array_set_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_set_size </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>new_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Input array. </td></tr>
    <tr><td class="paramname">new_length</td><td>New number of elements in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. The new array size must not be negative, or a <code>CPL_ERROR_ILLEGAL_INPUT</code> is returned. The input array pointer should not be <code>NULL</code>, or a <code>CPL_ERROR_NULL_INPUT</code> is returned.</dd></dl>
<p>Reallocate an array to a new number of elements. The contents of the array data buffer will be unchanged up to the lesser of the new and old sizes. If the array size is increased, the new array elements are flagged as invalid. The pointer to data may change, therefore pointers previously retrieved by calling <code><a class="el" href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f" title="Get a pointer to integer array data.">cpl_array_get_data_int()</a></code>, <code><a class="el" href="group__cpl__array.html#ga0e5d705ae246e2580532d51589f979c5" title="Get a pointer to string array data.">cpl_array_get_data_string()</a></code>, etc. should be discarded). Resizing to zero is allowed, and would produce a zero-length array. In case of failure, the old data buffer is left intact.</p>
<p>If the array is <em>NULL</em>, zero is returned. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gafdcddf97688e725811a4c8e7b7abfc01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdcddf97688e725811a4c8e7b7abfc01">&#9670;&nbsp;</a></span>cpl_array_set_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_set_string </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a character string to a string array element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be accessed. </td></tr>
    <tr><td class="paramname">indx</td><td>Position where to write character string. </td></tr>
    <tr><td class="paramname">string</td><td>Character string to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. If <em>array</em> is a <code>NULL</code> pointer a <code>CPL_ERROR_NULL_INPUT</code> is returned. If the array is not of the expected type, a <code>CPL_ERROR_TYPE_MISMATCH</code> is returned. If <em>indx</em> is outside the array range, a <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is returned. If the input array has length 0, the <code>CPL_ERROR_ACCESS_OUT_OF_RANGE</code> is always returned.</dd></dl>
<p>Copy a character string to a <em>string</em> array element. The written value can also be a <code>NULL</code> pointer. Note that the input character string is copied, therefore the original can be modified without affecting the column content. To "plug" a character string directly into an array element, use the function <code><a class="el" href="group__cpl__array.html#ga0e5d705ae246e2580532d51589f979c5" title="Get a pointer to string array data.">cpl_array_get_data_string()</a></code>. Array elements are counted starting from zero. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#gaef76a593a5bfbefdc37553c025537fe8">cpl_table_get_column_names()</a>.</p>

</div>
</div>
<a id="ga28267bc350ae578b495a67fd63e12e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28267bc350ae578b495a67fd63e12e6c">&#9670;&nbsp;</a></span>cpl_array_subtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_subtract </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>to_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>from_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract the values of two numeric or complex arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_array</td><td>Target array. </td></tr>
    <tr><td class="paramname">from_array</td><td>Source array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INCOMPATIBLE_INPUT </td><td class="ecr">The input arrays have different sizes.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">Any specified array is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>The arrays are subtracted element by element, and the result is stored in the target array. See the documentation of the function <code><a class="el" href="group__cpl__array.html#ga34e0451f31e2bb26c18981b50c32611b" title="Add the values of two numeric or complex arrays.">cpl_array_add()</a></code> for further details. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gad37320b72a4aca2911d5fac11002fd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad37320b72a4aca2911d5fac11002fd71">&#9670;&nbsp;</a></span>cpl_array_subtract_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_subtract_scalar </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract a constant value from a numerical array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Target array </td></tr>
    <tr><td class="paramname">value</td><td>Value to subtract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The input array is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>The operation is always performed in double precision, with a final cast of the result to the target array type. Invalid elements are are not modified by this operation. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gab0675ff2c7e86d847869e56636e3016a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0675ff2c7e86d847869e56636e3016a">&#9670;&nbsp;</a></span>cpl_array_subtract_scalar_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_array_subtract_scalar_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract a constant complex value from a complex array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Target array </td></tr>
    <tr><td class="paramname">value</td><td>Value to subtract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>array</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The input array is not complex.   </td></tr>
</table>
</dd>
</dl>
<p>The operation is always performed in double precision, with a final cast of the result to the target array type. Invalid elements are are not modified by this operation. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga72d1dd093082f040d23a745d49c20a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72d1dd093082f040d23a745d49c20a17">&#9670;&nbsp;</a></span>cpl_array_unwrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cpl_array_unwrap </td>
          <td>(</td>
          <td class="paramtype">cpl_array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an array, without losing the data buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal data buffer.</dd></dl>
<p>This function deletes an array, but its data buffer is not destroyed. Supposedly, the developer knows that the data are static, or the developer holds the pointer to the data obtained with the functions <code><a class="el" href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f" title="Get a pointer to integer array data.">cpl_array_get_data_int()</a></code>, <code><a class="el" href="group__cpl__array.html#ga955975ecb1d288fdfa98b1a0050f6c1c" title="Get a pointer to float array data.">cpl_array_get_data_float()</a></code>, etc. If the input array is <code>NULL</code>, nothing is done, and no error is set. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__wcs.html#gad3c5f9a87cfe66226c1690953539f46b">cpl_wcs_delete()</a>.</p>

</div>
</div>
<a id="gabb37d9c4565e61ab7bca94316156373e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb37d9c4565e61ab7bca94316156373e">&#9670;&nbsp;</a></span>cpl_array_wrap_cplsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_wrap_cplsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>cpl_size</em> array from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Existing data buffer. </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new array, or <code>NULL</code> in case of error.</dd></dl>
<p>This function creates a new <em>cpl_size</em> array that will encapsulate the given data. Note that the size of the data buffer is not checked in any way, and that the data values are all considered valid: invalid values should be marked using the functions <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code>. The data array is not copied, so it should never be deallocated: to deallocate it, the function <code><a class="el" href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074" title="Delete an array.">cpl_array_delete()</a></code> should be called instead. Alternatively, the function <code><a class="el" href="group__cpl__array.html#ga72d1dd093082f040d23a745d49c20a17" title="Delete an array, without losing the data buffer.">cpl_array_unwrap()</a></code> might be used, and the data array deallocated afterwards. A zero or negative length is illegal, and would cause an error <code>CPL_ERROR_ILLEGAL_INPUT</code> to be set. An input <code>NULL</code> pointer would set an error <code>CPL_ERROR_NULL_INPUT</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Functions that handle arrays assume that an array data buffer is dynamically allocated: with a statically allocated data buffer any function implying memory handling (<code><a class="el" href="group__cpl__array.html#ga4515ab30836eb6793514ed0b37dbb2ba" title="Resize an array.">cpl_array_set_size()</a></code>, <code><a class="el" href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074" title="Delete an array.">cpl_array_delete()</a></code>, etc.) would crash the program. This means that a static data buffer should never be passed to this function if memory handling is planned. In case of a static data buffer, only the <code><a class="el" href="group__cpl__array.html#ga72d1dd093082f040d23a745d49c20a17" title="Delete an array, without losing the data buffer.">cpl_array_unwrap()</a></code> destructor can be used. </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>.</p>

</div>
</div>
<a id="ga0efd9f5da20935d8a98859c31d71f935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0efd9f5da20935d8a98859c31d71f935">&#9670;&nbsp;</a></span>cpl_array_wrap_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_wrap_double </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>double</em> array from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Existing data buffer. </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new array, or <code>NULL</code> in case of error.</dd></dl>
<p>See documentation of function <code><a class="el" href="group__cpl__array.html#gabc7eaabc5ae95aaa957353af9d1eed48" title="Create a new integer array from existing data.">cpl_array_wrap_int()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>.</p>

</div>
</div>
<a id="gaa547ddac50c2483d2e8a0e7925aa8adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa547ddac50c2483d2e8a0e7925aa8adf">&#9670;&nbsp;</a></span>cpl_array_wrap_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_wrap_double_complex </td>
          <td>(</td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>double</em> complex array from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Existing data buffer. </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new array, or <code>NULL</code> in case of error.</dd></dl>
<p>See documentation of function <code><a class="el" href="group__cpl__array.html#gabc7eaabc5ae95aaa957353af9d1eed48" title="Create a new integer array from existing data.">cpl_array_wrap_int()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>.</p>

</div>
</div>
<a id="ga152869e1ce45155939477ec414a63fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga152869e1ce45155939477ec414a63fe2">&#9670;&nbsp;</a></span>cpl_array_wrap_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_wrap_float </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>float</em> array from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Existing data buffer. </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new array, or <code>NULL</code> in case of error.</dd></dl>
<p>See documentation of function <code><a class="el" href="group__cpl__array.html#gabc7eaabc5ae95aaa957353af9d1eed48" title="Create a new integer array from existing data.">cpl_array_wrap_int()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>.</p>

</div>
</div>
<a id="gaff22a9a5c3a8716dc4aa15126b5905e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff22a9a5c3a8716dc4aa15126b5905e8">&#9670;&nbsp;</a></span>cpl_array_wrap_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_wrap_float_complex </td>
          <td>(</td>
          <td class="paramtype">float complex *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>float</em> complex array from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Existing data buffer. </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new array, or <code>NULL</code> in case of error.</dd></dl>
<p>See documentation of function <code><a class="el" href="group__cpl__array.html#gabc7eaabc5ae95aaa957353af9d1eed48" title="Create a new integer array from existing data.">cpl_array_wrap_int()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>.</p>

</div>
</div>
<a id="gabc7eaabc5ae95aaa957353af9d1eed48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc7eaabc5ae95aaa957353af9d1eed48">&#9670;&nbsp;</a></span>cpl_array_wrap_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_wrap_int </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>integer</em> array from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Existing data buffer. </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new array, or <code>NULL</code> in case of error.</dd></dl>
<p>This function creates a new <em>integer</em> array that will encapsulate the given data. Note that the size of the data buffer is not checked in any way, and that the data values are all considered valid: invalid values should be marked using the functions <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code> The data array is not copied, so it should never be deallocated: to deallocate it, the function <code><a class="el" href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074" title="Delete an array.">cpl_array_delete()</a></code> should be called instead. Alternatively, the function <code><a class="el" href="group__cpl__array.html#ga72d1dd093082f040d23a745d49c20a17" title="Delete an array, without losing the data buffer.">cpl_array_unwrap()</a></code> might be used, and the data array deallocated afterwards. A zero or negative length is illegal, and would cause an error <code>CPL_ERROR_ILLEGAL_INPUT</code> to be set. An input <code>NULL</code> pointer would set an error <code>CPL_ERROR_NULL_INPUT</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Functions that handle arrays assume that an array data buffer is dynamically allocated: with a statically allocated data buffer any function implying memory handling (<code><a class="el" href="group__cpl__array.html#ga4515ab30836eb6793514ed0b37dbb2ba" title="Resize an array.">cpl_array_set_size()</a></code>, <code><a class="el" href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074" title="Delete an array.">cpl_array_delete()</a></code>, etc.) would crash the program. This means that a static data buffer should never be passed to this function if memory handling is planned. In case of a static data buffer, only the <code><a class="el" href="group__cpl__array.html#ga72d1dd093082f040d23a745d49c20a17" title="Delete an array, without losing the data buffer.">cpl_array_unwrap()</a></code> destructor can be used. </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__matrix.html#ga7c3ad80f61da6b039f8fc24e29e1c819">cpl_matrix_get_determinant()</a>, <a class="el" href="group__cpl__matrix.html#ga60c22f619c9a3b1cc2baff49192df6ed">cpl_matrix_invert_create()</a>, <a class="el" href="group__cpl__matrix.html#ga2c7a891b363360d1aa785ce538edc3c9">cpl_matrix_solve()</a>, and <a class="el" href="group__cpl__wcs.html#gaef2a2ad1e5206d26175ab95f81afb58c">cpl_wcs_platesol()</a>.</p>

</div>
</div>
<a id="ga72210e435f31ae6c4b6f451bbc1841b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72210e435f31ae6c4b6f451bbc1841b3">&#9670;&nbsp;</a></span>cpl_array_wrap_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_wrap_long </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>long</em> <em>integer</em> array from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Existing data buffer. </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new array, or <code>NULL</code> in case of error.</dd></dl>
<p>This function creates a new <em>long</em> <em>integer</em> array that will encapsulate the given data. Note that the size of the data buffer is not checked in any way, and that the data values are all considered valid: invalid values should be marked using the functions <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code> The data array is not copied, so it should never be deallocated: to deallocate it, the function <code><a class="el" href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074" title="Delete an array.">cpl_array_delete()</a></code> should be called instead. Alternatively, the function <code><a class="el" href="group__cpl__array.html#ga72d1dd093082f040d23a745d49c20a17" title="Delete an array, without losing the data buffer.">cpl_array_unwrap()</a></code> might be used, and the data array deallocated afterwards. A zero or negative length is illegal, and would cause an error <code>CPL_ERROR_ILLEGAL_INPUT</code> to be set. An input <code>NULL</code> pointer would set an error <code>CPL_ERROR_NULL_INPUT</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Functions that handle arrays assume that an array data buffer is dynamically allocated: with a statically allocated data buffer any function implying memory handling (<code><a class="el" href="group__cpl__array.html#ga4515ab30836eb6793514ed0b37dbb2ba" title="Resize an array.">cpl_array_set_size()</a></code>, <code><a class="el" href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074" title="Delete an array.">cpl_array_delete()</a></code>, etc.) would crash the program. This means that a static data buffer should never be passed to this function if memory handling is planned. In case of a static data buffer, only the <code><a class="el" href="group__cpl__array.html#ga72d1dd093082f040d23a745d49c20a17" title="Delete an array, without losing the data buffer.">cpl_array_unwrap()</a></code> destructor can be used. </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>.</p>

</div>
</div>
<a id="ga4266345a71a328b697a33048109cbd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4266345a71a328b697a33048109cbd1c">&#9670;&nbsp;</a></span>cpl_array_wrap_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_wrap_long_long </td>
          <td>(</td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>long</em> <em>long</em> <em>integer</em> array from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Existing data buffer. </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new array, or <code>NULL</code> in case of error.</dd></dl>
<p>This function creates a new <em>long</em> <em>long</em> <em>integer</em> array that will encapsulate the given data. Note that the size of the data buffer is not checked in any way, and that the data values are all considered valid: invalid values should be marked using the functions <code><a class="el" href="group__cpl__array.html#gaf177c5261df07eeecdbdd5b9fb0638eb" title="Invalidate an array element.">cpl_array_set_invalid()</a></code> The data array is not copied, so it should never be deallocated: to deallocate it, the function <code><a class="el" href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074" title="Delete an array.">cpl_array_delete()</a></code> should be called instead. Alternatively, the function <code><a class="el" href="group__cpl__array.html#ga72d1dd093082f040d23a745d49c20a17" title="Delete an array, without losing the data buffer.">cpl_array_unwrap()</a></code> might be used, and the data array deallocated afterwards. A zero or negative length is illegal, and would cause an error <code>CPL_ERROR_ILLEGAL_INPUT</code> to be set. An input <code>NULL</code> pointer would set an error <code>CPL_ERROR_NULL_INPUT</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Functions that handle arrays assume that an array data buffer is dynamically allocated: with a statically allocated data buffer any function implying memory handling (<code><a class="el" href="group__cpl__array.html#ga4515ab30836eb6793514ed0b37dbb2ba" title="Resize an array.">cpl_array_set_size()</a></code>, <code><a class="el" href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074" title="Delete an array.">cpl_array_delete()</a></code>, etc.) would crash the program. This means that a static data buffer should never be passed to this function if memory handling is planned. In case of a static data buffer, only the <code><a class="el" href="group__cpl__array.html#ga72d1dd093082f040d23a745d49c20a17" title="Delete an array, without losing the data buffer.">cpl_array_unwrap()</a></code> destructor can be used. </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>.</p>

</div>
</div>
<a id="ga73860f67710e47e722a150f8e2936351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73860f67710e47e722a150f8e2936351">&#9670;&nbsp;</a></span>cpl_array_wrap_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_array_wrap_string </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new character string array from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Existing data buffer. </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new array, or <code>NULL</code> in case of error.</dd></dl>
<p>See documentation of function <code><a class="el" href="group__cpl__array.html#gabc7eaabc5ae95aaa957353af9d1eed48" title="Create a new integer array from existing data.">cpl_array_wrap_int()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
