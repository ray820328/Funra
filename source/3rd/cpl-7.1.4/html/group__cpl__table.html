<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Common Pipeline Library Reference Manual: Tables</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cpl.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Common Pipeline Library Reference Manual
   &#160;<span id="projectnumber">7.1.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tables</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga06fc87d81c62e9abb8790b6e5713c55b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ , <br />
&#160;&#160;<a class="el" href="group__cpl__dfs.html#gga06fc87d81c62e9abb8790b6e5713c55bac69c4ac6a255442fcb9a3b220914ba7a">CPL_DFS_SIGNATURE_NONE</a>, 
<br />
&#160;&#160;<a class="el" href="group__cpl__dfs.html#gga06fc87d81c62e9abb8790b6e5713c55badba19502dbe2231579377a716f6a027f">CPL_DFS_SIGNATURE_DATAMD5</a>, 
<br />
&#160;&#160;<a class="el" href="group__cpl__dfs.html#gga06fc87d81c62e9abb8790b6e5713c55ba010f0a9abed7b7037f1a90707ae78019">CPL_DFS_SIGNATURE_CHECKSUM</a>
<br />
 }</td></tr>
<tr class="separator:ga06fc87d81c62e9abb8790b6e5713c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacd86e2e001bccbb405583fc4633a1553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gacd86e2e001bccbb405583fc4633a1553">cpl_table_abs_column</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gacd86e2e001bccbb405583fc4633a1553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of column values.  <a href="group__cpl__table.html#gacd86e2e001bccbb405583fc4633a1553">More...</a><br /></td></tr>
<tr class="separator:gacd86e2e001bccbb405583fc4633a1553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab781fd7d07eeeea0bf35caa742187e4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gab781fd7d07eeeea0bf35caa742187e4b">cpl_table_add_columns</a> (cpl_table *table, const char *to_name, const char *from_name)</td></tr>
<tr class="memdesc:gab781fd7d07eeeea0bf35caa742187e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the values of two numeric or complex table columns.  <a href="group__cpl__table.html#gab781fd7d07eeeea0bf35caa742187e4b">More...</a><br /></td></tr>
<tr class="separator:gab781fd7d07eeeea0bf35caa742187e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga883d885ad00da7f95afeb6152b147a2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga883d885ad00da7f95afeb6152b147a2d">cpl_table_add_scalar</a> (cpl_table *table, const char *name, double value)</td></tr>
<tr class="memdesc:ga883d885ad00da7f95afeb6152b147a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constant value to a numerical or complex column.  <a href="group__cpl__table.html#ga883d885ad00da7f95afeb6152b147a2d">More...</a><br /></td></tr>
<tr class="separator:ga883d885ad00da7f95afeb6152b147a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb27b0082baf9ca6b1cdcf22446dbe3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gadb27b0082baf9ca6b1cdcf22446dbe3b">cpl_table_add_scalar_complex</a> (cpl_table *table, const char *name, double complex value)</td></tr>
<tr class="memdesc:gadb27b0082baf9ca6b1cdcf22446dbe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constant complex value to a numerical or complex column.  <a href="group__cpl__table.html#gadb27b0082baf9ca6b1cdcf22446dbe3b">More...</a><br /></td></tr>
<tr class="separator:gadb27b0082baf9ca6b1cdcf22446dbe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82421625cbea42334ac39706a35c78c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga82421625cbea42334ac39706a35c78c7">cpl_table_and_selected</a> (cpl_table *table, const char *name1, cpl_table_select_operator operator, const char *name2)</td></tr>
<tr class="memdesc:ga82421625cbea42334ac39706a35c78c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from selected table rows, by comparing the values of two numerical columns.  <a href="group__cpl__table.html#ga82421625cbea42334ac39706a35c78c7">More...</a><br /></td></tr>
<tr class="separator:ga82421625cbea42334ac39706a35c78c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c70413f91b920b2d69222a55f0ec65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gad6c70413f91b920b2d69222a55f0ec65">cpl_table_and_selected_double</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, double value)</td></tr>
<tr class="memdesc:gad6c70413f91b920b2d69222a55f0ec65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from selected table rows, by comparing <em>double</em> column values with a constant.  <a href="group__cpl__table.html#gad6c70413f91b920b2d69222a55f0ec65">More...</a><br /></td></tr>
<tr class="separator:gad6c70413f91b920b2d69222a55f0ec65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf762d6b431bc22f1d1311d55a7856ac9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaf762d6b431bc22f1d1311d55a7856ac9">cpl_table_and_selected_double_complex</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, double complex value)</td></tr>
<tr class="memdesc:gaf762d6b431bc22f1d1311d55a7856ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from selected table rows, by comparing <em>double</em> complex column values with a complex constant.  <a href="group__cpl__table.html#gaf762d6b431bc22f1d1311d55a7856ac9">More...</a><br /></td></tr>
<tr class="separator:gaf762d6b431bc22f1d1311d55a7856ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadddb1fec819fbf39abeda2e7c86a16ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gadddb1fec819fbf39abeda2e7c86a16ca">cpl_table_and_selected_float</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, float value)</td></tr>
<tr class="memdesc:gadddb1fec819fbf39abeda2e7c86a16ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from selected table rows, by comparing <em>float</em> column values with a constant.  <a href="group__cpl__table.html#gadddb1fec819fbf39abeda2e7c86a16ca">More...</a><br /></td></tr>
<tr class="separator:gadddb1fec819fbf39abeda2e7c86a16ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabef99f98d4a4c50157790ca972c25b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gabef99f98d4a4c50157790ca972c25b94">cpl_table_and_selected_float_complex</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, float complex value)</td></tr>
<tr class="memdesc:gabef99f98d4a4c50157790ca972c25b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from selected table rows, by comparing <em>float</em> complex column values with a complex constant.  <a href="group__cpl__table.html#gabef99f98d4a4c50157790ca972c25b94">More...</a><br /></td></tr>
<tr class="separator:gabef99f98d4a4c50157790ca972c25b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c47b0c9a46d29d31e3bd6487d33587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga44c47b0c9a46d29d31e3bd6487d33587">cpl_table_and_selected_int</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, int value)</td></tr>
<tr class="memdesc:ga44c47b0c9a46d29d31e3bd6487d33587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from selected table rows, by comparing <em>integer</em> column values with a constant.  <a href="group__cpl__table.html#ga44c47b0c9a46d29d31e3bd6487d33587">More...</a><br /></td></tr>
<tr class="separator:ga44c47b0c9a46d29d31e3bd6487d33587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac4c8ccba7e895bacd6fd615e0d5e251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaac4c8ccba7e895bacd6fd615e0d5e251">cpl_table_and_selected_invalid</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gaac4c8ccba7e895bacd6fd615e0d5e251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from selected table rows all rows with an invalid value in a specified column.  <a href="group__cpl__table.html#gaac4c8ccba7e895bacd6fd615e0d5e251">More...</a><br /></td></tr>
<tr class="separator:gaac4c8ccba7e895bacd6fd615e0d5e251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e29ec76ae16a1b3a331873b4039318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga16e29ec76ae16a1b3a331873b4039318">cpl_table_and_selected_long</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, long value)</td></tr>
<tr class="memdesc:ga16e29ec76ae16a1b3a331873b4039318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from selected table rows, by comparing <em>long</em> column values with a constant.  <a href="group__cpl__table.html#ga16e29ec76ae16a1b3a331873b4039318">More...</a><br /></td></tr>
<tr class="separator:ga16e29ec76ae16a1b3a331873b4039318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3b53b514f999ed23586e2ce5a279394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gac3b53b514f999ed23586e2ce5a279394">cpl_table_and_selected_long_long</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, long long value)</td></tr>
<tr class="memdesc:gac3b53b514f999ed23586e2ce5a279394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from selected table rows, by comparing <em>long</em> <em>long</em> column values with a constant.  <a href="group__cpl__table.html#gac3b53b514f999ed23586e2ce5a279394">More...</a><br /></td></tr>
<tr class="separator:gac3b53b514f999ed23586e2ce5a279394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c357e82b40d5f78ae3ec5d1178ee47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga44c357e82b40d5f78ae3ec5d1178ee47">cpl_table_and_selected_string</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, const char *string)</td></tr>
<tr class="memdesc:ga44c357e82b40d5f78ae3ec5d1178ee47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from selected table rows, by comparing <em>string</em> column values with a character string.  <a href="group__cpl__table.html#ga44c357e82b40d5f78ae3ec5d1178ee47">More...</a><br /></td></tr>
<tr class="separator:ga44c357e82b40d5f78ae3ec5d1178ee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2494c547d1e8a7e8933114517c90b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaa2494c547d1e8a7e8933114517c90b2c">cpl_table_and_selected_window</a> (cpl_table *table, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count)</td></tr>
<tr class="memdesc:gaa2494c547d1e8a7e8933114517c90b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from selected rows only those within a table segment.  <a href="group__cpl__table.html#gaa2494c547d1e8a7e8933114517c90b2c">More...</a><br /></td></tr>
<tr class="separator:gaa2494c547d1e8a7e8933114517c90b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab000de212f15f43f1636b8935f36e8e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gab000de212f15f43f1636b8935f36e8e0">cpl_table_arg_column</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gab000de212f15f43f1636b8935f36e8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the phase angle value of table column elements.  <a href="group__cpl__table.html#gab000de212f15f43f1636b8935f36e8e0">More...</a><br /></td></tr>
<tr class="separator:gab000de212f15f43f1636b8935f36e8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0f43226e027e8ec517e040c0f6fefc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga5a0f43226e027e8ec517e040c0f6fefc">cpl_table_cast_column</a> (cpl_table *table, const char *from_name, const char *to_name, <a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a> type)</td></tr>
<tr class="memdesc:ga5a0f43226e027e8ec517e040c0f6fefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a numeric or complex column to a new numeric or complex type column.  <a href="group__cpl__table.html#ga5a0f43226e027e8ec517e040c0f6fefc">More...</a><br /></td></tr>
<tr class="separator:ga5a0f43226e027e8ec517e040c0f6fefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d6e80aaaa6c23a6ea33e5b4a3446a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gad3d6e80aaaa6c23a6ea33e5b4a3446a3">cpl_table_compare_structure</a> (const cpl_table *table1, const cpl_table *table2)</td></tr>
<tr class="memdesc:gad3d6e80aaaa6c23a6ea33e5b4a3446a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the structure of two tables.  <a href="group__cpl__table.html#gad3d6e80aaaa6c23a6ea33e5b4a3446a3">More...</a><br /></td></tr>
<tr class="separator:gad3d6e80aaaa6c23a6ea33e5b4a3446a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3159e272f1ab1334701ceb78c5bfed5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga3159e272f1ab1334701ceb78c5bfed5c">cpl_table_conjugate_column</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga3159e272f1ab1334701ceb78c5bfed5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex conjugate of column values.  <a href="group__cpl__table.html#ga3159e272f1ab1334701ceb78c5bfed5c">More...</a><br /></td></tr>
<tr class="separator:ga3159e272f1ab1334701ceb78c5bfed5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07ec4050738eb3c89aba569ad165358d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga07ec4050738eb3c89aba569ad165358d">cpl_table_copy_data_double</a> (cpl_table *table, const char *name, const double *data)</td></tr>
<tr class="memdesc:ga07ec4050738eb3c89aba569ad165358d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a table <em>double</em> column.  <a href="group__cpl__table.html#ga07ec4050738eb3c89aba569ad165358d">More...</a><br /></td></tr>
<tr class="separator:ga07ec4050738eb3c89aba569ad165358d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b06542776d38795071e1c1143e5fed6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga6b06542776d38795071e1c1143e5fed6">cpl_table_copy_data_double_complex</a> (cpl_table *table, const char *name, const double complex *data)</td></tr>
<tr class="memdesc:ga6b06542776d38795071e1c1143e5fed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a table <em>double</em> complex column.  <a href="group__cpl__table.html#ga6b06542776d38795071e1c1143e5fed6">More...</a><br /></td></tr>
<tr class="separator:ga6b06542776d38795071e1c1143e5fed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3047d1671356d4ebe6159b001f6467b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga3047d1671356d4ebe6159b001f6467b7">cpl_table_copy_data_float</a> (cpl_table *table, const char *name, const float *data)</td></tr>
<tr class="memdesc:ga3047d1671356d4ebe6159b001f6467b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a table <em>float</em> column.  <a href="group__cpl__table.html#ga3047d1671356d4ebe6159b001f6467b7">More...</a><br /></td></tr>
<tr class="separator:ga3047d1671356d4ebe6159b001f6467b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa8bb5bb7e7cff06f490bb91c8d056b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gacaa8bb5bb7e7cff06f490bb91c8d056b">cpl_table_copy_data_float_complex</a> (cpl_table *table, const char *name, const float complex *data)</td></tr>
<tr class="memdesc:gacaa8bb5bb7e7cff06f490bb91c8d056b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a table <em>float</em> complex column.  <a href="group__cpl__table.html#gacaa8bb5bb7e7cff06f490bb91c8d056b">More...</a><br /></td></tr>
<tr class="separator:gacaa8bb5bb7e7cff06f490bb91c8d056b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe57a091b367ded4a30091455a40287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga4fe57a091b367ded4a30091455a40287">cpl_table_copy_data_int</a> (cpl_table *table, const char *name, const int *data)</td></tr>
<tr class="memdesc:ga4fe57a091b367ded4a30091455a40287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a table <em>integer</em> column.  <a href="group__cpl__table.html#ga4fe57a091b367ded4a30091455a40287">More...</a><br /></td></tr>
<tr class="separator:ga4fe57a091b367ded4a30091455a40287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga201e5c5406192702faeb053a3d951f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga201e5c5406192702faeb053a3d951f4e">cpl_table_copy_data_long</a> (cpl_table *table, const char *name, const long *data)</td></tr>
<tr class="memdesc:ga201e5c5406192702faeb053a3d951f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a table <em>long</em> column.  <a href="group__cpl__table.html#ga201e5c5406192702faeb053a3d951f4e">More...</a><br /></td></tr>
<tr class="separator:ga201e5c5406192702faeb053a3d951f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga515eaf86d9b9cba708a8dd6befea0f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga515eaf86d9b9cba708a8dd6befea0f5e">cpl_table_copy_data_long_long</a> (cpl_table *table, const char *name, const long long *data)</td></tr>
<tr class="memdesc:ga515eaf86d9b9cba708a8dd6befea0f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a table <em>long</em> <em>long</em> column.  <a href="group__cpl__table.html#ga515eaf86d9b9cba708a8dd6befea0f5e">More...</a><br /></td></tr>
<tr class="separator:ga515eaf86d9b9cba708a8dd6befea0f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1d73189a9954720812c35641ee19570"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gad1d73189a9954720812c35641ee19570">cpl_table_copy_data_string</a> (cpl_table *table, const char *name, const char **data)</td></tr>
<tr class="memdesc:gad1d73189a9954720812c35641ee19570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy existing data to a table <em>string</em> column.  <a href="group__cpl__table.html#gad1d73189a9954720812c35641ee19570">More...</a><br /></td></tr>
<tr class="separator:gad1d73189a9954720812c35641ee19570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86dc059191d3a5b42832fcfcf8efbea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga86dc059191d3a5b42832fcfcf8efbea2">cpl_table_copy_structure</a> (cpl_table *table, const cpl_table *mtable)</td></tr>
<tr class="memdesc:ga86dc059191d3a5b42832fcfcf8efbea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give to a table the same structure of another table.  <a href="group__cpl__table.html#ga86dc059191d3a5b42832fcfcf8efbea2">More...</a><br /></td></tr>
<tr class="separator:ga86dc059191d3a5b42832fcfcf8efbea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ea43461bc9128d44622f747d92582d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga9ea43461bc9128d44622f747d92582d4">cpl_table_count_invalid</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga9ea43461bc9128d44622f747d92582d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count number of invalid values in a table column.  <a href="group__cpl__table.html#ga9ea43461bc9128d44622f747d92582d4">More...</a><br /></td></tr>
<tr class="separator:ga9ea43461bc9128d44622f747d92582d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e75173e3bc6cb8027d8df403bbc405"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga51e75173e3bc6cb8027d8df403bbc405">cpl_table_count_selected</a> (const cpl_table *table)</td></tr>
<tr class="memdesc:ga51e75173e3bc6cb8027d8df403bbc405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of selected rows in given table.  <a href="group__cpl__table.html#ga51e75173e3bc6cb8027d8df403bbc405">More...</a><br /></td></tr>
<tr class="separator:ga51e75173e3bc6cb8027d8df403bbc405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fa13d6c00a323556c31bd531d6dc00c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga7fa13d6c00a323556c31bd531d6dc00c">cpl_table_delete</a> (cpl_table *table)</td></tr>
<tr class="memdesc:ga7fa13d6c00a323556c31bd531d6dc00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a table.  <a href="group__cpl__table.html#ga7fa13d6c00a323556c31bd531d6dc00c">More...</a><br /></td></tr>
<tr class="separator:ga7fa13d6c00a323556c31bd531d6dc00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa96082bfb779453aa046af2c22007dc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaa96082bfb779453aa046af2c22007dc3">cpl_table_divide_columns</a> (cpl_table *table, const char *to_name, const char *from_name)</td></tr>
<tr class="memdesc:gaa96082bfb779453aa046af2c22007dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide two numeric or complex table columns.  <a href="group__cpl__table.html#gaa96082bfb779453aa046af2c22007dc3">More...</a><br /></td></tr>
<tr class="separator:gaa96082bfb779453aa046af2c22007dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96ed9107604e45cc14e3d0b71a447ac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga96ed9107604e45cc14e3d0b71a447ac5">cpl_table_divide_scalar</a> (cpl_table *table, const char *name, double value)</td></tr>
<tr class="memdesc:ga96ed9107604e45cc14e3d0b71a447ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a numerical or complex column by a constant.  <a href="group__cpl__table.html#ga96ed9107604e45cc14e3d0b71a447ac5">More...</a><br /></td></tr>
<tr class="separator:ga96ed9107604e45cc14e3d0b71a447ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d11a62cf023f89f4dfabc470a5a7e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga87d11a62cf023f89f4dfabc470a5a7e6">cpl_table_divide_scalar_complex</a> (cpl_table *table, const char *name, double complex value)</td></tr>
<tr class="memdesc:ga87d11a62cf023f89f4dfabc470a5a7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a numerical or complex column by a complex constant.  <a href="group__cpl__table.html#ga87d11a62cf023f89f4dfabc470a5a7e6">More...</a><br /></td></tr>
<tr class="separator:ga87d11a62cf023f89f4dfabc470a5a7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd790a348822ac1e02165c1e2b9435c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gacd790a348822ac1e02165c1e2b9435c4">cpl_table_dump</a> (const cpl_table *table, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, FILE *stream)</td></tr>
<tr class="memdesc:gacd790a348822ac1e02165c1e2b9435c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a table.  <a href="group__cpl__table.html#gacd790a348822ac1e02165c1e2b9435c4">More...</a><br /></td></tr>
<tr class="separator:gacd790a348822ac1e02165c1e2b9435c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8ae7c1313f70adaebfd92ad04c9305c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gae8ae7c1313f70adaebfd92ad04c9305c">cpl_table_dump_structure</a> (const cpl_table *table, FILE *stream)</td></tr>
<tr class="memdesc:gae8ae7c1313f70adaebfd92ad04c9305c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describe the structure and the contents of a table.  <a href="group__cpl__table.html#gae8ae7c1313f70adaebfd92ad04c9305c">More...</a><br /></td></tr>
<tr class="separator:gae8ae7c1313f70adaebfd92ad04c9305c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49553a682513ffa3ecd943187653dc40"><td class="memItemLeft" align="right" valign="top">cpl_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga49553a682513ffa3ecd943187653dc40">cpl_table_duplicate</a> (const cpl_table *table)</td></tr>
<tr class="memdesc:ga49553a682513ffa3ecd943187653dc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of a table.  <a href="group__cpl__table.html#ga49553a682513ffa3ecd943187653dc40">More...</a><br /></td></tr>
<tr class="separator:ga49553a682513ffa3ecd943187653dc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d283b2493284945d397e805aa5dd635"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga2d283b2493284945d397e805aa5dd635">cpl_table_duplicate_column</a> (cpl_table *to_table, const char *to_name, const cpl_table *from_table, const char *from_name)</td></tr>
<tr class="memdesc:ga2d283b2493284945d397e805aa5dd635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a column from a table to another.  <a href="group__cpl__table.html#ga2d283b2493284945d397e805aa5dd635">More...</a><br /></td></tr>
<tr class="separator:ga2d283b2493284945d397e805aa5dd635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdfca1c1b3478ce6bcc3f4340131adba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gabdfca1c1b3478ce6bcc3f4340131adba">cpl_table_erase_column</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gabdfca1c1b3478ce6bcc3f4340131adba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a column from a table.  <a href="group__cpl__table.html#gabdfca1c1b3478ce6bcc3f4340131adba">More...</a><br /></td></tr>
<tr class="separator:gabdfca1c1b3478ce6bcc3f4340131adba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397f3c878f110930bfe64b537c5d417c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga397f3c878f110930bfe64b537c5d417c">cpl_table_erase_invalid</a> (cpl_table *table)</td></tr>
<tr class="memdesc:ga397f3c878f110930bfe64b537c5d417c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove from a table all columns just containing invalid elements, and then all rows containing at least one invalid element.  <a href="group__cpl__table.html#ga397f3c878f110930bfe64b537c5d417c">More...</a><br /></td></tr>
<tr class="separator:ga397f3c878f110930bfe64b537c5d417c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c318a3f2c02b47e8c1fb4ccc019af1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga5c318a3f2c02b47e8c1fb4ccc019af1b">cpl_table_erase_invalid_rows</a> (cpl_table *table)</td></tr>
<tr class="memdesc:ga5c318a3f2c02b47e8c1fb4ccc019af1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove from a table columns and rows just containing invalid elements.  <a href="group__cpl__table.html#ga5c318a3f2c02b47e8c1fb4ccc019af1b">More...</a><br /></td></tr>
<tr class="separator:ga5c318a3f2c02b47e8c1fb4ccc019af1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b708efb1c519be18d680f26c947d8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gab9b708efb1c519be18d680f26c947d8d">cpl_table_erase_selected</a> (cpl_table *table)</td></tr>
<tr class="memdesc:gab9b708efb1c519be18d680f26c947d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the selected rows of a table.  <a href="group__cpl__table.html#gab9b708efb1c519be18d680f26c947d8d">More...</a><br /></td></tr>
<tr class="separator:gab9b708efb1c519be18d680f26c947d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3777a49d3efd72eeb137af1c47176e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga8e3777a49d3efd72eeb137af1c47176e">cpl_table_erase_window</a> (cpl_table *table, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count)</td></tr>
<tr class="memdesc:ga8e3777a49d3efd72eeb137af1c47176e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a table segment.  <a href="group__cpl__table.html#ga8e3777a49d3efd72eeb137af1c47176e">More...</a><br /></td></tr>
<tr class="separator:ga8e3777a49d3efd72eeb137af1c47176e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9494feb58c3cf9daab71c9940d5968d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga9494feb58c3cf9daab71c9940d5968d2">cpl_table_exponential_column</a> (cpl_table *table, const char *name, double base)</td></tr>
<tr class="memdesc:ga9494feb58c3cf9daab71c9940d5968d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of column values.  <a href="group__cpl__table.html#ga9494feb58c3cf9daab71c9940d5968d2">More...</a><br /></td></tr>
<tr class="separator:ga9494feb58c3cf9daab71c9940d5968d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84af52720711c7d4a3ecadce824f47b7"><td class="memItemLeft" align="right" valign="top">cpl_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga84af52720711c7d4a3ecadce824f47b7">cpl_table_extract</a> (const cpl_table *table, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count)</td></tr>
<tr class="memdesc:ga84af52720711c7d4a3ecadce824f47b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table from a section of another table.  <a href="group__cpl__table.html#ga84af52720711c7d4a3ecadce824f47b7">More...</a><br /></td></tr>
<tr class="separator:ga84af52720711c7d4a3ecadce824f47b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae709603ee26fdd0abdb11f50c8c64e36"><td class="memItemLeft" align="right" valign="top">cpl_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gae709603ee26fdd0abdb11f50c8c64e36">cpl_table_extract_selected</a> (const cpl_table *table)</td></tr>
<tr class="memdesc:gae709603ee26fdd0abdb11f50c8c64e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new table from the selected rows of another table.  <a href="group__cpl__table.html#gae709603ee26fdd0abdb11f50c8c64e36">More...</a><br /></td></tr>
<tr class="separator:gae709603ee26fdd0abdb11f50c8c64e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4cb45bf2ed95b53698e9a5371f311f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaf4cb45bf2ed95b53698e9a5371f311f3">cpl_table_fill_column_window</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, double value)</td></tr>
<tr class="memdesc:gaf4cb45bf2ed95b53698e9a5371f311f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a numerical column segment.  <a href="group__cpl__table.html#gaf4cb45bf2ed95b53698e9a5371f311f3">More...</a><br /></td></tr>
<tr class="separator:gaf4cb45bf2ed95b53698e9a5371f311f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23ab752473c166bfe541642cf618d065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga23ab752473c166bfe541642cf618d065">cpl_table_fill_column_window_array</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, const cpl_array *array)</td></tr>
<tr class="memdesc:ga23ab752473c166bfe541642cf618d065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an array to an <em>array</em> column segment.  <a href="group__cpl__table.html#ga23ab752473c166bfe541642cf618d065">More...</a><br /></td></tr>
<tr class="separator:ga23ab752473c166bfe541642cf618d065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ff6e5a6a9ea0cdfd2e7151098e3a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga57ff6e5a6a9ea0cdfd2e7151098e3a38">cpl_table_fill_column_window_complex</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, double complex value)</td></tr>
<tr class="memdesc:ga57ff6e5a6a9ea0cdfd2e7151098e3a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a complex column segment.  <a href="group__cpl__table.html#ga57ff6e5a6a9ea0cdfd2e7151098e3a38">More...</a><br /></td></tr>
<tr class="separator:ga57ff6e5a6a9ea0cdfd2e7151098e3a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b730484d1f4a4c260e62e042d1b7d9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga1b730484d1f4a4c260e62e042d1b7d9d">cpl_table_fill_column_window_double</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, double value)</td></tr>
<tr class="memdesc:ga1b730484d1f4a4c260e62e042d1b7d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>double</em> column segment.  <a href="group__cpl__table.html#ga1b730484d1f4a4c260e62e042d1b7d9d">More...</a><br /></td></tr>
<tr class="separator:ga1b730484d1f4a4c260e62e042d1b7d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91595305eb67001f0d8448bfccfd2215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga91595305eb67001f0d8448bfccfd2215">cpl_table_fill_column_window_double_complex</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, double complex value)</td></tr>
<tr class="memdesc:ga91595305eb67001f0d8448bfccfd2215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>double</em> complex column segment.  <a href="group__cpl__table.html#ga91595305eb67001f0d8448bfccfd2215">More...</a><br /></td></tr>
<tr class="separator:ga91595305eb67001f0d8448bfccfd2215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga188f2e0565ed4e489364e478e1b5c25d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga188f2e0565ed4e489364e478e1b5c25d">cpl_table_fill_column_window_float</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, float value)</td></tr>
<tr class="memdesc:ga188f2e0565ed4e489364e478e1b5c25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>float</em> column segment.  <a href="group__cpl__table.html#ga188f2e0565ed4e489364e478e1b5c25d">More...</a><br /></td></tr>
<tr class="separator:ga188f2e0565ed4e489364e478e1b5c25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc6d82251e5665043cc25aa4099394e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga6bc6d82251e5665043cc25aa4099394e">cpl_table_fill_column_window_float_complex</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, float complex value)</td></tr>
<tr class="memdesc:ga6bc6d82251e5665043cc25aa4099394e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>float</em> complex column segment.  <a href="group__cpl__table.html#ga6bc6d82251e5665043cc25aa4099394e">More...</a><br /></td></tr>
<tr class="separator:ga6bc6d82251e5665043cc25aa4099394e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4190271c05bd6121a22b53dc3e27bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaa4190271c05bd6121a22b53dc3e27bfe">cpl_table_fill_column_window_int</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, int value)</td></tr>
<tr class="memdesc:gaa4190271c05bd6121a22b53dc3e27bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to an <em>integer</em> column segment.  <a href="group__cpl__table.html#gaa4190271c05bd6121a22b53dc3e27bfe">More...</a><br /></td></tr>
<tr class="separator:gaa4190271c05bd6121a22b53dc3e27bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5717104df95162d3cb715060bab74f8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga5717104df95162d3cb715060bab74f8f">cpl_table_fill_column_window_long</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, long value)</td></tr>
<tr class="memdesc:ga5717104df95162d3cb715060bab74f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to an <em>long</em> column segment.  <a href="group__cpl__table.html#ga5717104df95162d3cb715060bab74f8f">More...</a><br /></td></tr>
<tr class="separator:ga5717104df95162d3cb715060bab74f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga312933cb021d6105c183b446ccc59c0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga312933cb021d6105c183b446ccc59c0d">cpl_table_fill_column_window_long_long</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, long long value)</td></tr>
<tr class="memdesc:ga312933cb021d6105c183b446ccc59c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to an <em>long</em> <em>long</em> column segment.  <a href="group__cpl__table.html#ga312933cb021d6105c183b446ccc59c0d">More...</a><br /></td></tr>
<tr class="separator:ga312933cb021d6105c183b446ccc59c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfb4459d9ef7b671c25977c8d0f9f3c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gacfb4459d9ef7b671c25977c8d0f9f3c4">cpl_table_fill_column_window_string</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count, const char *value)</td></tr>
<tr class="memdesc:gacfb4459d9ef7b671c25977c8d0f9f3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a character string to a <em>string</em> column segment.  <a href="group__cpl__table.html#gacfb4459d9ef7b671c25977c8d0f9f3c4">More...</a><br /></td></tr>
<tr class="separator:gacfb4459d9ef7b671c25977c8d0f9f3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5833f6747311fd2c8ccda52702379fbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga5833f6747311fd2c8ccda52702379fbc">cpl_table_fill_invalid_double</a> (cpl_table *table, const char *name, double code)</td></tr>
<tr class="memdesc:ga5833f6747311fd2c8ccda52702379fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a numerical value to invalid <em>double</em> column elements.  <a href="group__cpl__table.html#ga5833f6747311fd2c8ccda52702379fbc">More...</a><br /></td></tr>
<tr class="separator:ga5833f6747311fd2c8ccda52702379fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830a09cfa2504d15aa6eb0d25019eda2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga830a09cfa2504d15aa6eb0d25019eda2">cpl_table_fill_invalid_double_complex</a> (cpl_table *table, const char *name, double complex code)</td></tr>
<tr class="memdesc:ga830a09cfa2504d15aa6eb0d25019eda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a numerical value to invalid <em>double</em> complex column elements.  <a href="group__cpl__table.html#ga830a09cfa2504d15aa6eb0d25019eda2">More...</a><br /></td></tr>
<tr class="separator:ga830a09cfa2504d15aa6eb0d25019eda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5bd6ed9bb98fdbab4a79b26f3cf68ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaf5bd6ed9bb98fdbab4a79b26f3cf68ea">cpl_table_fill_invalid_float</a> (cpl_table *table, const char *name, float code)</td></tr>
<tr class="memdesc:gaf5bd6ed9bb98fdbab4a79b26f3cf68ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a numerical value to invalid <em>float</em> column elements.  <a href="group__cpl__table.html#gaf5bd6ed9bb98fdbab4a79b26f3cf68ea">More...</a><br /></td></tr>
<tr class="separator:gaf5bd6ed9bb98fdbab4a79b26f3cf68ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2f1d812cab0159c4eb1cd212928c4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaef2f1d812cab0159c4eb1cd212928c4a">cpl_table_fill_invalid_float_complex</a> (cpl_table *table, const char *name, float complex code)</td></tr>
<tr class="memdesc:gaef2f1d812cab0159c4eb1cd212928c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a numerical value to invalid <em>float</em> complex column elements.  <a href="group__cpl__table.html#gaef2f1d812cab0159c4eb1cd212928c4a">More...</a><br /></td></tr>
<tr class="separator:gaef2f1d812cab0159c4eb1cd212928c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0041fc2ebc6cf8c41693298b91a91551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga0041fc2ebc6cf8c41693298b91a91551">cpl_table_fill_invalid_int</a> (cpl_table *table, const char *name, int code)</td></tr>
<tr class="memdesc:ga0041fc2ebc6cf8c41693298b91a91551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a numerical value to invalid <em>integer</em> column elements.  <a href="group__cpl__table.html#ga0041fc2ebc6cf8c41693298b91a91551">More...</a><br /></td></tr>
<tr class="separator:ga0041fc2ebc6cf8c41693298b91a91551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga214cb1176a8d6c1381626f3446a31424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga214cb1176a8d6c1381626f3446a31424">cpl_table_fill_invalid_long</a> (cpl_table *table, const char *name, long code)</td></tr>
<tr class="memdesc:ga214cb1176a8d6c1381626f3446a31424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a numerical value to invalid <em>long</em> column elements.  <a href="group__cpl__table.html#ga214cb1176a8d6c1381626f3446a31424">More...</a><br /></td></tr>
<tr class="separator:ga214cb1176a8d6c1381626f3446a31424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96bffe508ceab3b4b0c33cbb7475ad64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga96bffe508ceab3b4b0c33cbb7475ad64">cpl_table_fill_invalid_long_long</a> (cpl_table *table, const char *name, long long code)</td></tr>
<tr class="memdesc:ga96bffe508ceab3b4b0c33cbb7475ad64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a numerical value to invalid <em>long</em> <em>long</em> column elements.  <a href="group__cpl__table.html#ga96bffe508ceab3b4b0c33cbb7475ad64">More...</a><br /></td></tr>
<tr class="separator:ga96bffe508ceab3b4b0c33cbb7475ad64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33399dd985658a5e658b0427a6d4762d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga33399dd985658a5e658b0427a6d4762d">cpl_table_get</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, int *null)</td></tr>
<tr class="memdesc:ga33399dd985658a5e658b0427a6d4762d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a numerical column.  <a href="group__cpl__table.html#ga33399dd985658a5e658b0427a6d4762d">More...</a><br /></td></tr>
<tr class="separator:ga33399dd985658a5e658b0427a6d4762d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1303e1dd8cc3239acb1d207da32ef63f"><td class="memItemLeft" align="right" valign="top">const cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga1303e1dd8cc3239acb1d207da32ef63f">cpl_table_get_array</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row)</td></tr>
<tr class="memdesc:ga1303e1dd8cc3239acb1d207da32ef63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an array from an <em>array</em> column.  <a href="group__cpl__table.html#ga1303e1dd8cc3239acb1d207da32ef63f">More...</a><br /></td></tr>
<tr class="separator:ga1303e1dd8cc3239acb1d207da32ef63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61f1174b2f53f2e835d64d35dd337d8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga61f1174b2f53f2e835d64d35dd337d8a">cpl_table_get_column_depth</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga61f1174b2f53f2e835d64d35dd337d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the depth of a table column.  <a href="group__cpl__table.html#ga61f1174b2f53f2e835d64d35dd337d8a">More...</a><br /></td></tr>
<tr class="separator:ga61f1174b2f53f2e835d64d35dd337d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga359e0b4ad826ad12cc8f17b7eb26c2d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga359e0b4ad826ad12cc8f17b7eb26c2d5">cpl_table_get_column_dimension</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> indx)</td></tr>
<tr class="memdesc:ga359e0b4ad826ad12cc8f17b7eb26c2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of one dimension of a table column of arrays.  <a href="group__cpl__table.html#ga359e0b4ad826ad12cc8f17b7eb26c2d5">More...</a><br /></td></tr>
<tr class="separator:ga359e0b4ad826ad12cc8f17b7eb26c2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbf8294fd53f45d95d6c1e6502c10422"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gabbf8294fd53f45d95d6c1e6502c10422">cpl_table_get_column_dimensions</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gabbf8294fd53f45d95d6c1e6502c10422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of dimensions of a table column of arrays.  <a href="group__cpl__table.html#gabbf8294fd53f45d95d6c1e6502c10422">More...</a><br /></td></tr>
<tr class="separator:gabbf8294fd53f45d95d6c1e6502c10422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae259f11cb1b876a48cadbd932262c82b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gae259f11cb1b876a48cadbd932262c82b">cpl_table_get_column_format</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gae259f11cb1b876a48cadbd932262c82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the format of a table column.  <a href="group__cpl__table.html#gae259f11cb1b876a48cadbd932262c82b">More...</a><br /></td></tr>
<tr class="separator:gae259f11cb1b876a48cadbd932262c82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9900039b3efba3bde4bdd6a178e5323a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga9900039b3efba3bde4bdd6a178e5323a">cpl_table_get_column_max</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga9900039b3efba3bde4bdd6a178e5323a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum value in a numerical column.  <a href="group__cpl__table.html#ga9900039b3efba3bde4bdd6a178e5323a">More...</a><br /></td></tr>
<tr class="separator:ga9900039b3efba3bde4bdd6a178e5323a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac868a47a84d7fae362c91425c692b313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gac868a47a84d7fae362c91425c692b313">cpl_table_get_column_maxpos</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *row)</td></tr>
<tr class="memdesc:gac868a47a84d7fae362c91425c692b313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get position of maximum in a numerical column.  <a href="group__cpl__table.html#gac868a47a84d7fae362c91425c692b313">More...</a><br /></td></tr>
<tr class="separator:gac868a47a84d7fae362c91425c692b313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373b83f9dcf98c1e1888d2eea9373861"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga373b83f9dcf98c1e1888d2eea9373861">cpl_table_get_column_mean</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga373b83f9dcf98c1e1888d2eea9373861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean value of a numerical column.  <a href="group__cpl__table.html#ga373b83f9dcf98c1e1888d2eea9373861">More...</a><br /></td></tr>
<tr class="separator:ga373b83f9dcf98c1e1888d2eea9373861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e074ae74e0eda508f4dcf2949f82bf8"><td class="memItemLeft" align="right" valign="top">double complex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga5e074ae74e0eda508f4dcf2949f82bf8">cpl_table_get_column_mean_complex</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga5e074ae74e0eda508f4dcf2949f82bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean value of a numerical or complex column.  <a href="group__cpl__table.html#ga5e074ae74e0eda508f4dcf2949f82bf8">More...</a><br /></td></tr>
<tr class="separator:ga5e074ae74e0eda508f4dcf2949f82bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f58ee405b0bcc98d709b3acfbb71ee8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga7f58ee405b0bcc98d709b3acfbb71ee8">cpl_table_get_column_median</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga7f58ee405b0bcc98d709b3acfbb71ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the median value of a numerical column.  <a href="group__cpl__table.html#ga7f58ee405b0bcc98d709b3acfbb71ee8">More...</a><br /></td></tr>
<tr class="separator:ga7f58ee405b0bcc98d709b3acfbb71ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80b4d4d2a48bbd76ff9e1a2823dad1a2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga80b4d4d2a48bbd76ff9e1a2823dad1a2">cpl_table_get_column_min</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga80b4d4d2a48bbd76ff9e1a2823dad1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum value in a numerical column.  <a href="group__cpl__table.html#ga80b4d4d2a48bbd76ff9e1a2823dad1a2">More...</a><br /></td></tr>
<tr class="separator:ga80b4d4d2a48bbd76ff9e1a2823dad1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga852d3e80f107f985232c506500def8e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga852d3e80f107f985232c506500def8e7">cpl_table_get_column_minpos</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *row)</td></tr>
<tr class="memdesc:ga852d3e80f107f985232c506500def8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get position of minimum in a numerical column.  <a href="group__cpl__table.html#ga852d3e80f107f985232c506500def8e7">More...</a><br /></td></tr>
<tr class="separator:ga852d3e80f107f985232c506500def8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab198f8dc91a1bd65082f1f8b8bb9019a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gab198f8dc91a1bd65082f1f8b8bb9019a">cpl_table_get_column_name</a> (const cpl_table *table)</td></tr>
<tr class="memdesc:gab198f8dc91a1bd65082f1f8b8bb9019a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get table columns names.  <a href="group__cpl__table.html#gab198f8dc91a1bd65082f1f8b8bb9019a">More...</a><br /></td></tr>
<tr class="separator:gab198f8dc91a1bd65082f1f8b8bb9019a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef76a593a5bfbefdc37553c025537fe8"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaef76a593a5bfbefdc37553c025537fe8">cpl_table_get_column_names</a> (const cpl_table *table)</td></tr>
<tr class="memdesc:gaef76a593a5bfbefdc37553c025537fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get table columns names.  <a href="group__cpl__table.html#gaef76a593a5bfbefdc37553c025537fe8">More...</a><br /></td></tr>
<tr class="separator:gaef76a593a5bfbefdc37553c025537fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabab0fdcc3cd3af2ac66fc56f1e3dda71"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gabab0fdcc3cd3af2ac66fc56f1e3dda71">cpl_table_get_column_stdev</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gabab0fdcc3cd3af2ac66fc56f1e3dda71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the standard deviation of a table column.  <a href="group__cpl__table.html#gabab0fdcc3cd3af2ac66fc56f1e3dda71">More...</a><br /></td></tr>
<tr class="separator:gabab0fdcc3cd3af2ac66fc56f1e3dda71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02d329749056a40390df1555c4021032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga02d329749056a40390df1555c4021032">cpl_table_get_column_type</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga02d329749056a40390df1555c4021032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of a table column.  <a href="group__cpl__table.html#ga02d329749056a40390df1555c4021032">More...</a><br /></td></tr>
<tr class="separator:ga02d329749056a40390df1555c4021032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d2166101405f3dd6f6e62adab9c9194"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga4d2166101405f3dd6f6e62adab9c9194">cpl_table_get_column_unit</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga4d2166101405f3dd6f6e62adab9c9194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unit of a table column.  <a href="group__cpl__table.html#ga4d2166101405f3dd6f6e62adab9c9194">More...</a><br /></td></tr>
<tr class="separator:ga4d2166101405f3dd6f6e62adab9c9194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2101ab90a219c7839d1226d0f69f85e7"><td class="memItemLeft" align="right" valign="top">double complex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga2101ab90a219c7839d1226d0f69f85e7">cpl_table_get_complex</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, int *null)</td></tr>
<tr class="memdesc:ga2101ab90a219c7839d1226d0f69f85e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a complex column.  <a href="group__cpl__table.html#ga2101ab90a219c7839d1226d0f69f85e7">More...</a><br /></td></tr>
<tr class="separator:ga2101ab90a219c7839d1226d0f69f85e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7f05cb05cdfdf3723d786d9ce89c23e"><td class="memItemLeft" align="right" valign="top">cpl_array **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gae7f05cb05cdfdf3723d786d9ce89c23e">cpl_table_get_data_array</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gae7f05cb05cdfdf3723d786d9ce89c23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <em>array</em> column data.  <a href="group__cpl__table.html#gae7f05cb05cdfdf3723d786d9ce89c23e">More...</a><br /></td></tr>
<tr class="separator:gae7f05cb05cdfdf3723d786d9ce89c23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga769291d4bb023842bce91fe0e0b536ae"><td class="memItemLeft" align="right" valign="top">const cpl_array **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga769291d4bb023842bce91fe0e0b536ae">cpl_table_get_data_array_const</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga769291d4bb023842bce91fe0e0b536ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <em>array</em> column data.  <a href="group__cpl__table.html#ga769291d4bb023842bce91fe0e0b536ae">More...</a><br /></td></tr>
<tr class="separator:ga769291d4bb023842bce91fe0e0b536ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87ca9a6aca3ddfc830f64906142a21cb"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga87ca9a6aca3ddfc830f64906142a21cb">cpl_table_get_data_double</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga87ca9a6aca3ddfc830f64906142a21cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <em>double</em> column data.  <a href="group__cpl__table.html#ga87ca9a6aca3ddfc830f64906142a21cb">More...</a><br /></td></tr>
<tr class="separator:ga87ca9a6aca3ddfc830f64906142a21cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6735ebf8f078b00d846e954f6577c79a"><td class="memItemLeft" align="right" valign="top">double complex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga6735ebf8f078b00d846e954f6577c79a">cpl_table_get_data_double_complex</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga6735ebf8f078b00d846e954f6577c79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <em>double</em> complex column data.  <a href="group__cpl__table.html#ga6735ebf8f078b00d846e954f6577c79a">More...</a><br /></td></tr>
<tr class="separator:ga6735ebf8f078b00d846e954f6577c79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33754f52437a696230a6a14494c9c088"><td class="memItemLeft" align="right" valign="top">const double complex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga33754f52437a696230a6a14494c9c088">cpl_table_get_data_double_complex_const</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga33754f52437a696230a6a14494c9c088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <em>double</em> complex column data.  <a href="group__cpl__table.html#ga33754f52437a696230a6a14494c9c088">More...</a><br /></td></tr>
<tr class="separator:ga33754f52437a696230a6a14494c9c088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed6b2dfa954fff86892075e0ba71e655"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaed6b2dfa954fff86892075e0ba71e655">cpl_table_get_data_double_const</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gaed6b2dfa954fff86892075e0ba71e655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <em>double</em> column data.  <a href="group__cpl__table.html#gaed6b2dfa954fff86892075e0ba71e655">More...</a><br /></td></tr>
<tr class="separator:gaed6b2dfa954fff86892075e0ba71e655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f464d0863d252cb9d80d43f3cd71ef"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gae9f464d0863d252cb9d80d43f3cd71ef">cpl_table_get_data_float</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gae9f464d0863d252cb9d80d43f3cd71ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <em>float</em> column data.  <a href="group__cpl__table.html#gae9f464d0863d252cb9d80d43f3cd71ef">More...</a><br /></td></tr>
<tr class="separator:gae9f464d0863d252cb9d80d43f3cd71ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8917beee9df147a5173806902e45a5d0"><td class="memItemLeft" align="right" valign="top">float complex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga8917beee9df147a5173806902e45a5d0">cpl_table_get_data_float_complex</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga8917beee9df147a5173806902e45a5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <em>float</em> complex column data.  <a href="group__cpl__table.html#ga8917beee9df147a5173806902e45a5d0">More...</a><br /></td></tr>
<tr class="separator:ga8917beee9df147a5173806902e45a5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabad14408e5d47d021cf1647c0df79e83"><td class="memItemLeft" align="right" valign="top">const float complex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gabad14408e5d47d021cf1647c0df79e83">cpl_table_get_data_float_complex_const</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gabad14408e5d47d021cf1647c0df79e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <em>float</em> complex column data.  <a href="group__cpl__table.html#gabad14408e5d47d021cf1647c0df79e83">More...</a><br /></td></tr>
<tr class="separator:gabad14408e5d47d021cf1647c0df79e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e0956719b1fd2591ab485d32a6a7b3"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gad1e0956719b1fd2591ab485d32a6a7b3">cpl_table_get_data_float_const</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gad1e0956719b1fd2591ab485d32a6a7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <em>float</em> column data.  <a href="group__cpl__table.html#gad1e0956719b1fd2591ab485d32a6a7b3">More...</a><br /></td></tr>
<tr class="separator:gad1e0956719b1fd2591ab485d32a6a7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff3998d07c6cbf88d0297648bce6f6f4"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaff3998d07c6cbf88d0297648bce6f6f4">cpl_table_get_data_int</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gaff3998d07c6cbf88d0297648bce6f6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <em>integer</em> column data.  <a href="group__cpl__table.html#gaff3998d07c6cbf88d0297648bce6f6f4">More...</a><br /></td></tr>
<tr class="separator:gaff3998d07c6cbf88d0297648bce6f6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75e99fd2cd8582c622c7d0e8b3584599"><td class="memItemLeft" align="right" valign="top">const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga75e99fd2cd8582c622c7d0e8b3584599">cpl_table_get_data_int_const</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga75e99fd2cd8582c622c7d0e8b3584599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <em>integer</em> column data.  <a href="group__cpl__table.html#ga75e99fd2cd8582c622c7d0e8b3584599">More...</a><br /></td></tr>
<tr class="separator:ga75e99fd2cd8582c622c7d0e8b3584599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef375e98c30597d3f6857e6f8914e2e"><td class="memItemLeft" align="right" valign="top">long *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga8ef375e98c30597d3f6857e6f8914e2e">cpl_table_get_data_long</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga8ef375e98c30597d3f6857e6f8914e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <em>long</em> column data.  <a href="group__cpl__table.html#ga8ef375e98c30597d3f6857e6f8914e2e">More...</a><br /></td></tr>
<tr class="separator:ga8ef375e98c30597d3f6857e6f8914e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59fa517b348aaa1129c0c671bed58ca"><td class="memItemLeft" align="right" valign="top">const long *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gae59fa517b348aaa1129c0c671bed58ca">cpl_table_get_data_long_const</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gae59fa517b348aaa1129c0c671bed58ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <em>long</em> column data.  <a href="group__cpl__table.html#gae59fa517b348aaa1129c0c671bed58ca">More...</a><br /></td></tr>
<tr class="separator:gae59fa517b348aaa1129c0c671bed58ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc3a50e0c1812fa80381dcddb26dd3e8"><td class="memItemLeft" align="right" valign="top">long long *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gacc3a50e0c1812fa80381dcddb26dd3e8">cpl_table_get_data_long_long</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gacc3a50e0c1812fa80381dcddb26dd3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <em>long</em> <em>long</em> column data.  <a href="group__cpl__table.html#gacc3a50e0c1812fa80381dcddb26dd3e8">More...</a><br /></td></tr>
<tr class="separator:gacc3a50e0c1812fa80381dcddb26dd3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2089d19649f49d69165ed9ec458a675b"><td class="memItemLeft" align="right" valign="top">const long long *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga2089d19649f49d69165ed9ec458a675b">cpl_table_get_data_long_long_const</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga2089d19649f49d69165ed9ec458a675b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <em>long</em> long column data.  <a href="group__cpl__table.html#ga2089d19649f49d69165ed9ec458a675b">More...</a><br /></td></tr>
<tr class="separator:ga2089d19649f49d69165ed9ec458a675b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48cf0bd4ad1b6e820699ab1edb1318e6"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga48cf0bd4ad1b6e820699ab1edb1318e6">cpl_table_get_data_string</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga48cf0bd4ad1b6e820699ab1edb1318e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <em>string</em> column data.  <a href="group__cpl__table.html#ga48cf0bd4ad1b6e820699ab1edb1318e6">More...</a><br /></td></tr>
<tr class="separator:ga48cf0bd4ad1b6e820699ab1edb1318e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953b39968f6d156e556da81ac93d9ef1"><td class="memItemLeft" align="right" valign="top">const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga953b39968f6d156e556da81ac93d9ef1">cpl_table_get_data_string_const</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga953b39968f6d156e556da81ac93d9ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to constant <em>string</em> column data.  <a href="group__cpl__table.html#ga953b39968f6d156e556da81ac93d9ef1">More...</a><br /></td></tr>
<tr class="separator:ga953b39968f6d156e556da81ac93d9ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60756f14cf5231b205345e3ab85422ee"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga60756f14cf5231b205345e3ab85422ee">cpl_table_get_double</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, int *null)</td></tr>
<tr class="memdesc:ga60756f14cf5231b205345e3ab85422ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>double</em> column.  <a href="group__cpl__table.html#ga60756f14cf5231b205345e3ab85422ee">More...</a><br /></td></tr>
<tr class="separator:ga60756f14cf5231b205345e3ab85422ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed133467e289a4c84393d104948d5c1d"><td class="memItemLeft" align="right" valign="top">double complex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaed133467e289a4c84393d104948d5c1d">cpl_table_get_double_complex</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, int *null)</td></tr>
<tr class="memdesc:gaed133467e289a4c84393d104948d5c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>double</em> complex column.  <a href="group__cpl__table.html#gaed133467e289a4c84393d104948d5c1d">More...</a><br /></td></tr>
<tr class="separator:gaed133467e289a4c84393d104948d5c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf275203e48d2208e8f1a6a26c4b5b751"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaf275203e48d2208e8f1a6a26c4b5b751">cpl_table_get_float</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, int *null)</td></tr>
<tr class="memdesc:gaf275203e48d2208e8f1a6a26c4b5b751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>float</em> column.  <a href="group__cpl__table.html#gaf275203e48d2208e8f1a6a26c4b5b751">More...</a><br /></td></tr>
<tr class="separator:gaf275203e48d2208e8f1a6a26c4b5b751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd6c102f7ab11338dd95ad5141babc3"><td class="memItemLeft" align="right" valign="top">float complex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga9cd6c102f7ab11338dd95ad5141babc3">cpl_table_get_float_complex</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, int *null)</td></tr>
<tr class="memdesc:ga9cd6c102f7ab11338dd95ad5141babc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>float</em> complex column.  <a href="group__cpl__table.html#ga9cd6c102f7ab11338dd95ad5141babc3">More...</a><br /></td></tr>
<tr class="separator:ga9cd6c102f7ab11338dd95ad5141babc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a806d7ca9db041bbf3d276c9f8e2918"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga2a806d7ca9db041bbf3d276c9f8e2918">cpl_table_get_int</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, int *null)</td></tr>
<tr class="memdesc:ga2a806d7ca9db041bbf3d276c9f8e2918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from an <em>integer</em> column.  <a href="group__cpl__table.html#ga2a806d7ca9db041bbf3d276c9f8e2918">More...</a><br /></td></tr>
<tr class="separator:ga2a806d7ca9db041bbf3d276c9f8e2918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3efdea8811dbcb40a917b783a01b18f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gac3efdea8811dbcb40a917b783a01b18f">cpl_table_get_long</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, int *null)</td></tr>
<tr class="memdesc:gac3efdea8811dbcb40a917b783a01b18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>long</em> column.  <a href="group__cpl__table.html#gac3efdea8811dbcb40a917b783a01b18f">More...</a><br /></td></tr>
<tr class="separator:gac3efdea8811dbcb40a917b783a01b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152f94ecbb6a49e2e7865f7277d7bd97"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga152f94ecbb6a49e2e7865f7277d7bd97">cpl_table_get_long_long</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, int *null)</td></tr>
<tr class="memdesc:ga152f94ecbb6a49e2e7865f7277d7bd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>long</em> <em>long</em> column.  <a href="group__cpl__table.html#ga152f94ecbb6a49e2e7865f7277d7bd97">More...</a><br /></td></tr>
<tr class="separator:ga152f94ecbb6a49e2e7865f7277d7bd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec958c1ed4794abf6b4a814a7063dfb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol</a> (const cpl_table *table)</td></tr>
<tr class="memdesc:gaec958c1ed4794abf6b4a814a7063dfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of columns in a table.  <a href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">More...</a><br /></td></tr>
<tr class="separator:gaec958c1ed4794abf6b4a814a7063dfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cf8e19056beaa8d9350806c58e7da4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga98cf8e19056beaa8d9350806c58e7da4">cpl_table_get_nrow</a> (const cpl_table *table)</td></tr>
<tr class="memdesc:ga98cf8e19056beaa8d9350806c58e7da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of rows in a table.  <a href="group__cpl__table.html#ga98cf8e19056beaa8d9350806c58e7da4">More...</a><br /></td></tr>
<tr class="separator:ga98cf8e19056beaa8d9350806c58e7da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec49fa526d1e8d827025921c93539691"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaec49fa526d1e8d827025921c93539691">cpl_table_get_string</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row)</td></tr>
<tr class="memdesc:gaec49fa526d1e8d827025921c93539691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a <em>string</em> column.  <a href="group__cpl__table.html#gaec49fa526d1e8d827025921c93539691">More...</a><br /></td></tr>
<tr class="separator:gaec49fa526d1e8d827025921c93539691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d8bc681c82a78b369a1804cd12590d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga1d8bc681c82a78b369a1804cd12590d9">cpl_table_has_column</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga1d8bc681c82a78b369a1804cd12590d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a column with a given name exists.  <a href="group__cpl__table.html#ga1d8bc681c82a78b369a1804cd12590d9">More...</a><br /></td></tr>
<tr class="separator:ga1d8bc681c82a78b369a1804cd12590d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb66243e92bbcada184691ab12d27e83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gabb66243e92bbcada184691ab12d27e83">cpl_table_has_invalid</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gabb66243e92bbcada184691ab12d27e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a column contains at least one invalid value.  <a href="group__cpl__table.html#gabb66243e92bbcada184691ab12d27e83">More...</a><br /></td></tr>
<tr class="separator:gabb66243e92bbcada184691ab12d27e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c0b33a617d6110efea6e3878987d6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga92c0b33a617d6110efea6e3878987d6c">cpl_table_has_valid</a> (const cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga92c0b33a617d6110efea6e3878987d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a column contains at least one valid value.  <a href="group__cpl__table.html#ga92c0b33a617d6110efea6e3878987d6c">More...</a><br /></td></tr>
<tr class="separator:ga92c0b33a617d6110efea6e3878987d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84696626a9695cbba896e3bcfc55b81a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga84696626a9695cbba896e3bcfc55b81a">cpl_table_imag_column</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga84696626a9695cbba896e3bcfc55b81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the imaginary part value of table column elements.  <a href="group__cpl__table.html#ga84696626a9695cbba896e3bcfc55b81a">More...</a><br /></td></tr>
<tr class="separator:ga84696626a9695cbba896e3bcfc55b81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0df354714c7494dd322060300fe7f2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gad0df354714c7494dd322060300fe7f2b">cpl_table_insert</a> (cpl_table *target_table, const cpl_table *insert_table, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row)</td></tr>
<tr class="memdesc:gad0df354714c7494dd322060300fe7f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two tables.  <a href="group__cpl__table.html#gad0df354714c7494dd322060300fe7f2b">More...</a><br /></td></tr>
<tr class="separator:gad0df354714c7494dd322060300fe7f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0a1d35143d200b5ad1202672e10332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga5a0a1d35143d200b5ad1202672e10332">cpl_table_insert_window</a> (cpl_table *table, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count)</td></tr>
<tr class="memdesc:ga5a0a1d35143d200b5ad1202672e10332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a segment of rows into table data.  <a href="group__cpl__table.html#ga5a0a1d35143d200b5ad1202672e10332">More...</a><br /></td></tr>
<tr class="separator:ga5a0a1d35143d200b5ad1202672e10332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce482a459d1fb56e320c5e37317c59d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gadce482a459d1fb56e320c5e37317c59d">cpl_table_is_selected</a> (const cpl_table *table, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row)</td></tr>
<tr class="memdesc:gadce482a459d1fb56e320c5e37317c59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a table row is selected or not.  <a href="group__cpl__table.html#gadce482a459d1fb56e320c5e37317c59d">More...</a><br /></td></tr>
<tr class="separator:gadce482a459d1fb56e320c5e37317c59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d95d1733be04798e771606a8a0cf8c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga1d95d1733be04798e771606a8a0cf8c3">cpl_table_is_valid</a> (const cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row)</td></tr>
<tr class="memdesc:ga1d95d1733be04798e771606a8a0cf8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a column element is valid.  <a href="group__cpl__table.html#ga1d95d1733be04798e771606a8a0cf8c3">More...</a><br /></td></tr>
<tr class="separator:ga1d95d1733be04798e771606a8a0cf8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7b1359331cb50e0a095bafb9d7d1caf"><td class="memItemLeft" align="right" valign="top">cpl_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gab7b1359331cb50e0a095bafb9d7d1caf">cpl_table_load</a> (const char *filename, int xtnum, int check_nulls)</td></tr>
<tr class="memdesc:gab7b1359331cb50e0a095bafb9d7d1caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a FITS table extension into a new <em>cpl_table</em>.  <a href="group__cpl__table.html#gab7b1359331cb50e0a095bafb9d7d1caf">More...</a><br /></td></tr>
<tr class="separator:gab7b1359331cb50e0a095bafb9d7d1caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34555be42ae8fd148c454b4107d5dabf"><td class="memItemLeft" align="right" valign="top">cpl_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga34555be42ae8fd148c454b4107d5dabf">cpl_table_load_window</a> (const char *filename, int xtnum, int check_nulls, const cpl_array *selcol, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> firstrow, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> nrow)</td></tr>
<tr class="memdesc:ga34555be42ae8fd148c454b4107d5dabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load part of a FITS table extension into a new <em>cpl_table</em>.  <a href="group__cpl__table.html#ga34555be42ae8fd148c454b4107d5dabf">More...</a><br /></td></tr>
<tr class="separator:ga34555be42ae8fd148c454b4107d5dabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d14bac002b235d78b258dfc9341797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaf8d14bac002b235d78b258dfc9341797">cpl_table_logarithm_column</a> (cpl_table *table, const char *name, double base)</td></tr>
<tr class="memdesc:gaf8d14bac002b235d78b258dfc9341797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logarithm of column values.  <a href="group__cpl__table.html#gaf8d14bac002b235d78b258dfc9341797">More...</a><br /></td></tr>
<tr class="separator:gaf8d14bac002b235d78b258dfc9341797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga902faf4c93198437baadd47d1f485436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga902faf4c93198437baadd47d1f485436">cpl_table_move_column</a> (cpl_table *to_table, const char *name, cpl_table *from_table)</td></tr>
<tr class="memdesc:ga902faf4c93198437baadd47d1f485436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a column from a table to another.  <a href="group__cpl__table.html#ga902faf4c93198437baadd47d1f485436">More...</a><br /></td></tr>
<tr class="separator:ga902faf4c93198437baadd47d1f485436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga364d5a1519ec5ba82a273ea1f22db402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga364d5a1519ec5ba82a273ea1f22db402">cpl_table_multiply_columns</a> (cpl_table *table, const char *to_name, const char *from_name)</td></tr>
<tr class="memdesc:ga364d5a1519ec5ba82a273ea1f22db402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two numeric or complex table columns.  <a href="group__cpl__table.html#ga364d5a1519ec5ba82a273ea1f22db402">More...</a><br /></td></tr>
<tr class="separator:ga364d5a1519ec5ba82a273ea1f22db402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga739c5830d599a411ebe34cdea99582b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga739c5830d599a411ebe34cdea99582b2">cpl_table_multiply_scalar</a> (cpl_table *table, const char *name, double value)</td></tr>
<tr class="memdesc:ga739c5830d599a411ebe34cdea99582b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a numerical or complex column by a constant.  <a href="group__cpl__table.html#ga739c5830d599a411ebe34cdea99582b2">More...</a><br /></td></tr>
<tr class="separator:ga739c5830d599a411ebe34cdea99582b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e78a1ba8e1b3986eece085c440adea1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga7e78a1ba8e1b3986eece085c440adea1">cpl_table_multiply_scalar_complex</a> (cpl_table *table, const char *name, double complex value)</td></tr>
<tr class="memdesc:ga7e78a1ba8e1b3986eece085c440adea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a numerical or complex column by a complex constant.  <a href="group__cpl__table.html#ga7e78a1ba8e1b3986eece085c440adea1">More...</a><br /></td></tr>
<tr class="separator:ga7e78a1ba8e1b3986eece085c440adea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad8efb6812a252e7ef58abc33d48c85c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaad8efb6812a252e7ef58abc33d48c85c">cpl_table_name_column</a> (cpl_table *table, const char *from_name, const char *to_name)</td></tr>
<tr class="memdesc:gaad8efb6812a252e7ef58abc33d48c85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a table column.  <a href="group__cpl__table.html#gaad8efb6812a252e7ef58abc33d48c85c">More...</a><br /></td></tr>
<tr class="separator:gaad8efb6812a252e7ef58abc33d48c85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1037bec8976297a42ca42da2e26f88b4"><td class="memItemLeft" align="right" valign="top">cpl_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga1037bec8976297a42ca42da2e26f88b4">cpl_table_new</a> (<a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> length)</td></tr>
<tr class="memdesc:ga1037bec8976297a42ca42da2e26f88b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty table structure.  <a href="group__cpl__table.html#ga1037bec8976297a42ca42da2e26f88b4">More...</a><br /></td></tr>
<tr class="separator:ga1037bec8976297a42ca42da2e26f88b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bece2b610c28f279984da0b126939a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga8bece2b610c28f279984da0b126939a1">cpl_table_new_column</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a> type)</td></tr>
<tr class="memdesc:ga8bece2b610c28f279984da0b126939a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty column in a table.  <a href="group__cpl__table.html#ga8bece2b610c28f279984da0b126939a1">More...</a><br /></td></tr>
<tr class="separator:ga8bece2b610c28f279984da0b126939a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410ae9cc07353d506b811ea7982b268b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga410ae9cc07353d506b811ea7982b268b">cpl_table_new_column_array</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a> type, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> depth)</td></tr>
<tr class="memdesc:ga410ae9cc07353d506b811ea7982b268b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty column of arrays in a table.  <a href="group__cpl__table.html#ga410ae9cc07353d506b811ea7982b268b">More...</a><br /></td></tr>
<tr class="separator:ga410ae9cc07353d506b811ea7982b268b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57a8c87ae66b61e585dd75f55897d947"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga57a8c87ae66b61e585dd75f55897d947">cpl_table_not_selected</a> (cpl_table *table)</td></tr>
<tr class="memdesc:ga57a8c87ae66b61e585dd75f55897d947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select unselected table rows, and unselect selected ones.  <a href="group__cpl__table.html#ga57a8c87ae66b61e585dd75f55897d947">More...</a><br /></td></tr>
<tr class="separator:ga57a8c87ae66b61e585dd75f55897d947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02a5b5398b7df6db4b1778a3b80b2bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaf02a5b5398b7df6db4b1778a3b80b2bc">cpl_table_or_selected</a> (cpl_table *table, const char *name1, cpl_table_select_operator operator, const char *name2)</td></tr>
<tr class="memdesc:gaf02a5b5398b7df6db4b1778a3b80b2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from unselected table rows, by comparing the values of two numerical columns.  <a href="group__cpl__table.html#gaf02a5b5398b7df6db4b1778a3b80b2bc">More...</a><br /></td></tr>
<tr class="separator:gaf02a5b5398b7df6db4b1778a3b80b2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7eb7ef68e7fa7679be43b00c16130d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gad7eb7ef68e7fa7679be43b00c16130d6">cpl_table_or_selected_double</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, double value)</td></tr>
<tr class="memdesc:gad7eb7ef68e7fa7679be43b00c16130d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from unselected table rows, by comparing <em>double</em> column values with a constant.  <a href="group__cpl__table.html#gad7eb7ef68e7fa7679be43b00c16130d6">More...</a><br /></td></tr>
<tr class="separator:gad7eb7ef68e7fa7679be43b00c16130d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d1d701ac2a9b391ec772545c7d43394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga6d1d701ac2a9b391ec772545c7d43394">cpl_table_or_selected_double_complex</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, double complex value)</td></tr>
<tr class="memdesc:ga6d1d701ac2a9b391ec772545c7d43394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from unselected table rows, by comparing <em>double</em> complex column values with a complex constant.  <a href="group__cpl__table.html#ga6d1d701ac2a9b391ec772545c7d43394">More...</a><br /></td></tr>
<tr class="separator:ga6d1d701ac2a9b391ec772545c7d43394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d961efcfce7846951421618f42e02a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga6d961efcfce7846951421618f42e02a8">cpl_table_or_selected_float</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, float value)</td></tr>
<tr class="memdesc:ga6d961efcfce7846951421618f42e02a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from unselected table rows, by comparing <em>float</em> column values with a constant.  <a href="group__cpl__table.html#ga6d961efcfce7846951421618f42e02a8">More...</a><br /></td></tr>
<tr class="separator:ga6d961efcfce7846951421618f42e02a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a1a4a9e8c9ed35fb50083a602ddd42a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga4a1a4a9e8c9ed35fb50083a602ddd42a">cpl_table_or_selected_float_complex</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, float complex value)</td></tr>
<tr class="memdesc:ga4a1a4a9e8c9ed35fb50083a602ddd42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from unselected table rows, by comparing <em>float</em> complex column values with a complex constant.  <a href="group__cpl__table.html#ga4a1a4a9e8c9ed35fb50083a602ddd42a">More...</a><br /></td></tr>
<tr class="separator:ga4a1a4a9e8c9ed35fb50083a602ddd42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga325bc450c8897b9c1ca9fd25ba32c81c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga325bc450c8897b9c1ca9fd25ba32c81c">cpl_table_or_selected_int</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, int value)</td></tr>
<tr class="memdesc:ga325bc450c8897b9c1ca9fd25ba32c81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from unselected table rows, by comparing <em>integer</em> column values with a constant.  <a href="group__cpl__table.html#ga325bc450c8897b9c1ca9fd25ba32c81c">More...</a><br /></td></tr>
<tr class="separator:ga325bc450c8897b9c1ca9fd25ba32c81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaddaba04bfeb32e00823571b8e0d7256"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaaddaba04bfeb32e00823571b8e0d7256">cpl_table_or_selected_invalid</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:gaaddaba04bfeb32e00823571b8e0d7256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from unselected table rows all rows with an invalid value in a specified column.  <a href="group__cpl__table.html#gaaddaba04bfeb32e00823571b8e0d7256">More...</a><br /></td></tr>
<tr class="separator:gaaddaba04bfeb32e00823571b8e0d7256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f979b45dd821ed7437c62f5c5cefc5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga4f979b45dd821ed7437c62f5c5cefc5c">cpl_table_or_selected_long</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, long value)</td></tr>
<tr class="memdesc:ga4f979b45dd821ed7437c62f5c5cefc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from unselected table rows, by comparing <em>long</em> column values with a constant.  <a href="group__cpl__table.html#ga4f979b45dd821ed7437c62f5c5cefc5c">More...</a><br /></td></tr>
<tr class="separator:ga4f979b45dd821ed7437c62f5c5cefc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0401fac11bbc042c15403849869eaca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga0401fac11bbc042c15403849869eaca7">cpl_table_or_selected_long_long</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, long long value)</td></tr>
<tr class="memdesc:ga0401fac11bbc042c15403849869eaca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from unselected table rows, by comparing <em>long</em> <em>long</em> column values with a constant.  <a href="group__cpl__table.html#ga0401fac11bbc042c15403849869eaca7">More...</a><br /></td></tr>
<tr class="separator:ga0401fac11bbc042c15403849869eaca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7669bb19a22ce09e8e956817b42ff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga5e7669bb19a22ce09e8e956817b42ff6">cpl_table_or_selected_string</a> (cpl_table *table, const char *name, cpl_table_select_operator operator, const char *string)</td></tr>
<tr class="memdesc:ga5e7669bb19a22ce09e8e956817b42ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from unselected table rows, by comparing column values with a constant.  <a href="group__cpl__table.html#ga5e7669bb19a22ce09e8e956817b42ff6">More...</a><br /></td></tr>
<tr class="separator:ga5e7669bb19a22ce09e8e956817b42ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c40efe7b94ea825c20a7e6f9cb65ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga08c40efe7b94ea825c20a7e6f9cb65ed">cpl_table_or_selected_window</a> (cpl_table *table, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count)</td></tr>
<tr class="memdesc:ga08c40efe7b94ea825c20a7e6f9cb65ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select from unselected rows only those within a table segment.  <a href="group__cpl__table.html#ga08c40efe7b94ea825c20a7e6f9cb65ed">More...</a><br /></td></tr>
<tr class="separator:ga08c40efe7b94ea825c20a7e6f9cb65ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e277e4307ddd1f7122204ce7f20f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaf1e277e4307ddd1f7122204ce7f20f80">cpl_table_power_column</a> (cpl_table *table, const char *name, double exponent)</td></tr>
<tr class="memdesc:gaf1e277e4307ddd1f7122204ce7f20f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the power of numerical column values.  <a href="group__cpl__table.html#gaf1e277e4307ddd1f7122204ce7f20f80">More...</a><br /></td></tr>
<tr class="separator:gaf1e277e4307ddd1f7122204ce7f20f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70d7631c3956d7e811be1d5e5ab8fad2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga70d7631c3956d7e811be1d5e5ab8fad2">cpl_table_real_column</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga70d7631c3956d7e811be1d5e5ab8fad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the real part value of table column elements.  <a href="group__cpl__table.html#ga70d7631c3956d7e811be1d5e5ab8fad2">More...</a><br /></td></tr>
<tr class="separator:ga70d7631c3956d7e811be1d5e5ab8fad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f74c8d7e280b0676d890f48a7b48977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga0f74c8d7e280b0676d890f48a7b48977">cpl_table_save</a> (const cpl_table *table, const <a class="el" href="group__cpl__propertylist.html#gab1629461e5d64dd8594cd505e3ea46ab">cpl_propertylist</a> *pheader, const <a class="el" href="group__cpl__propertylist.html#gab1629461e5d64dd8594cd505e3ea46ab">cpl_propertylist</a> *header, const char *filename, unsigned mode)</td></tr>
<tr class="memdesc:ga0f74c8d7e280b0676d890f48a7b48977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a <em>cpl_table</em> to a FITS file.  <a href="group__cpl__table.html#ga0f74c8d7e280b0676d890f48a7b48977">More...</a><br /></td></tr>
<tr class="separator:ga0f74c8d7e280b0676d890f48a7b48977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70887311ad5f8204315c224517e50cab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga70887311ad5f8204315c224517e50cab">cpl_table_select_all</a> (cpl_table *table)</td></tr>
<tr class="memdesc:ga70887311ad5f8204315c224517e50cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select all table rows.  <a href="group__cpl__table.html#ga70887311ad5f8204315c224517e50cab">More...</a><br /></td></tr>
<tr class="separator:ga70887311ad5f8204315c224517e50cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaba2ece26c596b6c0084d2d38096ede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaaaba2ece26c596b6c0084d2d38096ede">cpl_table_select_row</a> (cpl_table *table, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row)</td></tr>
<tr class="memdesc:gaaaba2ece26c596b6c0084d2d38096ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag a table row as selected.  <a href="group__cpl__table.html#gaaaba2ece26c596b6c0084d2d38096ede">More...</a><br /></td></tr>
<tr class="separator:gaaaba2ece26c596b6c0084d2d38096ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca7c44d01dd266c65057e7c43bb4b8ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaca7c44d01dd266c65057e7c43bb4b8ed">cpl_table_set</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, double value)</td></tr>
<tr class="memdesc:gaca7c44d01dd266c65057e7c43bb4b8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a numerical table column element.  <a href="group__cpl__table.html#gaca7c44d01dd266c65057e7c43bb4b8ed">More...</a><br /></td></tr>
<tr class="separator:gaca7c44d01dd266c65057e7c43bb4b8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga506a2e3a103198edcb2fd5a79480a75a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga506a2e3a103198edcb2fd5a79480a75a">cpl_table_set_array</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, const cpl_array *array)</td></tr>
<tr class="memdesc:ga506a2e3a103198edcb2fd5a79480a75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an array to an <em>array</em> table column element.  <a href="group__cpl__table.html#ga506a2e3a103198edcb2fd5a79480a75a">More...</a><br /></td></tr>
<tr class="separator:ga506a2e3a103198edcb2fd5a79480a75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df89d3fd9ce5aebdfd018d4d0e968eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga7df89d3fd9ce5aebdfd018d4d0e968eb">cpl_table_set_column_depth</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> depth)</td></tr>
<tr class="memdesc:ga7df89d3fd9ce5aebdfd018d4d0e968eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify depth of a column of arrays.  <a href="group__cpl__table.html#ga7df89d3fd9ce5aebdfd018d4d0e968eb">More...</a><br /></td></tr>
<tr class="separator:ga7df89d3fd9ce5aebdfd018d4d0e968eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058c918b739f1020af64ca02c6f5a9be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga058c918b739f1020af64ca02c6f5a9be">cpl_table_set_column_dimensions</a> (cpl_table *table, const char *name, const cpl_array *dimensions)</td></tr>
<tr class="memdesc:ga058c918b739f1020af64ca02c6f5a9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the dimensions of a table column of arrays.  <a href="group__cpl__table.html#ga058c918b739f1020af64ca02c6f5a9be">More...</a><br /></td></tr>
<tr class="separator:ga058c918b739f1020af64ca02c6f5a9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5916e21f121e842497d0f4df418a9768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga5916e21f121e842497d0f4df418a9768">cpl_table_set_column_format</a> (cpl_table *table, const char *name, const char *format)</td></tr>
<tr class="memdesc:ga5916e21f121e842497d0f4df418a9768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a new format to a table column.  <a href="group__cpl__table.html#ga5916e21f121e842497d0f4df418a9768">More...</a><br /></td></tr>
<tr class="separator:ga5916e21f121e842497d0f4df418a9768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b6b87265e160eb355a3e2bb6d423e2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d">cpl_table_set_column_invalid</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> start, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> count)</td></tr>
<tr class="memdesc:ga9b6b87265e160eb355a3e2bb6d423e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate a column segment.  <a href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d">More...</a><br /></td></tr>
<tr class="separator:ga9b6b87265e160eb355a3e2bb6d423e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52cb75b79daab6a9356331ec3f60c2a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga52cb75b79daab6a9356331ec3f60c2a7">cpl_table_set_column_unit</a> (cpl_table *table, const char *name, const char *unit)</td></tr>
<tr class="memdesc:ga52cb75b79daab6a9356331ec3f60c2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a new unit to a table column.  <a href="group__cpl__table.html#ga52cb75b79daab6a9356331ec3f60c2a7">More...</a><br /></td></tr>
<tr class="separator:ga52cb75b79daab6a9356331ec3f60c2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga625940482a9c3316d02ee87702385d5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga625940482a9c3316d02ee87702385d5f">cpl_table_set_complex</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, double complex value)</td></tr>
<tr class="memdesc:ga625940482a9c3316d02ee87702385d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a complex value to a complex numerical table column element.  <a href="group__cpl__table.html#ga625940482a9c3316d02ee87702385d5f">More...</a><br /></td></tr>
<tr class="separator:ga625940482a9c3316d02ee87702385d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae6b30390dd403a7ea2a3a4cd1ce8f4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaae6b30390dd403a7ea2a3a4cd1ce8f4f">cpl_table_set_double</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, double value)</td></tr>
<tr class="memdesc:gaae6b30390dd403a7ea2a3a4cd1ce8f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>double</em> table column element.  <a href="group__cpl__table.html#gaae6b30390dd403a7ea2a3a4cd1ce8f4f">More...</a><br /></td></tr>
<tr class="separator:gaae6b30390dd403a7ea2a3a4cd1ce8f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e12227fcd9e1cc3a99697dba99f5bd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga6e12227fcd9e1cc3a99697dba99f5bd3">cpl_table_set_double_complex</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, double complex value)</td></tr>
<tr class="memdesc:ga6e12227fcd9e1cc3a99697dba99f5bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>double</em> complex table column element.  <a href="group__cpl__table.html#ga6e12227fcd9e1cc3a99697dba99f5bd3">More...</a><br /></td></tr>
<tr class="separator:ga6e12227fcd9e1cc3a99697dba99f5bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae498ebf22f6233c3c7e4e61e51fdf65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaae498ebf22f6233c3c7e4e61e51fdf65">cpl_table_set_float</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, float value)</td></tr>
<tr class="memdesc:gaae498ebf22f6233c3c7e4e61e51fdf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>float</em> table column element.  <a href="group__cpl__table.html#gaae498ebf22f6233c3c7e4e61e51fdf65">More...</a><br /></td></tr>
<tr class="separator:gaae498ebf22f6233c3c7e4e61e51fdf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dca7192d34f1695b637a8548a34969d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga1dca7192d34f1695b637a8548a34969d">cpl_table_set_float_complex</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, float complex value)</td></tr>
<tr class="memdesc:ga1dca7192d34f1695b637a8548a34969d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a <em>float</em> complex table column element.  <a href="group__cpl__table.html#ga1dca7192d34f1695b637a8548a34969d">More...</a><br /></td></tr>
<tr class="separator:ga1dca7192d34f1695b637a8548a34969d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2661451495142c1893c377351ce86ce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga2661451495142c1893c377351ce86ce0">cpl_table_set_int</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, int value)</td></tr>
<tr class="memdesc:ga2661451495142c1893c377351ce86ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to an <em>integer</em> table column element.  <a href="group__cpl__table.html#ga2661451495142c1893c377351ce86ce0">More...</a><br /></td></tr>
<tr class="separator:ga2661451495142c1893c377351ce86ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1c5943ee40c3c71fb2e3634124e970b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b">cpl_table_set_invalid</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row)</td></tr>
<tr class="memdesc:gab1c5943ee40c3c71fb2e3634124e970b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag a column element as invalid.  <a href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b">More...</a><br /></td></tr>
<tr class="separator:gab1c5943ee40c3c71fb2e3634124e970b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf41fbef5f14437f50279b0cad416250"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gadf41fbef5f14437f50279b0cad416250">cpl_table_set_long</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, long value)</td></tr>
<tr class="memdesc:gadf41fbef5f14437f50279b0cad416250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to an <em>long</em> table column element.  <a href="group__cpl__table.html#gadf41fbef5f14437f50279b0cad416250">More...</a><br /></td></tr>
<tr class="separator:gadf41fbef5f14437f50279b0cad416250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a0be2532142967c89f2b6e424e205a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga9a0be2532142967c89f2b6e424e205a3">cpl_table_set_long_long</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, long long value)</td></tr>
<tr class="memdesc:ga9a0be2532142967c89f2b6e424e205a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to an <em>long</em> <em>long</em> table column element.  <a href="group__cpl__table.html#ga9a0be2532142967c89f2b6e424e205a3">More...</a><br /></td></tr>
<tr class="separator:ga9a0be2532142967c89f2b6e424e205a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa139114ea5112984ef62fb95e6da33ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaa139114ea5112984ef62fb95e6da33ae">cpl_table_set_size</a> (cpl_table *table, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> new_length)</td></tr>
<tr class="memdesc:gaa139114ea5112984ef62fb95e6da33ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a table to a new number of rows.  <a href="group__cpl__table.html#gaa139114ea5112984ef62fb95e6da33ae">More...</a><br /></td></tr>
<tr class="separator:gaa139114ea5112984ef62fb95e6da33ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67725799ee9368dfb58f9650713a867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaf67725799ee9368dfb58f9650713a867">cpl_table_set_string</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row, const char *value)</td></tr>
<tr class="memdesc:gaf67725799ee9368dfb58f9650713a867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a character string to a <em>string</em> table column element.  <a href="group__cpl__table.html#gaf67725799ee9368dfb58f9650713a867">More...</a><br /></td></tr>
<tr class="separator:gaf67725799ee9368dfb58f9650713a867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab92d31d871ee1a0b4d5326eabe1e2479"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gab92d31d871ee1a0b4d5326eabe1e2479">cpl_table_shift_column</a> (cpl_table *table, const char *name, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> shift)</td></tr>
<tr class="memdesc:gab92d31d871ee1a0b4d5326eabe1e2479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the position of numeric or complex column values.  <a href="group__cpl__table.html#gab92d31d871ee1a0b4d5326eabe1e2479">More...</a><br /></td></tr>
<tr class="separator:gab92d31d871ee1a0b4d5326eabe1e2479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ab7c9854c84aa8de64e2653d34d310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gae0ab7c9854c84aa8de64e2653d34d310">cpl_table_sort</a> (cpl_table *table, const <a class="el" href="group__cpl__propertylist.html#gab1629461e5d64dd8594cd505e3ea46ab">cpl_propertylist</a> *reflist)</td></tr>
<tr class="memdesc:gae0ab7c9854c84aa8de64e2653d34d310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort table rows according to columns values.  <a href="group__cpl__table.html#gae0ab7c9854c84aa8de64e2653d34d310">More...</a><br /></td></tr>
<tr class="separator:gae0ab7c9854c84aa8de64e2653d34d310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18a1cdd93f6fefd5a33e662f9e1df9ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga18a1cdd93f6fefd5a33e662f9e1df9ef">cpl_table_subtract_columns</a> (cpl_table *table, const char *to_name, const char *from_name)</td></tr>
<tr class="memdesc:ga18a1cdd93f6fefd5a33e662f9e1df9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two numeric or complex table columns.  <a href="group__cpl__table.html#ga18a1cdd93f6fefd5a33e662f9e1df9ef">More...</a><br /></td></tr>
<tr class="separator:ga18a1cdd93f6fefd5a33e662f9e1df9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa947c64513c1e72bb7f9524c77b383d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gafa947c64513c1e72bb7f9524c77b383d">cpl_table_subtract_scalar</a> (cpl_table *table, const char *name, double value)</td></tr>
<tr class="memdesc:gafa947c64513c1e72bb7f9524c77b383d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant value from a numerical or complex column.  <a href="group__cpl__table.html#gafa947c64513c1e72bb7f9524c77b383d">More...</a><br /></td></tr>
<tr class="separator:gafa947c64513c1e72bb7f9524c77b383d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c1e241b7c3544d4785d6fc0f2318c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gaf1c1e241b7c3544d4785d6fc0f2318c9">cpl_table_subtract_scalar_complex</a> (cpl_table *table, const char *name, double complex value)</td></tr>
<tr class="memdesc:gaf1c1e241b7c3544d4785d6fc0f2318c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant complex value from a numerical or complex column.  <a href="group__cpl__table.html#gaf1c1e241b7c3544d4785d6fc0f2318c9">More...</a><br /></td></tr>
<tr class="separator:gaf1c1e241b7c3544d4785d6fc0f2318c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae35f77711a7fcceb0648d879a4073ec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gae35f77711a7fcceb0648d879a4073ec1">cpl_table_unselect_all</a> (cpl_table *table)</td></tr>
<tr class="memdesc:gae35f77711a7fcceb0648d879a4073ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unselect all table rows.  <a href="group__cpl__table.html#gae35f77711a7fcceb0648d879a4073ec1">More...</a><br /></td></tr>
<tr class="separator:gae35f77711a7fcceb0648d879a4073ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb9aab012cd788cc30c2e742899fbdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga1cb9aab012cd788cc30c2e742899fbdb">cpl_table_unselect_row</a> (cpl_table *table, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> row)</td></tr>
<tr class="memdesc:ga1cb9aab012cd788cc30c2e742899fbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag a table row as unselected.  <a href="group__cpl__table.html#ga1cb9aab012cd788cc30c2e742899fbdb">More...</a><br /></td></tr>
<tr class="separator:ga1cb9aab012cd788cc30c2e742899fbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga493cee1969a8fff7ee9cd80df40d29b7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga493cee1969a8fff7ee9cd80df40d29b7">cpl_table_unwrap</a> (cpl_table *table, const char *name)</td></tr>
<tr class="memdesc:ga493cee1969a8fff7ee9cd80df40d29b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwrap a table column.  <a href="group__cpl__table.html#ga493cee1969a8fff7ee9cd80df40d29b7">More...</a><br /></td></tr>
<tr class="separator:ga493cee1969a8fff7ee9cd80df40d29b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbcd8712863836e78e6960722ae1ab96"><td class="memItemLeft" align="right" valign="top">cpl_array *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gabbcd8712863836e78e6960722ae1ab96">cpl_table_where_selected</a> (const cpl_table *table)</td></tr>
<tr class="memdesc:gabbcd8712863836e78e6960722ae1ab96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get array of indexes to selected table rows.  <a href="group__cpl__table.html#gabbcd8712863836e78e6960722ae1ab96">More...</a><br /></td></tr>
<tr class="separator:gabbcd8712863836e78e6960722ae1ab96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga759812f0f8872e7c6ff978daa89c4697"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga759812f0f8872e7c6ff978daa89c4697">cpl_table_wrap_double</a> (cpl_table *table, double *data, const char *name)</td></tr>
<tr class="memdesc:ga759812f0f8872e7c6ff978daa89c4697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create in table a new <em>double</em> column obtained from existing data.  <a href="group__cpl__table.html#ga759812f0f8872e7c6ff978daa89c4697">More...</a><br /></td></tr>
<tr class="separator:ga759812f0f8872e7c6ff978daa89c4697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab25db3fd9b98bfd2e8927246678f9df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gab25db3fd9b98bfd2e8927246678f9df7">cpl_table_wrap_double_complex</a> (cpl_table *table, double complex *data, const char *name)</td></tr>
<tr class="memdesc:gab25db3fd9b98bfd2e8927246678f9df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create in table a new <em>double</em> complex column from existing data.  <a href="group__cpl__table.html#gab25db3fd9b98bfd2e8927246678f9df7">More...</a><br /></td></tr>
<tr class="separator:gab25db3fd9b98bfd2e8927246678f9df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff16f9ee7e1d009cad25a4f0e6a4609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gafff16f9ee7e1d009cad25a4f0e6a4609">cpl_table_wrap_float</a> (cpl_table *table, float *data, const char *name)</td></tr>
<tr class="memdesc:gafff16f9ee7e1d009cad25a4f0e6a4609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create in table a new <em>float</em> column obtained from existing data.  <a href="group__cpl__table.html#gafff16f9ee7e1d009cad25a4f0e6a4609">More...</a><br /></td></tr>
<tr class="separator:gafff16f9ee7e1d009cad25a4f0e6a4609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f2fc0d2dce1a9a00efb67e23d123c90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga6f2fc0d2dce1a9a00efb67e23d123c90">cpl_table_wrap_float_complex</a> (cpl_table *table, float complex *data, const char *name)</td></tr>
<tr class="memdesc:ga6f2fc0d2dce1a9a00efb67e23d123c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create in table a new <em>float</em> complex column obtained from existing data.  <a href="group__cpl__table.html#ga6f2fc0d2dce1a9a00efb67e23d123c90">More...</a><br /></td></tr>
<tr class="separator:ga6f2fc0d2dce1a9a00efb67e23d123c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb3eaa902753fcfe2141e8fa58698cc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gacb3eaa902753fcfe2141e8fa58698cc6">cpl_table_wrap_int</a> (cpl_table *table, int *data, const char *name)</td></tr>
<tr class="memdesc:gacb3eaa902753fcfe2141e8fa58698cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create in table a new <em>integer</em> column obtained from existing data.  <a href="group__cpl__table.html#gacb3eaa902753fcfe2141e8fa58698cc6">More...</a><br /></td></tr>
<tr class="separator:gacb3eaa902753fcfe2141e8fa58698cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac48f93a714c37cf86ad6cc6ae07f503a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#gac48f93a714c37cf86ad6cc6ae07f503a">cpl_table_wrap_long</a> (cpl_table *table, long *data, const char *name)</td></tr>
<tr class="memdesc:gac48f93a714c37cf86ad6cc6ae07f503a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create in table a new <em>long</em> column obtained from existing data.  <a href="group__cpl__table.html#gac48f93a714c37cf86ad6cc6ae07f503a">More...</a><br /></td></tr>
<tr class="separator:gac48f93a714c37cf86ad6cc6ae07f503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e6e8ba79efaabab49b3a45524b853fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga4e6e8ba79efaabab49b3a45524b853fc">cpl_table_wrap_long_long</a> (cpl_table *table, long long *data, const char *name)</td></tr>
<tr class="memdesc:ga4e6e8ba79efaabab49b3a45524b853fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create in table a new <em>long</em> <em>long</em> column obtained from existing data.  <a href="group__cpl__table.html#ga4e6e8ba79efaabab49b3a45524b853fc">More...</a><br /></td></tr>
<tr class="separator:ga4e6e8ba79efaabab49b3a45524b853fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02ba1a4fd4162e31a05d6f737dbf44c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__table.html#ga02ba1a4fd4162e31a05d6f737dbf44c6">cpl_table_wrap_string</a> (cpl_table *table, char **data, const char *name)</td></tr>
<tr class="memdesc:ga02ba1a4fd4162e31a05d6f737dbf44c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create in table a new <em>string</em> column obtained from existing data.  <a href="group__cpl__table.html#ga02ba1a4fd4162e31a05d6f737dbf44c6">More...</a><br /></td></tr>
<tr class="separator:ga02ba1a4fd4162e31a05d6f737dbf44c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module provides functions to create, use, and destroy a <em>cpl_table</em>. A <em>cpl_table</em> is made of columns, and a column consists of an array of elements of a given type. Currently three numerical types are supported, <code>CPL_TYPE_INT</code>, <code>CPL_TYPE_FLOAT</code>, and <code>CPL_TYPE_DOUBLE</code>, plus a type indicating columns containing character strings, <code>CPL_TYPE_STRING</code>. Moreover, it is possible to define columns of arrays, i.e. columns whose elements are arrays of all the basic types listed above. Within the same column all arrays must have the same type and the same length.</p>
<p>A table column is accessed by specifying its name. The ordering of the columns within a table is undefined: a <em>cpl_table</em> is not an n-tuple of columns, but just a set of columns. The N elements of a column are counted from 0 to N-1, with element 0 on top. The set of all the table columns elements with the same index constitutes a table row, and table rows are counted according to the same convention. It is possible to flag each <em>cpl_table</em> row as "selected" or "unselected", and each column element as "valid" or "invalid". Selecting table rows is mainly a way to extract just those table parts fulfilling any given condition, while invalidating column elements is a way to exclude such elements from any computation. A <em>cpl_table</em> is created with all rows selected, and a column is created with all elements invalidated.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>cpl_table</em> pointers specified in the argument list of all the <em>cpl_table</em> functions must point to valid objects: these functions do not perform any check in this sense. Only in the particular case of a <code>NULL</code> pointer the functions will set a <code>CPL_ERROR_NULL_INPUT</code> error code, unless differently specified.</dd></dl>
<dl class="section user"><dt>Synopsis:</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cpl_table.h&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga06fc87d81c62e9abb8790b6e5713c55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06fc87d81c62e9abb8790b6e5713c55b">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga06fc87d81c62e9abb8790b6e5713c55bac69c4ac6a255442fcb9a3b220914ba7a"></a>CPL_DFS_SIGNATURE_NONE&#160;</td><td class="fielddoc"><p>Do not compute any signatures </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06fc87d81c62e9abb8790b6e5713c55badba19502dbe2231579377a716f6a027f"></a>CPL_DFS_SIGNATURE_DATAMD5&#160;</td><td class="fielddoc"><p>Compute the DATAMD5 data hash </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06fc87d81c62e9abb8790b6e5713c55ba010f0a9abed7b7037f1a90707ae78019"></a>CPL_DFS_SIGNATURE_CHECKSUM&#160;</td><td class="fielddoc"><p>Compute FITS standard CHECKSUM and DATASUM </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacd86e2e001bccbb405583fc4633a1553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd86e2e001bccbb405583fc4633a1553">&#9670;&nbsp;</a></span>cpl_table_abs_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_abs_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the absolute value of column values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Table column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is not numerical, or has type array.   </td></tr>
</table>
</dd>
</dl>
<p>Each column element is replaced by its absolute value. Invalid elements are not modified by this operation. If the column is complex, its type will be turned to real (CPL_TYPE_FLOAT_COMPLEX will be changed into CPL_TYPE_FLOAT, and CPL_TYPE_DOUBLE_COMPLEX will be changed into CPL_TYPE_DOUBLE), and any pointer retrieved by calling <code><a class="el" href="group__cpl__table.html#ga8917beee9df147a5173806902e45a5d0" title="Get a pointer to float complex column data.">cpl_table_get_data_float_complex()</a></code> and <code><a class="el" href="group__cpl__array.html#ga3b284ffb554d127566b89f369a7a631a" title="Get a pointer to double complex array data.">cpl_array_get_data_double_complex()</a></code> should be discarded. </p>

</div>
</div>
<a id="gab781fd7d07eeeea0bf35caa742187e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab781fd7d07eeeea0bf35caa742187e4b">&#9670;&nbsp;</a></span>cpl_table_add_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_add_columns </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the values of two numeric or complex table columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">to_name</td><td>Name of target column. </td></tr>
    <tr><td class="paramname">from_name</td><td>Name of source column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or any column name are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with any specified name is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">Any specified column is neither numerical nor complex, or it is an array column.   </td></tr>
</table>
</dd>
</dl>
<p>The columns are summed element by element, and the result of the sum is stored in the target column. The columns' types may differ, and in that case the operation would be performed using the standard C upcasting rules, with a final cast of the result to the target column type. Invalid elements are propagated consistently: if either or both members of the sum are invalid, the result will be invalid too. Underflows and overflows are ignored. </p>

</div>
</div>
<a id="ga883d885ad00da7f95afeb6152b147a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga883d885ad00da7f95afeb6152b147a2d">&#9670;&nbsp;</a></span>cpl_table_add_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_add_scalar </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a constant value to a numerical or complex column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">value</td><td>Value to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex, or it is an array column.   </td></tr>
</table>
</dd>
</dl>
<p>The operation is always performed in double precision, with a final cast of the result to the target column type. Invalid elements are are not modified by this operation. </p>

</div>
</div>
<a id="gadb27b0082baf9ca6b1cdcf22446dbe3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb27b0082baf9ca6b1cdcf22446dbe3b">&#9670;&nbsp;</a></span>cpl_table_add_scalar_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_add_scalar_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a constant complex value to a numerical or complex column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">value</td><td>Value to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex, or it is an array column.   </td></tr>
</table>
</dd>
</dl>
<p>The operation is always performed in double precision, with a final cast of the result to the target column type. Invalid elements are are not modified by this operation. </p>

</div>
</div>
<a id="ga82421625cbea42334ac39706a35c78c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82421625cbea42334ac39706a35c78c7">&#9670;&nbsp;</a></span>cpl_table_and_selected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_and_selected </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from selected table rows, by comparing the values of two numerical columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name1</td><td>Name of first table column. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">name2</td><td>Name of second table column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column names are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with any of the specified names is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">Invalid types for comparison.   </td></tr>
</table>
</dd>
</dl>
<p>Either both columns must be numerical, or they both must be strings. The comparison between strings is lexicographical. Comparison between complex types and array types are not supported.</p>
<p>For all the already selected table rows, the values of the specified columns are compared. The table rows not fulfilling the comparison are unselected. Invalid elements from either columns never fulfill any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, <code>CPL_NOT_LESS_THAN</code>. See also the function <code><a class="el" href="group__cpl__table.html#gaf02a5b5398b7df6db4b1778a3b80b2bc" title="Select from unselected table rows, by comparing the values of two numerical columns.">cpl_table_or_selected()</a></code>. </p>

</div>
</div>
<a id="gad6c70413f91b920b2d69222a55f0ec65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6c70413f91b920b2d69222a55f0ec65">&#9670;&nbsp;</a></span>cpl_table_and_selected_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_and_selected_double </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from selected table rows, by comparing <em>double</em> column values with a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE</code>.   </td></tr>
</table>
</dd>
</dl>
<p>For all the already selected table rows, the values of the specified column are compared with the reference value. All table rows not fulfilling the comparison are unselected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, and <code>CPL_NOT_LESS_THAN</code>. If the table has no rows, no error is set, and 0 is returned. See also the function <code><a class="el" href="group__cpl__table.html#gad7eb7ef68e7fa7679be43b00c16130d6" title="Select from unselected table rows, by comparing double column values with a constant.">cpl_table_or_selected_double()</a></code>. </p>

</div>
</div>
<a id="gaf762d6b431bc22f1d1311d55a7856ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf762d6b431bc22f1d1311d55a7856ac9">&#9670;&nbsp;</a></span>cpl_table_and_selected_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_and_selected_double_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from selected table rows, by comparing <em>double</em> complex column values with a complex constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">Operator other than <code>CPL_EQUAL_TO</code> or <code>CPL_NOT_EQUAL_TO</code> was specified.   </td></tr>
</table>
</dd>
</dl>
<p>For all the already selected table rows, the values of the specified column are compared with the reference value. All table rows not fulfilling the comparison are unselected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code> and <code>CPL_NOT_EQUAL_TO</code>. If the table has no rows, no error is set, and 0 is returned. See also the function <code><a class="el" href="group__cpl__table.html#ga6d1d701ac2a9b391ec772545c7d43394" title="Select from unselected table rows, by comparing double complex column values with a complex constant.">cpl_table_or_selected_double_complex()</a></code>. </p>

</div>
</div>
<a id="gadddb1fec819fbf39abeda2e7c86a16ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadddb1fec819fbf39abeda2e7c86a16ca">&#9670;&nbsp;</a></span>cpl_table_and_selected_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_and_selected_float </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from selected table rows, by comparing <em>float</em> column values with a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>For all the already selected table rows, the values of the specified column are compared with the reference value. All table rows not fulfilling the comparison are unselected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, and <code>CPL_NOT_LESS_THAN</code>. If the table has no rows, no error is set, and 0 is returned. See also the function <code><a class="el" href="group__cpl__table.html#ga6d961efcfce7846951421618f42e02a8" title="Select from unselected table rows, by comparing float column values with a constant.">cpl_table_or_selected_float()</a></code>. </p>

</div>
</div>
<a id="gabef99f98d4a4c50157790ca972c25b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabef99f98d4a4c50157790ca972c25b94">&#9670;&nbsp;</a></span>cpl_table_and_selected_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_and_selected_float_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from selected table rows, by comparing <em>float</em> complex column values with a complex constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT_COMPLEX</code>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">Operator other than <code>CPL_EQUAL_TO</code> or <code>CPL_NOT_EQUAL_TO</code> was specified.   </td></tr>
</table>
</dd>
</dl>
<p>For all the already selected table rows, the values of the specified column are compared with the reference value. All table rows not fulfilling the comparison are unselected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code> and <code>CPL_NOT_EQUAL_TO</code>. If the table has no rows, no error is set, and 0 is returned. See also the function <code><a class="el" href="group__cpl__table.html#ga4a1a4a9e8c9ed35fb50083a602ddd42a" title="Select from unselected table rows, by comparing float complex column values with a complex constant.">cpl_table_or_selected_float_complex()</a></code>. </p>

</div>
</div>
<a id="ga44c47b0c9a46d29d31e3bd6487d33587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44c47b0c9a46d29d31e3bd6487d33587">&#9670;&nbsp;</a></span>cpl_table_and_selected_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_and_selected_int </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from selected table rows, by comparing <em>integer</em> column values with a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_INT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>For all the already selected table rows, the values of the specified column are compared with the reference value. All table rows not fulfilling the comparison are unselected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, and <code>CPL_NOT_LESS_THAN</code>. If the table has no rows, no error is set, and 0 is returned. See also the function <code><a class="el" href="group__cpl__table.html#ga325bc450c8897b9c1ca9fd25ba32c81c" title="Select from unselected table rows, by comparing integer column values with a constant.">cpl_table_or_selected_int()</a></code>. </p>

</div>
</div>
<a id="gaac4c8ccba7e895bacd6fd615e0d5e251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac4c8ccba7e895bacd6fd615e0d5e251">&#9670;&nbsp;</a></span>cpl_table_and_selected_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_and_selected_invalid </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from selected table rows all rows with an invalid value in a specified column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>For all the already selected table rows, all the rows containing valid values at the specified column are unselected. See also the function <code><a class="el" href="group__cpl__table.html#gaaddaba04bfeb32e00823571b8e0d7256" title="Select from unselected table rows all rows with an invalid value in a specified column.">cpl_table_or_selected_invalid()</a></code>. </p>

</div>
</div>
<a id="ga16e29ec76ae16a1b3a331873b4039318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16e29ec76ae16a1b3a331873b4039318">&#9670;&nbsp;</a></span>cpl_table_and_selected_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_and_selected_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from selected table rows, by comparing <em>long</em> column values with a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>For all the already selected table rows, the values of the specified column are compared with the reference value. All table rows not fulfilling the comparison are unselected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, and <code>CPL_NOT_LESS_THAN</code>. If the table has no rows, no error is set, and 0 is returned. See also the function <code><a class="el" href="group__cpl__table.html#ga4f979b45dd821ed7437c62f5c5cefc5c" title="Select from unselected table rows, by comparing long column values with a constant.">cpl_table_or_selected_long()</a></code>. </p>

</div>
</div>
<a id="gac3b53b514f999ed23586e2ce5a279394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3b53b514f999ed23586e2ce5a279394">&#9670;&nbsp;</a></span>cpl_table_and_selected_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_and_selected_long_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from selected table rows, by comparing <em>long</em> <em>long</em> column values with a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>For all the already selected table rows, the values of the specified column are compared with the reference value. All table rows not fulfilling the comparison are unselected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, and <code>CPL_NOT_LESS_THAN</code>. If the table has no rows, no error is set, and 0 is returned. See also the function <code><a class="el" href="group__cpl__table.html#ga0401fac11bbc042c15403849869eaca7" title="Select from unselected table rows, by comparing long long column values with a constant.">cpl_table_or_selected_long_long()</a></code>. </p>

</div>
</div>
<a id="ga44c357e82b40d5f78ae3ec5d1178ee47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44c357e82b40d5f78ae3ec5d1178ee47">&#9670;&nbsp;</a></span>cpl_table_and_selected_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_and_selected_string </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from selected table rows, by comparing <em>string</em> column values with a character string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">string</td><td>Reference character string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_STRING</code>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">Invalid regular expression.   </td></tr>
</table>
</dd>
</dl>
<p>For all the already selected table rows, the values of the specified column are compared with the reference string. The comparison function used is the C standard <code>strcmp()</code>, but in case the relational operators <code>CPL_EQUAL_TO</code> or <code>CPL_NOT_EQUAL_TO</code> are specified, the comparison string is treated as a regular expression. All table rows not fulfilling the comparison are unselected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, and <code>CPL_NOT_LESS_THAN</code>. If the table has no rows, no error is set, and 0 is returned. See also the function <code><a class="el" href="group__cpl__table.html#ga5e7669bb19a22ce09e8e956817b42ff6" title="Select from unselected table rows, by comparing column values with a constant.">cpl_table_or_selected_string()</a></code>. </p>

</div>
</div>
<a id="gaa2494c547d1e8a7e8933114517c90b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2494c547d1e8a7e8933114517c90b2c">&#9670;&nbsp;</a></span>cpl_table_and_selected_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_and_selected_window </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from selected rows only those within a table segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">start</td><td>First row of table segment. </td></tr>
    <tr><td class="paramname">count</td><td>Length of segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
</table>
</dd>
</dl>
<p>All the selected table rows that are outside the specified interval are unselected. If the sum of <em>start</em> and <em>count</em> goes beyond the end of the input table, rows are checked up to the end of the table. See also the function <code><a class="el" href="group__cpl__table.html#ga08c40efe7b94ea825c20a7e6f9cb65ed" title="Select from unselected rows only those within a table segment.">cpl_table_or_selected_window()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0d916ea6a7e198a74863ecd9ea03d733">CPL_ERROR_ACCESS_OUT_OF_RANGE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>.</p>

</div>
</div>
<a id="gab000de212f15f43f1636b8935f36e8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab000de212f15f43f1636b8935f36e8e0">&#9670;&nbsp;</a></span>cpl_table_arg_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_arg_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the phase angle value of table column elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex.   </td></tr>
</table>
</dd>
</dl>
<p>Each column element is replaced by its phase angle value. The phase angle will be in the range of [-pi,pi]. Invalid elements are not modified by this operation. If the column is complex, its type will be turned to real (CPL_TYPE_FLOAT_COMPLEX will be changed into CPL_TYPE_FLOAT, and CPL_TYPE_DOUBLE_COMPLEX will be changed into CPL_TYPE_DOUBLE), and any pointer retrieved by calling <code><a class="el" href="group__cpl__table.html#ga8917beee9df147a5173806902e45a5d0" title="Get a pointer to float complex column data.">cpl_table_get_data_float_complex()</a></code>, <code><a class="el" href="group__cpl__table.html#ga6735ebf8f078b00d846e954f6577c79a" title="Get a pointer to double complex column data.">cpl_table_get_data_double_complex()</a></code>, etc., should be discarded. </p>

</div>
</div>
<a id="ga5a0f43226e027e8ec517e040c0f6fefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a0f43226e027e8ec517e040c0f6fefc">&#9670;&nbsp;</a></span>cpl_table_cast_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_cast_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast a numeric or complex column to a new numeric or complex type column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">from_name</td><td>Name of table column to cast. </td></tr>
    <tr><td class="paramname">to_name</td><td>Name of new table column. </td></tr>
    <tr><td class="paramname">type</td><td>Type of new table column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any of <em>table</em> or <em>from_name</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the specified <em>to_name</em> already exists in <em>table</em>. Note however that <em>to_name</em> equal to <em>from_name</em> is legal (in-place cast).   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>from_name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The specified <em>type</em> is neither numerical nor complex.   </td></tr>
</table>
</dd>
</dl>
<p>A new column of the specified type is created, and the content of the given numeric column is cast to the new type. If the input column type is identical to the specified type the column is duplicated as is done by the function <code><a class="el" href="group__cpl__table.html#ga2d283b2493284945d397e805aa5dd635" title="Copy a column from a table to another.">cpl_table_duplicate_column()</a></code>. Note that a column of arrays is always cast to another column of arrays of the specified type, unless it has depth 1. Consistently, a column of numbers can be cast to a column of arrays of depth 1. Here is a complete summary of how any (legal) <em>type</em> specification would be interpreted, depending on the type of the input column:</p>
<div class="fragment"><div class="line">from_name type = CPL_TYPE_XXX</div>
<div class="line">specified type = CPL_TYPE_XXX</div>
<div class="line">to_name   type = CPL_TYPE_XXX</div>
<div class="line"> </div>
<div class="line">from_name type = CPL_TYPE_XXX | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a></div>
<div class="line">specified type = CPL_TYPE_XXX | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a></div>
<div class="line">to_name   type = CPL_TYPE_XXX | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a></div>
<div class="line"> </div>
<div class="line">from_name type = CPL_TYPE_XXX | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a> (depth &gt; 1)</div>
<div class="line">specified type = CPL_TYPE_XXX</div>
<div class="line">to_name   type = CPL_TYPE_XXX | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a></div>
<div class="line"> </div>
<div class="line">from_name type = CPL_TYPE_XXX | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a> (depth = 1)</div>
<div class="line">specified type = CPL_TYPE_XXX</div>
<div class="line">to_name   type = CPL_TYPE_XXX</div>
<div class="line"> </div>
<div class="line">from_name type = CPL_TYPE_XXX</div>
<div class="line">specified type = CPL_TYPE_XXX | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a></div>
<div class="line">to_name   type = CPL_TYPE_XXX | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a> (depth = 1)</div>
<div class="line"> </div>
<div class="line">from_name type = CPL_TYPE_XXX</div>
<div class="line">specified type = <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a></div>
<div class="line">to_name   type = CPL_TYPE_XXX | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a> (depth = 1)</div>
<div class="line"> </div>
<div class="line">from_name type = CPL_TYPE_XXX</div>
<div class="line">specified type = CPL_TYPE_YYY</div>
<div class="line">to_name   type = CPL_TYPE_YYY</div>
<div class="line"> </div>
<div class="line">from_name type = CPL_TYPE_XXX | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a></div>
<div class="line">specified type = CPL_TYPE_YYY | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a></div>
<div class="line">to_name   type = CPL_TYPE_YYY | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a></div>
<div class="line"> </div>
<div class="line">from_name type = CPL_TYPE_XXX | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a> (depth &gt; 1)</div>
<div class="line">specified type = CPL_TYPE_YYY</div>
<div class="line">to_name   type = CPL_TYPE_YYY | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a></div>
<div class="line"> </div>
<div class="line">from_name type = CPL_TYPE_XXX | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a> (depth = 1)</div>
<div class="line">specified type = CPL_TYPE_YYY</div>
<div class="line">to_name   type = CPL_TYPE_YYY</div>
<div class="line"> </div>
<div class="line">from_name type = CPL_TYPE_XXX</div>
<div class="line">specified type = CPL_TYPE_YYY | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a></div>
<div class="line">to_name   type = CPL_TYPE_YYY | <a class="code" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a> (depth = 1)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If <em>to_name</em> is a NULL pointer, or it is equal to <em>from_name</em>, the cast is done in-place. The pointers to data will change, therefore pointers previously retrieved by <code>cpl_table_get_data_xxx()</code>, should be discarded. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__cpl__plot.html#ga1bb893c5a03596a48f670c2608dc1b94">cpl_plot_column()</a>, and <a class="el" href="group__cpl__plot.html#ga511c1fba8ff96b7bc5ed698ba8ab2d87">cpl_plot_columns()</a>.</p>

</div>
</div>
<a id="gad3d6e80aaaa6c23a6ea33e5b4a3446a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3d6e80aaaa6c23a6ea33e5b4a3446a3">&#9670;&nbsp;</a></span>cpl_table_compare_structure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpl_table_compare_structure </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the structure of two tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table1</td><td>Pointer to a table. </td></tr>
    <tr><td class="paramname">table2</td><td>Pointer to another table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the tables have the same structure, 1 otherwise. In case of error, -1 is returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
</table>
</dd>
</dl>
<p>Two tables have the same structure if they have the same number of columns, with the same names, the same types, and the same units. The order of the columns is not relevant. </p>

<p class="reference">References <a class="el" href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074">cpl_array_delete()</a>, <a class="el" href="group__cpl__array.html#ga93e096fb44e739a98a76159e762af10d">cpl_array_get_string()</a>, <a class="el" href="group__cpl__table.html#ga61f1174b2f53f2e835d64d35dd337d8a">cpl_table_get_column_depth()</a>, <a class="el" href="group__cpl__table.html#gaef76a593a5bfbefdc37553c025537fe8">cpl_table_get_column_names()</a>, <a class="el" href="group__cpl__table.html#ga02d329749056a40390df1555c4021032">cpl_table_get_column_type()</a>, <a class="el" href="group__cpl__table.html#ga4d2166101405f3dd6f6e62adab9c9194">cpl_table_get_column_unit()</a>, <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>, and <a class="el" href="group__cpl__table.html#ga1d8bc681c82a78b369a1804cd12590d9">cpl_table_has_column()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#gad0df354714c7494dd322060300fe7f2b">cpl_table_insert()</a>.</p>

</div>
</div>
<a id="ga3159e272f1ab1334701ceb78c5bfed5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3159e272f1ab1334701ceb78c5bfed5c">&#9670;&nbsp;</a></span>cpl_table_conjugate_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_conjugate_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the complex conjugate of column values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex, or it is integer, or it is an array column.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The input <em>base</em> is not positive.   </td></tr>
</table>
</dd>
</dl>
<p>Each column element is replaced by its complex conjugate. The operation is always performed in double precision, with a final cast of the result to the target column type. Invalid elements are not modified by this operation. </p>

</div>
</div>
<a id="ga07ec4050738eb3c89aba569ad165358d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07ec4050738eb3c89aba569ad165358d">&#9670;&nbsp;</a></span>cpl_table_copy_data_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_copy_data_double </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a table <em>double</em> column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE</code>.   </td></tr>
</table>
</dd>
</dl>
<p>See the description of <code><a class="el" href="group__cpl__table.html#ga4fe57a091b367ded4a30091455a40287" title="Copy existing data to a table integer column.">cpl_table_copy_data_int()</a></code> for details. </p>

</div>
</div>
<a id="ga6b06542776d38795071e1c1143e5fed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b06542776d38795071e1c1143e5fed6">&#9670;&nbsp;</a></span>cpl_table_copy_data_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_copy_data_double_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double complex *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a table <em>double</em> complex column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>.   </td></tr>
</table>
</dd>
</dl>
<p>See the description of <code><a class="el" href="group__cpl__table.html#ga4fe57a091b367ded4a30091455a40287" title="Copy existing data to a table integer column.">cpl_table_copy_data_int()</a></code> for details. </p>

</div>
</div>
<a id="ga3047d1671356d4ebe6159b001f6467b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3047d1671356d4ebe6159b001f6467b7">&#9670;&nbsp;</a></span>cpl_table_copy_data_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_copy_data_float </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a table <em>float</em> column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>See the description of <code><a class="el" href="group__cpl__table.html#ga4fe57a091b367ded4a30091455a40287" title="Copy existing data to a table integer column.">cpl_table_copy_data_int()</a></code> for details. </p>

</div>
</div>
<a id="gacaa8bb5bb7e7cff06f490bb91c8d056b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaa8bb5bb7e7cff06f490bb91c8d056b">&#9670;&nbsp;</a></span>cpl_table_copy_data_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_copy_data_float_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float complex *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a table <em>float</em> complex column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT_COMPLEX</code>.   </td></tr>
</table>
</dd>
</dl>
<p>See the description of <code><a class="el" href="group__cpl__table.html#ga4fe57a091b367ded4a30091455a40287" title="Copy existing data to a table integer column.">cpl_table_copy_data_int()</a></code> for details. </p>

</div>
</div>
<a id="ga4fe57a091b367ded4a30091455a40287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fe57a091b367ded4a30091455a40287">&#9670;&nbsp;</a></span>cpl_table_copy_data_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_copy_data_int </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a table <em>integer</em> column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_INT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>The input data values are copied to the specified column. The size of the input array is not checked in any way, and it is expected to be compatible with the number of rows in the given table. The copied data values are all taken as valid: invalid values should be marked using the functions <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code> and <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code>. </p>

</div>
</div>
<a id="ga201e5c5406192702faeb053a3d951f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga201e5c5406192702faeb053a3d951f4e">&#9670;&nbsp;</a></span>cpl_table_copy_data_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_copy_data_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a table <em>long</em> column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>See the description of <code><a class="el" href="group__cpl__table.html#ga4fe57a091b367ded4a30091455a40287" title="Copy existing data to a table integer column.">cpl_table_copy_data_int()</a></code> for details. </p>

</div>
</div>
<a id="ga515eaf86d9b9cba708a8dd6befea0f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga515eaf86d9b9cba708a8dd6befea0f5e">&#9670;&nbsp;</a></span>cpl_table_copy_data_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_copy_data_long_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a table <em>long</em> <em>long</em> column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>See the description of <code><a class="el" href="group__cpl__table.html#ga4fe57a091b367ded4a30091455a40287" title="Copy existing data to a table integer column.">cpl_table_copy_data_int()</a></code> for details. </p>

</div>
</div>
<a id="gad1d73189a9954720812c35641ee19570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1d73189a9954720812c35641ee19570">&#9670;&nbsp;</a></span>cpl_table_copy_data_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_copy_data_string </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy existing data to a table <em>string</em> column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_STRING</code>.   </td></tr>
</table>
</dd>
</dl>
<p>See the description of <code><a class="el" href="group__cpl__table.html#ga4fe57a091b367ded4a30091455a40287" title="Copy existing data to a table integer column.">cpl_table_copy_data_int()</a></code> for details. In the particular case of a string column, it should be noted that the data are copied in-depth, i.e., also the pointed strings are duplicated. Strings contained in the existing table column are deallocated before being replaced by the new ones. </p>

</div>
</div>
<a id="ga86dc059191d3a5b42832fcfcf8efbea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86dc059191d3a5b42832fcfcf8efbea2">&#9670;&nbsp;</a></span>cpl_table_copy_structure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_copy_structure </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>mtable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give to a table the same structure of another table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to empty table. </td></tr>
    <tr><td class="paramname">mtable</td><td>Pointer to model table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> in case of success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>table</em> contains columns.   </td></tr>
</table>
</dd>
</dl>
<p>This function assignes to a columnless table the same column structure (names, types, units) of a given model table. All columns are physically created in the new table, and they are initialised to contain just invalid elements. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>, <a class="el" href="group__cpl__table.html#ga8bece2b610c28f279984da0b126939a1">cpl_table_new_column()</a>, <a class="el" href="group__cpl__table.html#ga410ae9cc07353d506b811ea7982b268b">cpl_table_new_column_array()</a>, <a class="el" href="group__cpl__table.html#ga5916e21f121e842497d0f4df418a9768">cpl_table_set_column_format()</a>, <a class="el" href="group__cpl__table.html#ga52cb75b79daab6a9356331ec3f60c2a7">cpl_table_set_column_unit()</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#gae709603ee26fdd0abdb11f50c8c64e36">cpl_table_extract_selected()</a>.</p>

</div>
</div>
<a id="ga9ea43461bc9128d44622f747d92582d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ea43461bc9128d44622f747d92582d4">&#9670;&nbsp;</a></span>cpl_table_count_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_count_invalid </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count number of invalid values in a table column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to examine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of invalid elements in a table column, or -1 in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Count number of invalid elements in a table column. </p>

<p class="reference">Referenced by <a class="el" href="group__cpl__plot.html#ga1bb893c5a03596a48f670c2608dc1b94">cpl_plot_column()</a>.</p>

</div>
</div>
<a id="ga51e75173e3bc6cb8027d8df403bbc405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51e75173e3bc6cb8027d8df403bbc405">&#9670;&nbsp;</a></span>cpl_table_count_selected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_count_selected </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of selected rows in given table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
</table>
</dd>
</dl>
<p>Get number of selected rows in given table. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga7fa13d6c00a323556c31bd531d6dc00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fa13d6c00a323556c31bd531d6dc00c">&#9670;&nbsp;</a></span>cpl_table_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpl_table_delete </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function deletes a table, releasing all the memory associated to it, including any existing column. If <em>table</em> is <code>NULL</code>, nothing is done, and no error is set. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>, and <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__plot.html#ga1bb893c5a03596a48f670c2608dc1b94">cpl_plot_column()</a>.</p>

</div>
</div>
<a id="gaa96082bfb779453aa046af2c22007dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa96082bfb779453aa046af2c22007dc3">&#9670;&nbsp;</a></span>cpl_table_divide_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_divide_columns </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide two numeric or complex table columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">to_name</td><td>Name of target column. </td></tr>
    <tr><td class="paramname">from_name</td><td>Name of column dividing the target column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or any column name are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with any specified name is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">Any specified column is neither numerical nor complex, or it is an array column.   </td></tr>
</table>
</dd>
</dl>
<p>The columns are divided element by element, and the result of the division is stored in the target column. The columns' types may differ, and in that case the operation would be performed using the standard C upcasting rules, with a final cast of the result to the target column type. Invalid elements are propagated consistently: if either or both members of the division are invalid, the result will be invalid too. Underflows and overflows are ignored, but a division by exactly zero will set an invalid column element. </p>

</div>
</div>
<a id="ga96ed9107604e45cc14e3d0b71a447ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96ed9107604e45cc14e3d0b71a447ac5">&#9670;&nbsp;</a></span>cpl_table_divide_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_divide_scalar </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide a numerical or complex column by a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">value</td><td>Divisor value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex, or it is an array column.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DIVISION_BY_ZERO </td><td class="ecr">The input <em>value</em> is 0.0.   </td></tr>
</table>
</dd>
</dl>
<p>The operation is always performed in double precision, with a final cast of the result to the target column type. Invalid elements are not modified by this operation. </p>

</div>
</div>
<a id="ga87d11a62cf023f89f4dfabc470a5a7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87d11a62cf023f89f4dfabc470a5a7e6">&#9670;&nbsp;</a></span>cpl_table_divide_scalar_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_divide_scalar_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide a numerical or complex column by a complex constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">value</td><td>Divisor value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex, or it is an array column.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DIVISION_BY_ZERO </td><td class="ecr">The input <em>value</em> is 0.0.   </td></tr>
</table>
</dd>
</dl>
<p>The operation is always performed in double precision, with a final cast of the result to the target column type. Invalid elements are not modified by this operation. </p>

</div>
</div>
<a id="gacd790a348822ac1e02165c1e2b9435c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd790a348822ac1e02165c1e2b9435c4">&#9670;&nbsp;</a></span>cpl_table_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpl_table_dump </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table </td></tr>
    <tr><td class="paramname">start</td><td>First row to print </td></tr>
    <tr><td class="paramname">count</td><td>Number of rows to print </td></tr>
    <tr><td class="paramname">stream</td><td>The output stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function is mainly intended for debug purposes. All column elements are printed according to the column formats, that may be specified for each table column with the function <code><a class="el" href="group__cpl__table.html#ga5916e21f121e842497d0f4df418a9768" title="Give a new format to a table column.">cpl_table_set_column_format()</a></code>. The default column formats have been chosen to provide a reasonable printout in most cases. Table rows are counted from 0, and their sequence number is printed at the left of each row. Invalid table elements are represented as a sequence of "-" as wide as the field occupied by the column to which they belong. Array elements are not resolved, and are represented by a sequence of "+" as wide as the field occupied by the column to which they belong. It is not shown whether a table row is selected or not. Specifying a <em>start</em> beyond the table boundaries, or a non-positive <em>count</em>, would generate a warning message, but no error would be set. The specified number of rows to print may exceed the table end, and in that case the table would be printed up to its last row. If the specified stream is <code>NULL</code>, it is set to <em>stdout</em>. The function used for printing is the standard C <code>fprintf()</code>. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>, <a class="el" href="group__cpl__memory.html#gac884edcb0a592489c65239d0e5d08785">cpl_malloc()</a>, <a class="el" href="group__cpl__type.html#ga4f6c44a14bbc3aea87b1f47acf8dfd02">CPL_SIZE_FORMAT</a>, and <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>.</p>

</div>
</div>
<a id="gae8ae7c1313f70adaebfd92ad04c9305c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8ae7c1313f70adaebfd92ad04c9305c">&#9670;&nbsp;</a></span>cpl_table_dump_structure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpl_table_dump_structure </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describe the structure and the contents of a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">stream</td><td>The output stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function is mainly intended for debug purposes. Some information about the structure of a table and its contents is printed to terminal:</p>
<ul>
<li>Number of columns, with their names and types</li>
<li>Number of invalid elements for each column</li>
<li>Number of rows and of selected rows</li>
</ul>
<p>If the specified stream is <code>NULL</code>, it is set to <em>stdout</em>. The function used for printing is the standard C <code>fprintf()</code>. </p>

<p class="reference">References <a class="el" href="group__cpl__type.html#ga4f6c44a14bbc3aea87b1f47acf8dfd02">CPL_SIZE_FORMAT</a>, and <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>.</p>

</div>
</div>
<a id="ga49553a682513ffa3ecd943187653dc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49553a682513ffa3ecd943187653dc40">&#9670;&nbsp;</a></span>cpl_table_duplicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_table* cpl_table_duplicate </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a copy of a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new table, or <code>NULL</code> in case of <code>NULL</code> input, or in case of error.</dd></dl>
<p>The copy operation is done "in depth": columns data are duplicated too, not just their pointers. Also the selection flags of the original table are transferred to the new table. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gac884edcb0a592489c65239d0e5d08785">cpl_malloc()</a>, <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>, <a class="el" href="group__cpl__table.html#ga98cf8e19056beaa8d9350806c58e7da4">cpl_table_get_nrow()</a>, and <a class="el" href="group__cpl__table.html#ga1037bec8976297a42ca42da2e26f88b4">cpl_table_new()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#gae709603ee26fdd0abdb11f50c8c64e36">cpl_table_extract_selected()</a>.</p>

</div>
</div>
<a id="ga2d283b2493284945d397e805aa5dd635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d283b2493284945d397e805aa5dd635">&#9670;&nbsp;</a></span>cpl_table_duplicate_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_duplicate_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>to_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>from_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a column from a table to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_table</td><td>Target table. </td></tr>
    <tr><td class="paramname">to_name</td><td>New name of copied column. </td></tr>
    <tr><td class="paramname">from_table</td><td>Source table. </td></tr>
    <tr><td class="paramname">from_name</td><td>Name of column to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INCOMPATIBLE_INPUT </td><td class="ecr">The input tables do not have the same number of rows.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>from_name</em> is not found in the source table.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the specified <em>to_name</em> already exists in the target table.   </td></tr>
</table>
</dd>
</dl>
<p>Copy a column from a table to another. The column is duplicated. A column may be duplicated also within the same table. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__plot.html#ga1bb893c5a03596a48f670c2608dc1b94">cpl_plot_column()</a>, and <a class="el" href="group__cpl__plot.html#ga511c1fba8ff96b7bc5ed698ba8ab2d87">cpl_plot_columns()</a>.</p>

</div>
</div>
<a id="gabdfca1c1b3478ce6bcc3f4340131adba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdfca1c1b3478ce6bcc3f4340131adba">&#9670;&nbsp;</a></span>cpl_table_erase_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_erase_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a column from a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Delete a column from a table. If the table is left without columns, also the selection flags are lost. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#ga397f3c878f110930bfe64b537c5d417c">cpl_table_erase_invalid()</a>, and <a class="el" href="group__cpl__table.html#ga5c318a3f2c02b47e8c1fb4ccc019af1b">cpl_table_erase_invalid_rows()</a>.</p>

</div>
</div>
<a id="ga397f3c878f110930bfe64b537c5d417c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga397f3c878f110930bfe64b537c5d417c">&#9670;&nbsp;</a></span>cpl_table_erase_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_erase_invalid </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove from a table all columns just containing invalid elements, and then all rows containing at least one invalid element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
</table>
</dd>
</dl>
<p>Firstly, all columns consisting just of invalid elements are deleted from the table. Next, the remaining table rows containing at least one invalid element are also deleted from the table. The selection flags are set back to "all selected" even if no rows or columns are erased. The pointers to data may change, therefore pointers previously retrieved by calling <code><a class="el" href="group__cpl__table.html#gaff3998d07c6cbf88d0297648bce6f6f4" title="Get a pointer to integer column data.">cpl_table_get_data_int()</a></code>, etc., should be discarded.</p>
<p>The function is similar to the function <a class="el" href="group__cpl__table.html#ga5c318a3f2c02b47e8c1fb4ccc019af1b" title="Remove from a table columns and rows just containing invalid elements.">cpl_table_erase_invalid_rows()</a>, except for the criteria to remove rows containing invalid elements after all invalid columns have been removed. While <a class="el" href="group__cpl__table.html#ga5c318a3f2c02b47e8c1fb4ccc019af1b" title="Remove from a table columns and rows just containing invalid elements.">cpl_table_erase_invalid_rows()</a> requires all elements to be invalid in order to remove a row from the table, this function requires only one (or more) elements to be invalid.</p>
<dl class="section note"><dt>Note</dt><dd>If the input table just contains invalid elements, all columns are deleted.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__table.html#ga5c318a3f2c02b47e8c1fb4ccc019af1b" title="Remove from a table columns and rows just containing invalid elements.">cpl_table_erase_invalid_rows()</a> </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__table.html#gabdfca1c1b3478ce6bcc3f4340131adba">cpl_table_erase_column()</a>, <a class="el" href="group__cpl__table.html#ga8e3777a49d3efd72eeb137af1c47176e">cpl_table_erase_window()</a>, <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>, <a class="el" href="group__cpl__table.html#ga98cf8e19056beaa8d9350806c58e7da4">cpl_table_get_nrow()</a>, and <a class="el" href="group__cpl__table.html#ga70887311ad5f8204315c224517e50cab">cpl_table_select_all()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__plot.html#ga1bb893c5a03596a48f670c2608dc1b94">cpl_plot_column()</a>.</p>

</div>
</div>
<a id="ga5c318a3f2c02b47e8c1fb4ccc019af1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c318a3f2c02b47e8c1fb4ccc019af1b">&#9670;&nbsp;</a></span>cpl_table_erase_invalid_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_erase_invalid_rows </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove from a table columns and rows just containing invalid elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
</table>
</dd>
</dl>
<p>Table columns and table rows just containing invalid elements are deleted from the table, i.e. a column or a row is deleted only if all of its elements are invalid. The selection flags are set back to "all selected" even if no rows or columns are removed. The pointers to data may change, therefore pointers previously retrieved by <code><a class="el" href="group__cpl__table.html#gaff3998d07c6cbf88d0297648bce6f6f4" title="Get a pointer to integer column data.">cpl_table_get_data_int()</a></code>, <code><a class="el" href="group__cpl__table.html#ga48cf0bd4ad1b6e820699ab1edb1318e6" title="Get a pointer to string column data.">cpl_table_get_data_string()</a></code>, etc., should be discarded.</p>
<dl class="section note"><dt>Note</dt><dd>If the input table just contains invalid elements, all columns are deleted. </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__table.html#gabdfca1c1b3478ce6bcc3f4340131adba">cpl_table_erase_column()</a>, <a class="el" href="group__cpl__table.html#ga8e3777a49d3efd72eeb137af1c47176e">cpl_table_erase_window()</a>, <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>, <a class="el" href="group__cpl__table.html#ga98cf8e19056beaa8d9350806c58e7da4">cpl_table_get_nrow()</a>, and <a class="el" href="group__cpl__table.html#ga70887311ad5f8204315c224517e50cab">cpl_table_select_all()</a>.</p>

</div>
</div>
<a id="gab9b708efb1c519be18d680f26c947d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b708efb1c519be18d680f26c947d8d">&#9670;&nbsp;</a></span>cpl_table_erase_selected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_erase_selected </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the selected rows of a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr"><em>table</em> is a <code>NULL</code> pointer.   </td></tr>
</table>
</dd>
</dl>
<p>A portion of the table data is physically removed. The pointer to column data may change, therefore pointers previously retrieved by calling <code><a class="el" href="group__cpl__table.html#gaff3998d07c6cbf88d0297648bce6f6f4" title="Get a pointer to integer column data.">cpl_table_get_data_int()</a></code>, <code><a class="el" href="group__cpl__table.html#ga48cf0bd4ad1b6e820699ab1edb1318e6" title="Get a pointer to string column data.">cpl_table_get_data_string()</a></code>, etc., should be discarded. The table selection flags are set back to "all selected". </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>, <a class="el" href="group__cpl__table.html#ga98cf8e19056beaa8d9350806c58e7da4">cpl_table_get_nrow()</a>, <a class="el" href="group__cpl__table.html#ga70887311ad5f8204315c224517e50cab">cpl_table_select_all()</a>, and <a class="el" href="group__cpl__table.html#gaa139114ea5112984ef62fb95e6da33ae">cpl_table_set_size()</a>.</p>

</div>
</div>
<a id="ga8e3777a49d3efd72eeb137af1c47176e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e3777a49d3efd72eeb137af1c47176e">&#9670;&nbsp;</a></span>cpl_table_erase_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_erase_window </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a table segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">start</td><td>First row to delete. </td></tr>
    <tr><td class="paramname">count</td><td>Number of rows to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr"><em>table</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input table has length zero, or <em>start</em> is outside the table range.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
</table>
</dd>
</dl>
<p>A portion of the table data is physically removed. The pointers to column data may change, therefore pointers previously retrieved by calling <code><a class="el" href="group__cpl__table.html#gaff3998d07c6cbf88d0297648bce6f6f4" title="Get a pointer to integer column data.">cpl_table_get_data_int()</a></code>, <code><a class="el" href="group__cpl__table.html#ga48cf0bd4ad1b6e820699ab1edb1318e6" title="Get a pointer to string column data.">cpl_table_get_data_string()</a></code>, etc., should be discarded. The table selection flags are set back to "all selected". The specified segment can extend beyond the end of the table, and in that case rows will be removed up to the end of the table. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>, and <a class="el" href="group__cpl__table.html#ga70887311ad5f8204315c224517e50cab">cpl_table_select_all()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#ga397f3c878f110930bfe64b537c5d417c">cpl_table_erase_invalid()</a>, and <a class="el" href="group__cpl__table.html#ga5c318a3f2c02b47e8c1fb4ccc019af1b">cpl_table_erase_invalid_rows()</a>.</p>

</div>
</div>
<a id="ga9494feb58c3cf9daab71c9940d5968d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9494feb58c3cf9daab71c9940d5968d2">&#9670;&nbsp;</a></span>cpl_table_exponential_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_exponential_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the exponential of column values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">base</td><td>Exponential base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex, or it is an array column.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The input <em>base</em> is not positive.   </td></tr>
</table>
</dd>
</dl>
<p>Each column element is replaced by its exponential in the specified base. The operation is always performed in double precision, with a final cast of the result to the target column type. Invalid elements are not modified by this operation. </p>

</div>
</div>
<a id="ga84af52720711c7d4a3ecadce824f47b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84af52720711c7d4a3ecadce824f47b7">&#9670;&nbsp;</a></span>cpl_table_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_table* cpl_table_extract </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a table from a section of another table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">start</td><td>First row to be copied to new table. </td></tr>
    <tr><td class="paramname">count</td><td>Number of rows to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new table, or <code>NULL</code> in case or error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
</table>
</dd>
</dl>
<p>A number of consecutive rows are copied from an input table to a newly created table. The new table will have the same structure of the original table (see function <code><a class="el" href="group__cpl__table.html#gad3d6e80aaaa6c23a6ea33e5b4a3446a3" title="Compare the structure of two tables.">cpl_table_compare_structure()</a></code> ). If the sum of <em>start</em> and <em>count</em> goes beyond the end of the input table, rows are copied up to the end. All the rows of the new table are selected, i.e., existing selection flags are not transferred from the old table to the new one. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>, <a class="el" href="group__cpl__table.html#ga98cf8e19056beaa8d9350806c58e7da4">cpl_table_get_nrow()</a>, and <a class="el" href="group__cpl__table.html#ga1037bec8976297a42ca42da2e26f88b4">cpl_table_new()</a>.</p>

</div>
</div>
<a id="gae709603ee26fdd0abdb11f50c8c64e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae709603ee26fdd0abdb11f50c8c64e36">&#9670;&nbsp;</a></span>cpl_table_extract_selected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_table* cpl_table_extract_selected </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new table from the selected rows of another table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new table, or <code>NULL</code> in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
</table>
</dd>
</dl>
<p>A new table is created, containing a copy of all the selected rows of the input table. In the output table all rows are selected. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__table.html#ga86dc059191d3a5b42832fcfcf8efbea2">cpl_table_copy_structure()</a>, <a class="el" href="group__cpl__table.html#ga49553a682513ffa3ecd943187653dc40">cpl_table_duplicate()</a>, and <a class="el" href="group__cpl__table.html#ga1037bec8976297a42ca42da2e26f88b4">cpl_table_new()</a>.</p>

</div>
</div>
<a id="gaf4cb45bf2ed95b53698e9a5371f311f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4cb45bf2ed95b53698e9a5371f311f3">&#9670;&nbsp;</a></span>cpl_table_fill_column_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_column_window </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a numerical column segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin to write the value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is not numerical, or is of type <em>array</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Write the same value to a numerical column segment. The value is cast to the type of the accessed column according to the C casting rules. The written values are automatically marked as valid. To invalidate a column interval use <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code> instead. If the sum of <em>start</em> and <em>count</em> exceeds the number of table rows, the column is filled up to its end. </p>

</div>
</div>
<a id="ga23ab752473c166bfe541642cf618d065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23ab752473c166bfe541642cf618d065">&#9670;&nbsp;</a></span>cpl_table_fill_column_window_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_column_window_array </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an array to an <em>array</em> column segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin to write the array. </td></tr>
    <tr><td class="paramname">count</td><td>Number of arrays to write. </td></tr>
    <tr><td class="paramname">array</td><td>Array to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column does not match the type of the input <em>array</em>, or it is not made of arrays.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INCOMPATIBLE_INPUT </td><td class="ecr">The size of the input <em>array</em> is different from the depth of the specified column.   </td></tr>
</table>
</dd>
</dl>
<p>Write the same array to a segment of an array column. If the input array is not a <code>NULL</code> pointer, it is duplicated for each accessed column element. If the input array is a <code>NULL</code> pointer, this call is equivalent to a call to <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code>. If the sum of <em>start</em> and <em>count</em> exceeds the number of rows in the table, the column is filled up to its end. </p>

</div>
</div>
<a id="ga57ff6e5a6a9ea0cdfd2e7151098e3a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57ff6e5a6a9ea0cdfd2e7151098e3a38">&#9670;&nbsp;</a></span>cpl_table_fill_column_window_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_column_window_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a complex column segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin to write the value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is not complex, or is of type <em>array</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Write the same value to a complex column segment. The value is cast to the type of the accessed column according to the C casting rules. The written values are automatically marked as valid. To invalidate a column interval use <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code> instead. If the sum of <em>start</em> and <em>count</em> exceeds the number of table rows, the column is filled up to its end. </p>

</div>
</div>
<a id="ga1b730484d1f4a4c260e62e042d1b7d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b730484d1f4a4c260e62e042d1b7d9d">&#9670;&nbsp;</a></span>cpl_table_fill_column_window_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_column_window_double </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>double</em> column segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin to write the value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write the same value to a <em>double</em> column segment. The written values are automatically marked as valid. To invalidate a column interval use <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code> instead. If the sum of <em>start</em> and <em>count</em> exceeds the number of table rows, the column is filled up to its end. </p>

</div>
</div>
<a id="ga91595305eb67001f0d8448bfccfd2215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91595305eb67001f0d8448bfccfd2215">&#9670;&nbsp;</a></span>cpl_table_fill_column_window_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_column_window_double_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>double</em> complex column segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin to write the value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write the same value to a <em>double</em> complex column segment. The written values are automatically marked as valid. To invalidate a column interval use <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code> instead. If the sum of <em>start</em> and <em>count</em> exceeds the number of table rows, the column is filled up to its end. </p>

</div>
</div>
<a id="ga188f2e0565ed4e489364e478e1b5c25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga188f2e0565ed4e489364e478e1b5c25d">&#9670;&nbsp;</a></span>cpl_table_fill_column_window_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_column_window_float </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>float</em> column segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin to write the value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write the same value to a <em>float</em> column segment. The written values are automatically marked as valid. To invalidate a column interval use <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code> instead. If the sum of <em>start</em> and <em>count</em> exceeds the number of table rows, the column is filled up to its end. </p>

</div>
</div>
<a id="ga6bc6d82251e5665043cc25aa4099394e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bc6d82251e5665043cc25aa4099394e">&#9670;&nbsp;</a></span>cpl_table_fill_column_window_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_column_window_float_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>float</em> complex column segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin to write the value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT_COMPLEX</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write the same value to a <em>float</em> complex column segment. The written values are automatically marked as valid. To invalidate a column interval use <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code> instead. If the sum of <em>start</em> and <em>count</em> exceeds the number of table rows, the column is filled up to its end. </p>

</div>
</div>
<a id="gaa4190271c05bd6121a22b53dc3e27bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4190271c05bd6121a22b53dc3e27bfe">&#9670;&nbsp;</a></span>cpl_table_fill_column_window_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_column_window_int </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to an <em>integer</em> column segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin to write the value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_INT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write the same value to an <em>integer</em> column segment. The written values are automatically marked as valid. To invalidate a column interval use <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code> instead. If the sum of <em>start</em> and <em>count</em> exceeds the number of table rows, the column is filled up to its end.</p>
<dl class="section note"><dt>Note</dt><dd>For automatic conversion to the accessed column type use the function <code><a class="el" href="group__cpl__table.html#gaf4cb45bf2ed95b53698e9a5371f311f3" title="Write a value to a numerical column segment.">cpl_table_fill_column_window()</a></code>. </dd></dl>

</div>
</div>
<a id="ga5717104df95162d3cb715060bab74f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5717104df95162d3cb715060bab74f8f">&#9670;&nbsp;</a></span>cpl_table_fill_column_window_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_column_window_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to an <em>long</em> column segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin to write the value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write the same value to an <em>long</em> column segment. The written values are automatically marked as valid. To invalidate a column interval use <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code> instead. If the sum of <em>start</em> and <em>count</em> exceeds the number of table rows, the column is filled up to its end.</p>
<dl class="section note"><dt>Note</dt><dd>For automatic conversion to the accessed column type use the function <code><a class="el" href="group__cpl__table.html#gaf4cb45bf2ed95b53698e9a5371f311f3" title="Write a value to a numerical column segment.">cpl_table_fill_column_window()</a></code>. </dd></dl>

</div>
</div>
<a id="ga312933cb021d6105c183b446ccc59c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga312933cb021d6105c183b446ccc59c0d">&#9670;&nbsp;</a></span>cpl_table_fill_column_window_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_column_window_long_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to an <em>long</em> <em>long</em> column segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin to write the value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write the same value to an <em>long</em> <em>long</em> column segment. The written values are automatically marked as valid. To invalidate a column interval use <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code> instead. If the sum of <em>start</em> and <em>count</em> exceeds the number of table rows, the column is filled up to its end.</p>
<dl class="section note"><dt>Note</dt><dd>For automatic conversion to the accessed column type use the function <code><a class="el" href="group__cpl__table.html#gaf4cb45bf2ed95b53698e9a5371f311f3" title="Write a value to a numerical column segment.">cpl_table_fill_column_window()</a></code>. </dd></dl>

</div>
</div>
<a id="gacfb4459d9ef7b671c25977c8d0f9f3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfb4459d9ef7b671c25977c8d0f9f3c4">&#9670;&nbsp;</a></span>cpl_table_fill_column_window_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_column_window_string </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a character string to a <em>string</em> column segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin to write the character string. </td></tr>
    <tr><td class="paramname">count</td><td>Number of strings to write. </td></tr>
    <tr><td class="paramname">value</td><td>Character string to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_STRING</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write the same value to a <em>string</em> column segment. If the input string is not a <code>NULL</code> pointer, it is duplicated for each accessed column element. If the input string is a <code>NULL</code> pointer, this call is equivalent to a call to <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code>. If the sum of <em>start</em> and <em>count</em> exceeds the number of rows in the table, the column is filled up to its end. </p>

</div>
</div>
<a id="ga5833f6747311fd2c8ccda52702379fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5833f6747311fd2c8ccda52702379fbc">&#9670;&nbsp;</a></span>cpl_table_fill_invalid_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_invalid_double </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a numerical value to invalid <em>double</em> column elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table containing the column. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">code</td><td>Value to write to invalid column elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE</code>, or of type <code>CPL_TYPE_DOUBLE | CPL_TYPE_POINTER</code>.   </td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__table.html#ga0041fc2ebc6cf8c41693298b91a91551" title="Write a numerical value to invalid integer column elements.">cpl_table_fill_invalid_int()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assigning a value to an invalid numerical element will not make it valid, but assigning a value to an element consisting of an array of numbers will make the array element valid. </dd></dl>

</div>
</div>
<a id="ga830a09cfa2504d15aa6eb0d25019eda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga830a09cfa2504d15aa6eb0d25019eda2">&#9670;&nbsp;</a></span>cpl_table_fill_invalid_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_invalid_double_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a numerical value to invalid <em>double</em> complex column elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table containing the column. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">code</td><td>Value to write to invalid column elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>, or of type <code>CPL_TYPE_DOUBLE_COMPLEX | CPL_TYPE_POINTER</code>.   </td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__table.html#ga0041fc2ebc6cf8c41693298b91a91551" title="Write a numerical value to invalid integer column elements.">cpl_table_fill_invalid_int()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assigning a value to an invalid numerical element will not make it valid, but assigning a value to an element consisting of an array of numbers will make the array element valid. </dd></dl>

</div>
</div>
<a id="gaf5bd6ed9bb98fdbab4a79b26f3cf68ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5bd6ed9bb98fdbab4a79b26f3cf68ea">&#9670;&nbsp;</a></span>cpl_table_fill_invalid_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_invalid_float </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a numerical value to invalid <em>float</em> column elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table containing the column. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">code</td><td>Value to write to invalid column elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT</code>, or of type <code>CPL_TYPE_FLOAT | CPL_TYPE_POINTER</code>.   </td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__table.html#ga0041fc2ebc6cf8c41693298b91a91551" title="Write a numerical value to invalid integer column elements.">cpl_table_fill_invalid_int()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assigning a value to an invalid numerical element will not make it valid, but assigning a value to an element consisting of an array of numbers will make the array element valid. </dd></dl>

</div>
</div>
<a id="gaef2f1d812cab0159c4eb1cd212928c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef2f1d812cab0159c4eb1cd212928c4a">&#9670;&nbsp;</a></span>cpl_table_fill_invalid_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_invalid_float_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float complex&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a numerical value to invalid <em>float</em> complex column elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table containing the column. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">code</td><td>Value to write to invalid column elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT_COMPLEX</code>, or of type <code>CPL_TYPE_FLOAT_COMPLEX | CPL_TYPE_POINTER</code>.   </td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__table.html#ga0041fc2ebc6cf8c41693298b91a91551" title="Write a numerical value to invalid integer column elements.">cpl_table_fill_invalid_int()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assigning a value to an invalid numerical element will not make it valid, but assigning a value to an element consisting of an array of numbers will make the array element valid. </dd></dl>

</div>
</div>
<a id="ga0041fc2ebc6cf8c41693298b91a91551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0041fc2ebc6cf8c41693298b91a91551">&#9670;&nbsp;</a></span>cpl_table_fill_invalid_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_invalid_int </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a numerical value to invalid <em>integer</em> column elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table containing the column. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">code</td><td>Value to write to invalid column elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_INT</code>, or of type <code>CPL_TYPE_INT | CPL_TYPE_POINTER</code>.   </td></tr>
</table>
</dd>
</dl>
<p>In general, a numeric column element that is flagged as invalid is undefined and should not be read. It is however sometimes convenient to read such values, f.ex. via calls to <code><a class="el" href="group__cpl__table.html#gaff3998d07c6cbf88d0297648bce6f6f4" title="Get a pointer to integer column data.">cpl_table_get_data_int()</a></code> and memcpy(). In order to avoid that such usage causes uninitialized memory to be read, the invalid elements may be set to a value specified by a call to this function. Note that only existing invalid elements will be filled as indicated: new invalid column elements would still have their actual values left undefined. Also, any further processing of the column would not take care of maintaining the assigned value to a given invalid column element: therefore the value should be applied just before it is actually needed. An invalid numerical column element remains invalid after this call, and the usual method of checking whether the element is invalid or not should still be used. This function can be applied also to columns of arrays of integers. In this case the call will cause the array element to be flagged as valid.</p>
<dl class="section note"><dt>Note</dt><dd>Assigning a value to an invalid numerical element will not make it valid, but assigning a value to an element consisting of an array of numbers will make the array element valid. </dd></dl>

</div>
</div>
<a id="ga214cb1176a8d6c1381626f3446a31424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga214cb1176a8d6c1381626f3446a31424">&#9670;&nbsp;</a></span>cpl_table_fill_invalid_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_invalid_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a numerical value to invalid <em>long</em> column elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table containing the column. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">code</td><td>Value to write to invalid column elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG</code>, or of type <code>CPL_TYPE_LONG | CPL_TYPE_POINTER</code>.   </td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__table.html#ga0041fc2ebc6cf8c41693298b91a91551" title="Write a numerical value to invalid integer column elements.">cpl_table_fill_invalid_int()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assigning a value to an invalid numerical element will not make it valid, but assigning a value to an element consisting of an array of numbers will make the array element valid. </dd></dl>

</div>
</div>
<a id="ga96bffe508ceab3b4b0c33cbb7475ad64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96bffe508ceab3b4b0c33cbb7475ad64">&#9670;&nbsp;</a></span>cpl_table_fill_invalid_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_fill_invalid_long_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a numerical value to invalid <em>long</em> <em>long</em> column elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table containing the column. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">code</td><td>Value to write to invalid column elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG_LONG</code>, or of type <code>CPL_TYPE_LONG_LONG | CPL_TYPE_POINTER</code>.   </td></tr>
</table>
</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__table.html#ga0041fc2ebc6cf8c41693298b91a91551" title="Write a numerical value to invalid integer column elements.">cpl_table_fill_invalid_int()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assigning a value to an invalid numerical element will not make it valid, but assigning a value to an element consisting of an array of numbers will make the array element valid. </dd></dl>

</div>
</div>
<a id="ga33399dd985658a5e658b0427a6d4762d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33399dd985658a5e658b0427a6d4762d">&#9670;&nbsp;</a></span>cpl_table_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_table_get </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a numerical column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to be accessed. </td></tr>
    <tr><td class="paramname">row</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating <em>null</em> values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value read. In case of invalid table element, or in case of error, 0.0 is returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is not numerical, or is a column of arrays.   </td></tr>
</table>
</dd>
</dl>
<p>Rows are counted starting from 0. The <em>null</em> flag is used to indicate whether the accessed table element is valid (0) or invalid (1). The <em>null</em> flag also signals an error condition (-1). The <em>null</em> argument can be left to <code>NULL</code>. </p>

</div>
</div>
<a id="ga1303e1dd8cc3239acb1d207da32ef63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1303e1dd8cc3239acb1d207da32ef63f">&#9670;&nbsp;</a></span>cpl_table_get_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cpl_array* cpl_table_get_array </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an array from an <em>array</em> column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position of element to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to array. In case of an invalid column element, or in case of error, a <code>NULL</code> pointer is always returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <em>array</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Read a value from a column of any array type. Rows are counted starting from 0.</p>
<dl class="section note"><dt>Note</dt><dd>The returned array is a pointer to a table element, not its copy. Its manipulation will directly affect that element, while changing that element using <code><a class="el" href="group__cpl__table.html#ga506a2e3a103198edcb2fd5a79480a75a" title="Write an array to an array table column element.">cpl_table_set_array()</a></code> will turn it into garbage. Therefore, if a real copy of an array column element is required, this function should be called as an argument of the function <code><a class="el" href="group__cpl__array.html#ga4d2bbefc13a4c4d7d03a3413202653db" title="Make a copy of an array.">cpl_array_duplicate()</a></code>. </dd></dl>

</div>
</div>
<a id="ga61f1174b2f53f2e835d64d35dd337d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61f1174b2f53f2e835d64d35dd337d8a">&#9670;&nbsp;</a></span>cpl_table_get_column_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_get_column_depth </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the depth of a table column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Column depth, or -1 in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Get the depth of a column. Columns of type <em>array</em> always have positive depth, while columns listing numbers or character strings have depth 0. </p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#gad3d6e80aaaa6c23a6ea33e5b4a3446a3">cpl_table_compare_structure()</a>.</p>

</div>
</div>
<a id="ga359e0b4ad826ad12cc8f17b7eb26c2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga359e0b4ad826ad12cc8f17b7eb26c2d5">&#9670;&nbsp;</a></span>cpl_table_get_column_dimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_get_column_dimension </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of one dimension of a table column of arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">indx</td><td>Indicate dimension to query (0 = x, 1 = y, 2 = z, etc.).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of queried dimension of the column, or zero in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_UNSUPPORTED_MODE </td><td class="ecr">The specified column is not of type <em>array</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The specified <em>indx</em> array is not compatible with the column dimensions.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INCOMPATIBLE_INPUT </td><td class="ecr">The specified dimensions are incompatible with the total number of elements in the column arrays.   </td></tr>
</table>
</dd>
</dl>
<p>Get the size of one dimension of a column. If a column is not an array column, or if it has no dimensions, 1 is returned. </p>

</div>
</div>
<a id="gabbf8294fd53f45d95d6c1e6502c10422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbf8294fd53f45d95d6c1e6502c10422">&#9670;&nbsp;</a></span>cpl_table_get_column_dimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_get_column_dimensions </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of dimensions of a table column of arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Column number of dimensions, or 0 in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Get the number of dimensions of a column. If a column is not an array column, or if it has no dimensions, 1 is returned. </p>

</div>
</div>
<a id="gae259f11cb1b876a48cadbd932262c82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae259f11cb1b876a48cadbd932262c82b">&#9670;&nbsp;</a></span>cpl_table_get_column_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cpl_table_get_column_format </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the format of a table column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Format of column, or <code>NULL</code> in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Return the format of a column. Note that the returned string is a pointer to the column format, not its copy. Its manipulation will directly affect the column format, while changing the column format using <code>cpl_column_set_format()</code> will turn it into garbage. Therefore it should be considered read-only, and if a real copy of a column format is required, this function should be called as an argument of the function <code>strdup()</code>. </p>

</div>
</div>
<a id="ga9900039b3efba3bde4bdd6a178e5323a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9900039b3efba3bde4bdd6a178e5323a">&#9670;&nbsp;</a></span>cpl_table_get_column_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_table_get_column_max </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get maximum value in a numerical column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum value. See documentation of <code><a class="el" href="group__cpl__table.html#ga373b83f9dcf98c1e1888d2eea9373861" title="Compute the mean value of a numerical column.">cpl_table_get_column_mean()</a></code>.</dd></dl>
<p>See the description of the function <code><a class="el" href="group__cpl__table.html#ga373b83f9dcf98c1e1888d2eea9373861" title="Compute the mean value of a numerical column.">cpl_table_get_column_mean()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>.</p>

</div>
</div>
<a id="gac868a47a84d7fae362c91425c692b313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac868a47a84d7fae362c91425c692b313">&#9670;&nbsp;</a></span>cpl_table_get_column_maxpos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_get_column_maxpos </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get position of maximum in a numerical column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">row</td><td>Returned position of maximum value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>, or it just contains invalid elements, or the table has length zero.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>Invalid column values are excluded from the search. The <em>row</em> argument will be assigned the position of the maximum value, where rows are counted starting from 0. If more than one column element correspond to the max value, the position with the lowest row number is returned. In case of error, <em>row</em> is left untouched. The table selection flags have no influence on the result. </p>

</div>
</div>
<a id="ga373b83f9dcf98c1e1888d2eea9373861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga373b83f9dcf98c1e1888d2eea9373861">&#9670;&nbsp;</a></span>cpl_table_get_column_mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_table_get_column_mean </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean value of a numerical column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mean value. In case of error 0.0 is returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>, or it just contains invalid elements, or the table has length zero.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>Invalid column values are excluded from the computation. The table selection flags have no influence on the result. </p>

<p class="reference">References <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>.</p>

</div>
</div>
<a id="ga5e074ae74e0eda508f4dcf2949f82bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e074ae74e0eda508f4dcf2949f82bf8">&#9670;&nbsp;</a></span>cpl_table_get_column_mean_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double complex cpl_table_get_column_mean_complex </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean value of a numerical or complex column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mean value. In case of error 0.0 is returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>, or it just contains invalid elements, or the table has length zero.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex.   </td></tr>
</table>
</dd>
</dl>
<p>Invalid column values are excluded from the computation. The table selection flags have no influence on the result. </p>

<p class="reference">References <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>.</p>

</div>
</div>
<a id="ga7f58ee405b0bcc98d709b3acfbb71ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f58ee405b0bcc98d709b3acfbb71ee8">&#9670;&nbsp;</a></span>cpl_table_get_column_median()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_table_get_column_median </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the median value of a numerical column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Median value. See documentation of <code><a class="el" href="group__cpl__table.html#ga373b83f9dcf98c1e1888d2eea9373861" title="Compute the mean value of a numerical column.">cpl_table_get_column_mean()</a></code>.</dd></dl>
<p>See the description of the function <code><a class="el" href="group__cpl__table.html#ga373b83f9dcf98c1e1888d2eea9373861" title="Compute the mean value of a numerical column.">cpl_table_get_column_mean()</a></code>. </p>

</div>
</div>
<a id="ga80b4d4d2a48bbd76ff9e1a2823dad1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80b4d4d2a48bbd76ff9e1a2823dad1a2">&#9670;&nbsp;</a></span>cpl_table_get_column_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_table_get_column_min </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get minimum value in a numerical column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum value. See documentation of <code><a class="el" href="group__cpl__table.html#ga373b83f9dcf98c1e1888d2eea9373861" title="Compute the mean value of a numerical column.">cpl_table_get_column_mean()</a></code>.</dd></dl>
<p>See the description of the function <code><a class="el" href="group__cpl__table.html#ga373b83f9dcf98c1e1888d2eea9373861" title="Compute the mean value of a numerical column.">cpl_table_get_column_mean()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>.</p>

</div>
</div>
<a id="ga852d3e80f107f985232c506500def8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga852d3e80f107f985232c506500def8e7">&#9670;&nbsp;</a></span>cpl_table_get_column_minpos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_get_column_minpos </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get position of minimum in a numerical column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">row</td><td>Returned position of minimum value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See function <code><a class="el" href="group__cpl__table.html#gac868a47a84d7fae362c91425c692b313" title="Get position of maximum in a numerical column.">cpl_table_get_column_maxpos()</a></code>.</dd></dl>
<p>See the description of the function <code><a class="el" href="group__cpl__table.html#gac868a47a84d7fae362c91425c692b313" title="Get position of maximum in a numerical column.">cpl_table_get_column_maxpos()</a></code>. </p>

</div>
</div>
<a id="gab198f8dc91a1bd65082f1f8b8bb9019a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab198f8dc91a1bd65082f1f8b8bb9019a">&#9670;&nbsp;</a></span>cpl_table_get_column_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cpl_table_get_column_name </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get table columns names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of a table column.</dd></dl>
<p>If this function is not called with a <code>NULL</code> pointer the name of the first table column will be returned. Further calls made with a <code>NULL</code> pointer would return the next columns names, till the end of the list of columns when a <code>NULL</code> would be returned. This function only guarantees that all the table column names would be returned by subsequent calls to this function, but the order in which the column names are returned is undefined. The table structure must not be modified (e.g. by deleting, creating, moving, or renaming columns) between a sequence of calls to <code><a class="el" href="group__cpl__table.html#gab198f8dc91a1bd65082f1f8b8bb9019a" title="Get table columns names.">cpl_table_get_column_name()</a></code> related to the same table, or this function behaviour will be undetermined. This function returns a pointer to the table column name, and not to its copy, therefore the pointed string shouldn't be deallocated or manipulated in any way. Its manipulation would directly affect the column name, while changing the column name using <code><a class="el" href="group__cpl__table.html#gaad8efb6812a252e7ef58abc33d48c85c" title="Rename a table column.">cpl_table_name_column()</a></code> would turn it into garbage. Therefore, if a real copy of a column name is required, this function should be called as an argument of the function <code>strdup()</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>This function is deprecated, because its usage could create serious problems in case it is attempted to get names from different tables simultaneously. For instance, a programmer may call <a class="el" href="group__cpl__table.html#gab198f8dc91a1bd65082f1f8b8bb9019a" title="Get table columns names.">cpl_table_get_column_name()</a> in a loop, and in the same loop call a CPL function that calls as well the same function. The behaviour in this case would be unpredictable. The function <a class="el" href="group__cpl__table.html#gaef76a593a5bfbefdc37553c025537fe8" title="Get table columns names.">cpl_table_get_column_names()</a> should be used instead. </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>.</p>

</div>
</div>
<a id="gaef76a593a5bfbefdc37553c025537fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef76a593a5bfbefdc37553c025537fe8">&#9670;&nbsp;</a></span>cpl_table_get_column_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_table_get_column_names </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get table columns names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of table columns names.</dd></dl>
<p>The returned CPL array of strings should be finally destroyed using <a class="el" href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074" title="Delete an array.">cpl_array_delete()</a>. </p>

<p class="reference">References <a class="el" href="group__cpl__array.html#gaf7d187111491f2d3a8b50fff01fbad17">cpl_array_new()</a>, <a class="el" href="group__cpl__array.html#gafdcddf97688e725811a4c8e7b7abfc01">cpl_array_set_string()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8c58196493fdac6c0424560417cd6bf8">CPL_TYPE_STRING</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#gad3d6e80aaaa6c23a6ea33e5b4a3446a3">cpl_table_compare_structure()</a>.</p>

</div>
</div>
<a id="gabab0fdcc3cd3af2ac66fc56f1e3dda71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabab0fdcc3cd3af2ac66fc56f1e3dda71">&#9670;&nbsp;</a></span>cpl_table_get_column_stdev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_table_get_column_stdev </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the standard deviation of a table column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard deviation. See documentation of <code><a class="el" href="group__cpl__table.html#ga373b83f9dcf98c1e1888d2eea9373861" title="Compute the mean value of a numerical column.">cpl_table_get_column_mean()</a></code>.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>, or it just contains invalid elements, or the table has length zero.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>Invalid column values are excluded from the computation of the standard deviation. If just one valid element is found, 0.0 is returned but no error is set. The table selection flags have no influence on the result. </p>

<p class="reference">References <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>.</p>

</div>
</div>
<a id="ga02d329749056a40390df1555c4021032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02d329749056a40390df1555c4021032">&#9670;&nbsp;</a></span>cpl_table_get_column_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a> cpl_table_get_column_type </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of a table column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Column type, or <code>CPL_TYPE_INVALID</code> in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Get the type of a column. </p>

<p class="reference">Referenced by <a class="el" href="group__cpl__plot.html#ga1bb893c5a03596a48f670c2608dc1b94">cpl_plot_column()</a>, <a class="el" href="group__cpl__plot.html#ga511c1fba8ff96b7bc5ed698ba8ab2d87">cpl_plot_columns()</a>, <a class="el" href="group__cpl__table.html#gad3d6e80aaaa6c23a6ea33e5b4a3446a3">cpl_table_compare_structure()</a>, and <a class="el" href="group__cpl__table.html#ga493cee1969a8fff7ee9cd80df40d29b7">cpl_table_unwrap()</a>.</p>

</div>
</div>
<a id="ga4d2166101405f3dd6f6e62adab9c9194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d2166101405f3dd6f6e62adab9c9194">&#9670;&nbsp;</a></span>cpl_table_get_column_unit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cpl_table_get_column_unit </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unit of a table column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unit of column, or <code>NULL</code> if no unit can be returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Return the unit of a column if present, otherwise a NULL pointer is returned. Note that the returned string is a pointer to the column unit, not its copy. Its manipulation will directly affect the column unit, while changing the column unit using <code>cpl_column_set_unit()</code> will turn it into garbage. Therefore it should be considered read-only, and if a real copy of a column unit is required, this function should be called as an argument of the function <code>strdup()</code>. </p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#gad3d6e80aaaa6c23a6ea33e5b4a3446a3">cpl_table_compare_structure()</a>.</p>

</div>
</div>
<a id="ga2101ab90a219c7839d1226d0f69f85e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2101ab90a219c7839d1226d0f69f85e7">&#9670;&nbsp;</a></span>cpl_table_get_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double complex cpl_table_get_complex </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a complex column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to be accessed. </td></tr>
    <tr><td class="paramname">row</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating <em>null</em> values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value read. In case of invalid table element, or in case of error, 0.0 is returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is not complex, or is a column of arrays.   </td></tr>
</table>
</dd>
</dl>
<p>Rows are counted starting from 0. The <em>null</em> flag is used to indicate whether the accessed table element is valid (0) or invalid (1). The <em>null</em> flag also signals an error condition (-1). The <em>null</em> argument can be left to <code>NULL</code>. </p>

</div>
</div>
<a id="gae7f05cb05cdfdf3723d786d9ce89c23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7f05cb05cdfdf3723d786d9ce89c23e">&#9670;&nbsp;</a></span>cpl_table_get_data_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array** cpl_table_get_data_array </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <em>array</em> column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <em>array</em>.   </td></tr>
</table>
</dd>
</dl>
<p>A table column of type <em>array</em> includes an array of values of type <em>cpl_array*</em>. This function returns a pointer to this array.</p>
<dl class="section note"><dt>Note</dt><dd>Use at your own risk: direct manipulation of column data rules out any check performed by the table object interface, and may introduce inconsistencies between the information maintained internally, and the actual column data and structure. </dd></dl>

</div>
</div>
<a id="ga769291d4bb023842bce91fe0e0b536ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga769291d4bb023842bce91fe0e0b536ae">&#9670;&nbsp;</a></span>cpl_table_get_data_array_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cpl_array** cpl_table_get_data_array_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <em>array</em> column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <em>array</em>.   </td></tr>
</table>
</dd>
</dl>
<p>A table column of type <em>array</em> includes an array of values of type <em>cpl_array*</em>. This function returns a pointer to this array. </p>

</div>
</div>
<a id="ga87ca9a6aca3ddfc830f64906142a21cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87ca9a6aca3ddfc830f64906142a21cb">&#9670;&nbsp;</a></span>cpl_table_get_data_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* cpl_table_get_data_double </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <em>double</em> column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_DOUBLE</code> includes an array of values of type <em>double</em>. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#ga5833f6747311fd2c8ccda52702379fbc" title="Write a numerical value to invalid double column elements.">cpl_table_fill_invalid_double()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#ga5833f6747311fd2c8ccda52702379fbc" title="Write a numerical value to invalid double column elements.">cpl_table_fill_invalid_double()</a></code> for further details.</p>
<dl class="section note"><dt>Note</dt><dd>Use at your own risk: direct manipulation of column data rules out any check performed by the table object interface, and may introduce inconsistencies between the information maintained internally, and the actual column data and structure. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__cpl__plot.html#ga1bb893c5a03596a48f670c2608dc1b94">cpl_plot_column()</a>.</p>

</div>
</div>
<a id="ga6735ebf8f078b00d846e954f6577c79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6735ebf8f078b00d846e954f6577c79a">&#9670;&nbsp;</a></span>cpl_table_get_data_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double complex* cpl_table_get_data_double_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <em>double</em> complex column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_DOUBLE_COMPLEX</code> includes an array of values of type <em>double</em> complex. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#ga830a09cfa2504d15aa6eb0d25019eda2" title="Write a numerical value to invalid double complex column elements.">cpl_table_fill_invalid_double_complex()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#ga830a09cfa2504d15aa6eb0d25019eda2" title="Write a numerical value to invalid double complex column elements.">cpl_table_fill_invalid_double_complex()</a></code> for further details.</p>
<dl class="section note"><dt>Note</dt><dd>Use at your own risk: direct manipulation of column data rules out any check performed by the table object interface, and may introduce inconsistencies between the information maintained internally, and the actual column data and structure. </dd></dl>

</div>
</div>
<a id="ga33754f52437a696230a6a14494c9c088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33754f52437a696230a6a14494c9c088">&#9670;&nbsp;</a></span>cpl_table_get_data_double_complex_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double complex* cpl_table_get_data_double_complex_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <em>double</em> complex column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to constant table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_DOUBLE_COMPLEX</code> includes an array of values of type <em>double</em> complex. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#ga830a09cfa2504d15aa6eb0d25019eda2" title="Write a numerical value to invalid double complex column elements.">cpl_table_fill_invalid_double_complex()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#ga830a09cfa2504d15aa6eb0d25019eda2" title="Write a numerical value to invalid double complex column elements.">cpl_table_fill_invalid_double_complex()</a></code> for further details. </p>

</div>
</div>
<a id="gaed6b2dfa954fff86892075e0ba71e655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed6b2dfa954fff86892075e0ba71e655">&#9670;&nbsp;</a></span>cpl_table_get_data_double_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* cpl_table_get_data_double_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <em>double</em> column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to constant table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_DOUBLE</code> includes an array of values of type <em>double</em>. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#ga5833f6747311fd2c8ccda52702379fbc" title="Write a numerical value to invalid double column elements.">cpl_table_fill_invalid_double()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#ga5833f6747311fd2c8ccda52702379fbc" title="Write a numerical value to invalid double column elements.">cpl_table_fill_invalid_double()</a></code> for further details. </p>

<p class="reference">Referenced by <a class="el" href="group__cpl__plot.html#ga1bb893c5a03596a48f670c2608dc1b94">cpl_plot_column()</a>, and <a class="el" href="group__cpl__plot.html#ga511c1fba8ff96b7bc5ed698ba8ab2d87">cpl_plot_columns()</a>.</p>

</div>
</div>
<a id="gae9f464d0863d252cb9d80d43f3cd71ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9f464d0863d252cb9d80d43f3cd71ef">&#9670;&nbsp;</a></span>cpl_table_get_data_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* cpl_table_get_data_float </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <em>float</em> column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_FLOAT</code> includes an array of values of type <em>float</em>. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#gaf5bd6ed9bb98fdbab4a79b26f3cf68ea" title="Write a numerical value to invalid float column elements.">cpl_table_fill_invalid_float()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#gaf5bd6ed9bb98fdbab4a79b26f3cf68ea" title="Write a numerical value to invalid float column elements.">cpl_table_fill_invalid_float()</a></code> for further details.</p>
<dl class="section note"><dt>Note</dt><dd>Use at your own risk: direct manipulation of column data rules out any check performed by the table object interface, and may introduce inconsistencies between the information maintained internally, and the actual column data and structure. </dd></dl>

</div>
</div>
<a id="ga8917beee9df147a5173806902e45a5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8917beee9df147a5173806902e45a5d0">&#9670;&nbsp;</a></span>cpl_table_get_data_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float complex* cpl_table_get_data_float_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <em>float</em> complex column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT_COMPLEX</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_FLOAT_COMPLEX</code> includes an array of values of type <em>float</em> complex. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#gaef2f1d812cab0159c4eb1cd212928c4a" title="Write a numerical value to invalid float complex column elements.">cpl_table_fill_invalid_float_complex()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#gaef2f1d812cab0159c4eb1cd212928c4a" title="Write a numerical value to invalid float complex column elements.">cpl_table_fill_invalid_float_complex()</a></code> for further details.</p>
<dl class="section note"><dt>Note</dt><dd>Use at your own risk: direct manipulation of column data rules out any check performed by the table object interface, and may introduce inconsistencies between the information maintained internally, and the actual column data and structure. </dd></dl>

</div>
</div>
<a id="gabad14408e5d47d021cf1647c0df79e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabad14408e5d47d021cf1647c0df79e83">&#9670;&nbsp;</a></span>cpl_table_get_data_float_complex_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float complex* cpl_table_get_data_float_complex_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <em>float</em> complex column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to constant table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT_COMPLEX</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_FLOAT_COMPLEX</code> includes an array of values of type <em>float</em> complex. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#gaef2f1d812cab0159c4eb1cd212928c4a" title="Write a numerical value to invalid float complex column elements.">cpl_table_fill_invalid_float_complex()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#gaef2f1d812cab0159c4eb1cd212928c4a" title="Write a numerical value to invalid float complex column elements.">cpl_table_fill_invalid_float_complex()</a></code> for further details. </p>

</div>
</div>
<a id="gad1e0956719b1fd2591ab485d32a6a7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1e0956719b1fd2591ab485d32a6a7b3">&#9670;&nbsp;</a></span>cpl_table_get_data_float_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float* cpl_table_get_data_float_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <em>float</em> column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to constant table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_FLOAT</code> includes an array of values of type <em>float</em>. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#gaf5bd6ed9bb98fdbab4a79b26f3cf68ea" title="Write a numerical value to invalid float column elements.">cpl_table_fill_invalid_float()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#gaf5bd6ed9bb98fdbab4a79b26f3cf68ea" title="Write a numerical value to invalid float column elements.">cpl_table_fill_invalid_float()</a></code> for further details. </p>

</div>
</div>
<a id="gaff3998d07c6cbf88d0297648bce6f6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff3998d07c6cbf88d0297648bce6f6f4">&#9670;&nbsp;</a></span>cpl_table_get_data_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* cpl_table_get_data_int </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <em>integer</em> column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_INT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_INT</code> includes an array of values of type <em>int</em>. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#ga0041fc2ebc6cf8c41693298b91a91551" title="Write a numerical value to invalid integer column elements.">cpl_table_fill_invalid_int()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#ga0041fc2ebc6cf8c41693298b91a91551" title="Write a numerical value to invalid integer column elements.">cpl_table_fill_invalid_int()</a></code> for further details.</p>
<dl class="section note"><dt>Note</dt><dd>Use at your own risk: direct manipulation of column data rules out any check performed by the table object interface, and may introduce inconsistencies between the information maintained internally, and the actual column data and structure. </dd></dl>

</div>
</div>
<a id="ga75e99fd2cd8582c622c7d0e8b3584599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75e99fd2cd8582c622c7d0e8b3584599">&#9670;&nbsp;</a></span>cpl_table_get_data_int_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int* cpl_table_get_data_int_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <em>integer</em> column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to constant table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_INT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_INT</code> includes an array of values of type <em>int</em>. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#ga0041fc2ebc6cf8c41693298b91a91551" title="Write a numerical value to invalid integer column elements.">cpl_table_fill_invalid_int()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#ga0041fc2ebc6cf8c41693298b91a91551" title="Write a numerical value to invalid integer column elements.">cpl_table_fill_invalid_int()</a></code> for further details. </p>

</div>
</div>
<a id="ga8ef375e98c30597d3f6857e6f8914e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ef375e98c30597d3f6857e6f8914e2e">&#9670;&nbsp;</a></span>cpl_table_get_data_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long* cpl_table_get_data_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <em>long</em> column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_LONG</code> includes an array of values of type <em>long</em>. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#ga214cb1176a8d6c1381626f3446a31424" title="Write a numerical value to invalid long column elements.">cpl_table_fill_invalid_long()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#ga214cb1176a8d6c1381626f3446a31424" title="Write a numerical value to invalid long column elements.">cpl_table_fill_invalid_long()</a></code> for further details.</p>
<dl class="section note"><dt>Note</dt><dd>Use at your own risk: direct manipulation of column data rules out any check performed by the table object interface, and may introduce inconsistencies between the information maintained internally, and the actual column data and structure. </dd></dl>

</div>
</div>
<a id="gae59fa517b348aaa1129c0c671bed58ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae59fa517b348aaa1129c0c671bed58ca">&#9670;&nbsp;</a></span>cpl_table_get_data_long_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const long* cpl_table_get_data_long_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <em>long</em> column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to constant table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_LONG</code> includes an array of values of type <em>long</em>. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#ga214cb1176a8d6c1381626f3446a31424" title="Write a numerical value to invalid long column elements.">cpl_table_fill_invalid_long()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#ga214cb1176a8d6c1381626f3446a31424" title="Write a numerical value to invalid long column elements.">cpl_table_fill_invalid_long()</a></code> for further details. </p>

</div>
</div>
<a id="gacc3a50e0c1812fa80381dcddb26dd3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc3a50e0c1812fa80381dcddb26dd3e8">&#9670;&nbsp;</a></span>cpl_table_get_data_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long* cpl_table_get_data_long_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <em>long</em> <em>long</em> column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_LONG_LONG</code> includes an array of values of type <em>long</em> long. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#ga96bffe508ceab3b4b0c33cbb7475ad64" title="Write a numerical value to invalid long long column elements.">cpl_table_fill_invalid_long_long()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#ga96bffe508ceab3b4b0c33cbb7475ad64" title="Write a numerical value to invalid long long column elements.">cpl_table_fill_invalid_long_long()</a></code> for further details.</p>
<dl class="section note"><dt>Note</dt><dd>Use at your own risk: direct manipulation of column data rules out any check performed by the table object interface, and may introduce inconsistencies between the information maintained internally, and the actual column data and structure. </dd></dl>

</div>
</div>
<a id="ga2089d19649f49d69165ed9ec458a675b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2089d19649f49d69165ed9ec458a675b">&#9670;&nbsp;</a></span>cpl_table_get_data_long_long_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const long long* cpl_table_get_data_long_long_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <em>long</em> long column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to constant table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A <em>cpl_table</em> column of type <code>CPL_TYPE_LONG_LONG</code> includes an array of values of type <em>long</em> long. This function returns a pointer to this array. The data buffer elements corresponding to invalid column elements would in general contain garbage. To avoid this, <code><a class="el" href="group__cpl__table.html#ga96bffe508ceab3b4b0c33cbb7475ad64" title="Write a numerical value to invalid long long column elements.">cpl_table_fill_invalid_long_long()</a></code> should be called just before this function, assigning to all the invalid column elements an <em>ad</em> <em>hoc</em> numerical value. See the description of function <code><a class="el" href="group__cpl__table.html#ga96bffe508ceab3b4b0c33cbb7475ad64" title="Write a numerical value to invalid long long column elements.">cpl_table_fill_invalid_long_long()</a></code> for further details. </p>

</div>
</div>
<a id="ga48cf0bd4ad1b6e820699ab1edb1318e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48cf0bd4ad1b6e820699ab1edb1318e6">&#9670;&nbsp;</a></span>cpl_table_get_data_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** cpl_table_get_data_string </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to <em>string</em> column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_STRING</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A table column of type <code>CPL_TYPE_STRING</code> includes an array of values of type <em>char*</em>. This function returns a pointer to this array.</p>
<dl class="section note"><dt>Note</dt><dd>Use at your own risk: direct manipulation of column data rules out any check performed by the table object interface, and may introduce inconsistencies between the information maintained internally, and the actual column data and structure. </dd></dl>

</div>
</div>
<a id="ga953b39968f6d156e556da81ac93d9ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga953b39968f6d156e556da81ac93d9ef1">&#9670;&nbsp;</a></span>cpl_table_get_data_string_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char** cpl_table_get_data_string_const </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to constant <em>string</em> column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to constant table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constant column data, or <code>NULL</code> if the column has zero length, or in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_STRING</code>.   </td></tr>
</table>
</dd>
</dl>
<p>A table column of type <code>CPL_TYPE_STRING</code> includes an array of values of type <em>char*</em>. This function returns a pointer to this array. </p>

</div>
</div>
<a id="ga60756f14cf5231b205345e3ab85422ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60756f14cf5231b205345e3ab85422ee">&#9670;&nbsp;</a></span>cpl_table_get_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_table_get_double </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>double</em> column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating <em>null</em> values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Double value read. In case of an invalid table element, or in case of error, 0.0 is always returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Read a value from a column of type <code>CPL_TYPE_DOUBLE</code>. See the documentation of function <a class="el" href="group__cpl__table.html#ga2a806d7ca9db041bbf3d276c9f8e2918" title="Read a value from an integer column.">cpl_table_get_int()</a>. </p>

</div>
</div>
<a id="gaed133467e289a4c84393d104948d5c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed133467e289a4c84393d104948d5c1d">&#9670;&nbsp;</a></span>cpl_table_get_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double complex cpl_table_get_double_complex </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>double</em> complex column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating <em>null</em> values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Double complex value read. In case of an invalid table element, or in case of error, 0.0 is always returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Read a value from a column of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>. See the documentation of function <a class="el" href="group__cpl__table.html#ga2a806d7ca9db041bbf3d276c9f8e2918" title="Read a value from an integer column.">cpl_table_get_int()</a>. </p>

</div>
</div>
<a id="gaf275203e48d2208e8f1a6a26c4b5b751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf275203e48d2208e8f1a6a26c4b5b751">&#9670;&nbsp;</a></span>cpl_table_get_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cpl_table_get_float </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>float</em> column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating <em>null</em> values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Float value read. In case of an invalid table element, or in case of error, 0.0 is always returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Read a value from a column of type <code>CPL_TYPE_FLOAT</code>. See the documentation of function <a class="el" href="group__cpl__table.html#ga2a806d7ca9db041bbf3d276c9f8e2918" title="Read a value from an integer column.">cpl_table_get_int()</a>. </p>

</div>
</div>
<a id="ga9cd6c102f7ab11338dd95ad5141babc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cd6c102f7ab11338dd95ad5141babc3">&#9670;&nbsp;</a></span>cpl_table_get_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float complex cpl_table_get_float_complex </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>float</em> complex column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating <em>null</em> values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Float complex value read. In case of an invalid table element, or in case of error, 0.0 is always returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT_COMPLEX</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Read a value from a column of type <code>CPL_TYPE_FLOAT_COMPLEX</code>. See the documentation of function <a class="el" href="group__cpl__table.html#ga2a806d7ca9db041bbf3d276c9f8e2918" title="Read a value from an integer column.">cpl_table_get_int()</a>. </p>

</div>
</div>
<a id="ga2a806d7ca9db041bbf3d276c9f8e2918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a806d7ca9db041bbf3d276c9f8e2918">&#9670;&nbsp;</a></span>cpl_table_get_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpl_table_get_int </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from an <em>integer</em> column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating <em>null</em> values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value read. In case of an invalid table element, or in case of error, 0 is always returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_INT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Read a value from a column of type <code>CPL_TYPE_INT</code>. If the <em>null</em> flag is a valid pointer, it is used to indicate whether the accessed column element is valid (0) or invalid (1). The <em>null</em> flag also signals an error condition (-1). The <em>null</em> flag pointer can also be <code>NULL</code>, and in that case this option will be disabled. Rows are counted starting from 0.</p>
<dl class="section note"><dt>Note</dt><dd>For automatic conversion (always to type <em>double</em>), use the function <code><a class="el" href="group__cpl__table.html#ga33399dd985658a5e658b0427a6d4762d" title="Read a value from a numerical column.">cpl_table_get()</a></code>. </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gac3efdea8811dbcb40a917b783a01b18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3efdea8811dbcb40a917b783a01b18f">&#9670;&nbsp;</a></span>cpl_table_get_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long cpl_table_get_long </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>long</em> column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating <em>null</em> values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Long integer value read. In case of an invalid table element, or in case of error, 0 is always returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Read a value from a column of type <code>CPL_TYPE_LONG</code>. See the documentation of function <a class="el" href="group__cpl__table.html#ga2a806d7ca9db041bbf3d276c9f8e2918" title="Read a value from an integer column.">cpl_table_get_int()</a>. </p>

</div>
</div>
<a id="ga152f94ecbb6a49e2e7865f7277d7bd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga152f94ecbb6a49e2e7865f7277d7bd97">&#9670;&nbsp;</a></span>cpl_table_get_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long cpl_table_get_long_long </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>long</em> <em>long</em> column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position of element to be read. </td></tr>
    <tr><td class="paramname">null</td><td>Flag indicating <em>null</em> values, or error condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Long long integer value read. In case of an invalid table element, or in case of error, 0 is always returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Read a value from a column of type <code>CPL_TYPE_LONG_LONG</code>. See the documentation of function <a class="el" href="group__cpl__table.html#ga2a806d7ca9db041bbf3d276c9f8e2918" title="Read a value from an integer column.">cpl_table_get_int()</a>. </p>

</div>
</div>
<a id="gaec958c1ed4794abf6b4a814a7063dfb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec958c1ed4794abf6b4a814a7063dfb0">&#9670;&nbsp;</a></span>cpl_table_get_ncol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_get_ncol </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of columns in a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table to examine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of columns in the table. If a <code>NULL</code> table pointer is passed, -1 is returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr"><em>table</em> is a <code>NULL</code> pointer.   </td></tr>
</table>
</dd>
</dl>
<p>Get the number of columns in a table. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__error.html#gad7cf962bbe59df1b5991b17b1a2361a3">cpl_error_set</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#gad3d6e80aaaa6c23a6ea33e5b4a3446a3">cpl_table_compare_structure()</a>, <a class="el" href="group__cpl__table.html#ga86dc059191d3a5b42832fcfcf8efbea2">cpl_table_copy_structure()</a>, <a class="el" href="group__cpl__table.html#ga7fa13d6c00a323556c31bd531d6dc00c">cpl_table_delete()</a>, <a class="el" href="group__cpl__table.html#gacd790a348822ac1e02165c1e2b9435c4">cpl_table_dump()</a>, <a class="el" href="group__cpl__table.html#gae8ae7c1313f70adaebfd92ad04c9305c">cpl_table_dump_structure()</a>, <a class="el" href="group__cpl__table.html#ga49553a682513ffa3ecd943187653dc40">cpl_table_duplicate()</a>, <a class="el" href="group__cpl__table.html#ga397f3c878f110930bfe64b537c5d417c">cpl_table_erase_invalid()</a>, <a class="el" href="group__cpl__table.html#ga5c318a3f2c02b47e8c1fb4ccc019af1b">cpl_table_erase_invalid_rows()</a>, <a class="el" href="group__cpl__table.html#gab9b708efb1c519be18d680f26c947d8d">cpl_table_erase_selected()</a>, <a class="el" href="group__cpl__table.html#ga8e3777a49d3efd72eeb137af1c47176e">cpl_table_erase_window()</a>, <a class="el" href="group__cpl__table.html#ga84af52720711c7d4a3ecadce824f47b7">cpl_table_extract()</a>, <a class="el" href="group__cpl__table.html#gab198f8dc91a1bd65082f1f8b8bb9019a">cpl_table_get_column_name()</a>, <a class="el" href="group__cpl__table.html#gad0df354714c7494dd322060300fe7f2b">cpl_table_insert()</a>, <a class="el" href="group__cpl__table.html#ga5a0a1d35143d200b5ad1202672e10332">cpl_table_insert_window()</a>, and <a class="el" href="group__cpl__table.html#gaa139114ea5112984ef62fb95e6da33ae">cpl_table_set_size()</a>.</p>

</div>
</div>
<a id="ga98cf8e19056beaa8d9350806c58e7da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98cf8e19056beaa8d9350806c58e7da4">&#9670;&nbsp;</a></span>cpl_table_get_nrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_get_nrow </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of rows in a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table to examine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of rows in the table. If a <code>NULL</code> table pointer is passed, -1 is returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr"><em>table</em> is a <code>NULL</code> pointer.   </td></tr>
</table>
</dd>
</dl>
<p>Get the number of rows in a table. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__error.html#gad7cf962bbe59df1b5991b17b1a2361a3">cpl_error_set</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__plot.html#ga1bb893c5a03596a48f670c2608dc1b94">cpl_plot_column()</a>, <a class="el" href="group__cpl__plot.html#ga511c1fba8ff96b7bc5ed698ba8ab2d87">cpl_plot_columns()</a>, <a class="el" href="group__cpl__table.html#ga49553a682513ffa3ecd943187653dc40">cpl_table_duplicate()</a>, <a class="el" href="group__cpl__table.html#ga397f3c878f110930bfe64b537c5d417c">cpl_table_erase_invalid()</a>, <a class="el" href="group__cpl__table.html#ga5c318a3f2c02b47e8c1fb4ccc019af1b">cpl_table_erase_invalid_rows()</a>, <a class="el" href="group__cpl__table.html#gab9b708efb1c519be18d680f26c947d8d">cpl_table_erase_selected()</a>, and <a class="el" href="group__cpl__table.html#ga84af52720711c7d4a3ecadce824f47b7">cpl_table_extract()</a>.</p>

</div>
</div>
<a id="gaec49fa526d1e8d827025921c93539691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec49fa526d1e8d827025921c93539691">&#9670;&nbsp;</a></span>cpl_table_get_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cpl_table_get_string </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a <em>string</em> column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position of element to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to string. In case of an invalid column element, or in case of error, a <code>NULL</code> pointer is always returned.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_STRING</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Read a value from a column of type <code>CPL_TYPE_STRING</code>. Rows are counted starting from 0.</p>
<dl class="section note"><dt>Note</dt><dd>The returned string is a pointer to a table element, not its copy. Its manipulation will directly affect that element, while changing that element using <code><a class="el" href="group__cpl__table.html#gaf67725799ee9368dfb58f9650713a867" title="Write a character string to a string table column element.">cpl_table_set_string()</a></code> will turn it into garbage. Therefore, if a real copy of a string column element is required, this function should be called as an argument of the function <code>strdup()</code>. </dd></dl>

</div>
</div>
<a id="ga1d8bc681c82a78b369a1804cd12590d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d8bc681c82a78b369a1804cd12590d9">&#9670;&nbsp;</a></span>cpl_table_has_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpl_table_has_column </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a column with a given name exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if column exists, 0 if column doesn't exist, -1 in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
</table>
</dd>
</dl>
<p>Check if a column with a given name exists in the specified table. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__error.html#gad7cf962bbe59df1b5991b17b1a2361a3">cpl_error_set</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__plot.html#ga1bb893c5a03596a48f670c2608dc1b94">cpl_plot_column()</a>, <a class="el" href="group__cpl__plot.html#ga511c1fba8ff96b7bc5ed698ba8ab2d87">cpl_plot_columns()</a>, and <a class="el" href="group__cpl__table.html#gad3d6e80aaaa6c23a6ea33e5b4a3446a3">cpl_table_compare_structure()</a>.</p>

</div>
</div>
<a id="gabb66243e92bbcada184691ab12d27e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb66243e92bbcada184691ab12d27e83">&#9670;&nbsp;</a></span>cpl_table_has_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpl_table_has_invalid </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a column contains at least one invalid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the column contains at least one invalid element, 0 if not, -1 in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Check if there are invalid elements in a column. In case of columns of arrays, invalid values within an array are not considered: an invalid element here means that an array element is not allocated, i.e., it is a <code>NULL</code> pointer. In order to detect invalid elements within an array element, this element must be extracted using the function <code><a class="el" href="group__cpl__table.html#ga1303e1dd8cc3239acb1d207da32ef63f" title="Read an array from an array column.">cpl_table_get_array()</a></code>, and then use the function <code><a class="el" href="group__cpl__array.html#gaedc4a7c53d3a81c79d7efc473e645d6b" title="Check if an array contains at least one invalid element.">cpl_array_has_invalid()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>.</p>

</div>
</div>
<a id="ga92c0b33a617d6110efea6e3878987d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92c0b33a617d6110efea6e3878987d6c">&#9670;&nbsp;</a></span>cpl_table_has_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpl_table_has_valid </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a column contains at least one valid value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the column contains at least one valid value, 0 if not, -1 in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Check if there are valid elements in a column. In case of columns of arrays, invalid values within an array are not considered: an invalid element here means that an array element is not allocated, i.e., it is a <code>NULL</code> pointer. In order to detect valid elements within an array element, this element must be extracted using the function <code><a class="el" href="group__cpl__table.html#ga1303e1dd8cc3239acb1d207da32ef63f" title="Read an array from an array column.">cpl_table_get_array()</a></code>, and then use the function <code><a class="el" href="group__cpl__array.html#ga2ce90cb02dfff8e66e6b0b1bc5481988" title="Check if an array contains at least one valid value.">cpl_array_has_valid()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>.</p>

</div>
</div>
<a id="ga84696626a9695cbba896e3bcfc55b81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84696626a9695cbba896e3bcfc55b81a">&#9670;&nbsp;</a></span>cpl_table_imag_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_imag_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the imaginary part value of table column elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex.   </td></tr>
</table>
</dd>
</dl>
<p>Each column element is replaced by its imaginary party value only. Invalid elements are not modified by this operation. If the column is complex, its type will be turned to real (CPL_TYPE_FLOAT_COMPLEX will be changed into CPL_TYPE_FLOAT, and CPL_TYPE_DOUBLE_COMPLEX will be changed into CPL_TYPE_DOUBLE), and any pointer retrieved by calling <code><a class="el" href="group__cpl__table.html#ga8917beee9df147a5173806902e45a5d0" title="Get a pointer to float complex column data.">cpl_table_get_data_float_complex()</a></code>, <code><a class="el" href="group__cpl__table.html#ga6735ebf8f078b00d846e954f6577c79a" title="Get a pointer to double complex column data.">cpl_table_get_data_double_complex()</a></code>, etc., should be discarded. </p>

</div>
</div>
<a id="gad0df354714c7494dd322060300fe7f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0df354714c7494dd322060300fe7f2b">&#9670;&nbsp;</a></span>cpl_table_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_insert </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>target_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>insert_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge two tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_table</td><td>Target table. </td></tr>
    <tr><td class="paramname">insert_table</td><td>Table to be inserted in the target table. </td></tr>
    <tr><td class="paramname">row</td><td>Row where to insert the insert table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any input table is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr"><em>row</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INCOMPATIBLE_INPUT </td><td class="ecr">The input tables do not have the same structure.   </td></tr>
</table>
</dd>
</dl>
<p>The input tables must have the same structure, as defined by the function <code><a class="el" href="group__cpl__table.html#gad3d6e80aaaa6c23a6ea33e5b4a3446a3" title="Compare the structure of two tables.">cpl_table_compare_structure()</a></code> . Data from the <em>insert_table</em> are duplicated and inserted at the specified position of the <em>target_table</em>. If the specified <em>row</em> is not less than the target table length, the second table will be appended to the target table. The selection flags of the target table are always set back to "all selected". The pointers to column data in the target table may change, therefore pointers previously retrieved by calling <code><a class="el" href="group__cpl__table.html#gaff3998d07c6cbf88d0297648bce6f6f4" title="Get a pointer to integer column data.">cpl_table_get_data_int()</a></code>, <code><a class="el" href="group__cpl__table.html#ga48cf0bd4ad1b6e820699ab1edb1318e6" title="Get a pointer to string column data.">cpl_table_get_data_string()</a></code>, etc., should be discarded. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__table.html#gad3d6e80aaaa6c23a6ea33e5b4a3446a3">cpl_table_compare_structure()</a>, and <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>.</p>

</div>
</div>
<a id="ga5a0a1d35143d200b5ad1202672e10332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a0a1d35143d200b5ad1202672e10332">&#9670;&nbsp;</a></span>cpl_table_insert_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_insert_window </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a segment of rows into table data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table </td></tr>
    <tr><td class="paramname">start</td><td>Row where to insert the segment. </td></tr>
    <tr><td class="paramname">count</td><td>Length of the segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr"><em>table</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr"><em>start</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
</table>
</dd>
</dl>
<p>Insert a segment of empty rows, just containing invalid elements. Setting <em>start</em> to a number greater than the column length is legal, and has the effect of appending extra rows at the end of the table: this is equivalent to expanding the table using <code><a class="el" href="group__cpl__table.html#gaa139114ea5112984ef62fb95e6da33ae" title="Resize a table to a new number of rows.">cpl_table_set_size()</a></code>. The input <em>column</em> may also have zero length. The pointers to column data values may change, therefore pointers previously retrieved by calling <code><a class="el" href="group__cpl__table.html#gaff3998d07c6cbf88d0297648bce6f6f4" title="Get a pointer to integer column data.">cpl_table_get_data_int()</a></code>, <code><a class="el" href="group__cpl__table.html#ga48cf0bd4ad1b6e820699ab1edb1318e6" title="Get a pointer to string column data.">cpl_table_get_data_string()</a></code>, etc., should be discarded. The table selection flags are set back to "all selected". </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>, and <a class="el" href="group__cpl__table.html#ga70887311ad5f8204315c224517e50cab">cpl_table_select_all()</a>.</p>

</div>
</div>
<a id="gadce482a459d1fb56e320c5e37317c59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadce482a459d1fb56e320c5e37317c59d">&#9670;&nbsp;</a></span>cpl_table_is_selected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpl_table_is_selected </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a table row is selected or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">row</td><td>Table row to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if row is selected, 0 if it is not selected, -1 in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
</table>
</dd>
</dl>
<p>Check if a table row is selected. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0d916ea6a7e198a74863ecd9ea03d733">CPL_ERROR_ACCESS_OUT_OF_RANGE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga1d95d1733be04798e771606a8a0cf8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d95d1733be04798e771606a8a0cf8c3">&#9670;&nbsp;</a></span>cpl_table_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpl_table_is_valid </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a column element is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Column element to examine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the column element is valid, 0 if invalid, -1 in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
</table>
</dd>
</dl>
<p>Check if a column element is valid. </p>

<p class="reference">References <a class="el" href="group__cpl__errorstate.html#gadbf3f1525429b95837bc79a5e99b12cd">cpl_errorstate_get()</a>.</p>

</div>
</div>
<a id="gab7b1359331cb50e0a095bafb9d7d1caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7b1359331cb50e0a095bafb9d7d1caf">&#9670;&nbsp;</a></span>cpl_table_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_table* cpl_table_load </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xtnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>check_nulls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a FITS table extension into a new <em>cpl_table</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of FITS file with at least one table extension. </td></tr>
    <tr><td class="paramname">xtnum</td><td>Number of extension to read, starting from 1. </td></tr>
    <tr><td class="paramname">check_nulls</td><td>If set to 0, identified invalid values are not marked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New table, or <code>NULL</code> in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>filename</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_FILE_NOT_FOUND </td><td class="ecr">A file named as specified in <em>filename</em> is not found.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_BAD_FILE_FORMAT </td><td class="ecr">The input file is not in FITS format.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The specified FITS file extension is not a table, or, if it is a table, it has more than 9999 columns.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr"><em>xtnum</em> is greater than the number of FITS extensions in the FITS file, or is less than 1.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">The FITS table has no rows or no columns.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_UNSPECIFIED </td><td class="ecr">Generic error condition, that should be reported to the CPL Team.   </td></tr>
</table>
</dd>
</dl>
<p>The selected FITS file table extension is just read and converted into the <em>cpl_table</em> conventions. </p>

</div>
</div>
<a id="ga34555be42ae8fd148c454b4107d5dabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34555be42ae8fd148c454b4107d5dabf">&#9670;&nbsp;</a></span>cpl_table_load_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_table* cpl_table_load_window </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xtnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>check_nulls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>selcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>firstrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>nrow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load part of a FITS table extension into a new <em>cpl_table</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of FITS file with at least one table extension. </td></tr>
    <tr><td class="paramname">xtnum</td><td>Number of extension to read, starting from 1. </td></tr>
    <tr><td class="paramname">check_nulls</td><td>If set to 0, identified invalid values are not marked. </td></tr>
    <tr><td class="paramname">selcol</td><td>Array with the names of the columns to extract. </td></tr>
    <tr><td class="paramname">firstrow</td><td>First table row to extract. </td></tr>
    <tr><td class="paramname">nrow</td><td>Number of rows to extract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New table, or <code>NULL</code> in case of failure.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>filename</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_FILE_NOT_FOUND </td><td class="ecr">A file named as specified in <em>filename</em> is not found.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_BAD_FILE_FORMAT </td><td class="ecr">The input file is not in FITS format.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The specified FITS file extension is not a table. Or the specified number of rows to extract is less than zero. Or the array of column names to extract contains empty fields.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr"><em>xtnum</em> is greater than the number of FITS extensions in the FITS file, or is less than 1. Or <em>firstrow</em> is either less than zero, or greater than the number of rows in the table.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">The FITS table has no columns. Or <em>selcol</em> includes columns that are not found in table.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_UNSPECIFIED </td><td class="ecr">Generic error condition, that should be reported to the CPL Team.   </td></tr>
</table>
</dd>
</dl>
<p>The selected FITS file table extension is just read in the specified columns and rows intervals, and converted into the <em>cpl_table</em> conventions. If <em>selcol</em> is NULL, all columns are selected. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0d916ea6a7e198a74863ecd9ea03d733">CPL_ERROR_ACCESS_OUT_OF_RANGE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>.</p>

</div>
</div>
<a id="gaf8d14bac002b235d78b258dfc9341797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8d14bac002b235d78b258dfc9341797">&#9670;&nbsp;</a></span>cpl_table_logarithm_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_logarithm_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the logarithm of column values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Table column name. </td></tr>
    <tr><td class="paramname">base</td><td>Logarithm base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex, or it is an array column.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The input <em>base</em> is not positive.   </td></tr>
</table>
</dd>
</dl>
<p>Each column element is replaced by its logarithm in the specified base. The operation is always performed in double precision, with a final cast of the result to the target column type. Invalid elements are not modified by this operation, but zero or negative elements are invalidated by this operation. In case of complex numbers, values very close to the origin may cause an overflow. The imaginary part of the result is chosen in the interval [-pi/ln(base),pi/ln(base)], so it should be kept in mind that doing the logarithm of exponential of a complex number will not always express the phase angle with the same number. For instance, the exponential in base 2 of (5.00, 5.00) is (-30.33, -10.19), and the logarithm in base 2 of the latter will be expressed as (5.00, -4.06). </p>

</div>
</div>
<a id="ga902faf4c93198437baadd47d1f485436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga902faf4c93198437baadd47d1f485436">&#9670;&nbsp;</a></span>cpl_table_move_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_move_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>to_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>from_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a column from a table to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_table</td><td>Target table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of column to move. </td></tr>
    <tr><td class="paramname">from_table</td><td>Source table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INCOMPATIBLE_INPUT </td><td class="ecr">The input tables do not have the same number of rows.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">Source and target tables are the same table.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in the source table.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the same <em>name</em> already exists in the target table.   </td></tr>
</table>
</dd>
</dl>
<p>Move a column from a table to another. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga364d5a1519ec5ba82a273ea1f22db402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga364d5a1519ec5ba82a273ea1f22db402">&#9670;&nbsp;</a></span>cpl_table_multiply_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_multiply_columns </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two numeric or complex table columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">to_name</td><td>Name of target column. </td></tr>
    <tr><td class="paramname">from_name</td><td>Name of column to be multiplied with target column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or any column name are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with any specified name is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">Any specified column is neither numerical nor complex, or it is an array column.   </td></tr>
</table>
</dd>
</dl>
<p>The columns are multiplied element by element, and the result of the multiplication is stored in the target column. See the documentation of the function <code><a class="el" href="group__cpl__table.html#gab781fd7d07eeeea0bf35caa742187e4b" title="Add the values of two numeric or complex table columns.">cpl_table_add_columns()</a></code> for further details. </p>

</div>
</div>
<a id="ga739c5830d599a411ebe34cdea99582b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga739c5830d599a411ebe34cdea99582b2">&#9670;&nbsp;</a></span>cpl_table_multiply_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_multiply_scalar </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a numerical or complex column by a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">value</td><td>Multiplication factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex, or it is an array column.   </td></tr>
</table>
</dd>
</dl>
<p>See the description of the function <code><a class="el" href="group__cpl__table.html#ga883d885ad00da7f95afeb6152b147a2d" title="Add a constant value to a numerical or complex column.">cpl_table_add_scalar()</a></code>. </p>

</div>
</div>
<a id="ga7e78a1ba8e1b3986eece085c440adea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e78a1ba8e1b3986eece085c440adea1">&#9670;&nbsp;</a></span>cpl_table_multiply_scalar_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_multiply_scalar_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a numerical or complex column by a complex constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">value</td><td>Multiplication factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex, or it is an array column.   </td></tr>
</table>
</dd>
</dl>
<p>See the description of the function <code><a class="el" href="group__cpl__table.html#gadb27b0082baf9ca6b1cdcf22446dbe3b" title="Add a constant complex value to a numerical or complex column.">cpl_table_add_scalar_complex()</a></code>. </p>

</div>
</div>
<a id="gaad8efb6812a252e7ef58abc33d48c85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad8efb6812a252e7ef58abc33d48c85c">&#9670;&nbsp;</a></span>cpl_table_name_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_name_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename a table column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">from_name</td><td>Name of table column to rename. </td></tr>
    <tr><td class="paramname">to_name</td><td>New name of column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>from_name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the specified <em>to_name</em> already exists in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>This function is used to change the name of a column. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga1037bec8976297a42ca42da2e26f88b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1037bec8976297a42ca42da2e26f88b4">&#9670;&nbsp;</a></span>cpl_table_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_table* cpl_table_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty table structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Number of rows in table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new table, or <code>NULL</code> in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The specified <em>length</em> is negative.   </td></tr>
</table>
</dd>
</dl>
<p>This function allocates and initialises memory for a table data container. A new table is created with no columns, but the size of the columns that will be created is defined in advance, to ensure that all columns will be created with the same length. All table rows are marked a priori as selected. This should be considered the normal status of a table, as long as no row selection has been applied to it. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, and <a class="el" href="group__cpl__error.html#gad7cf962bbe59df1b5991b17b1a2361a3">cpl_error_set</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__plot.html#ga1bb893c5a03596a48f670c2608dc1b94">cpl_plot_column()</a>, <a class="el" href="group__cpl__plot.html#ga511c1fba8ff96b7bc5ed698ba8ab2d87">cpl_plot_columns()</a>, <a class="el" href="group__cpl__table.html#ga49553a682513ffa3ecd943187653dc40">cpl_table_duplicate()</a>, <a class="el" href="group__cpl__table.html#ga84af52720711c7d4a3ecadce824f47b7">cpl_table_extract()</a>, and <a class="el" href="group__cpl__table.html#gae709603ee26fdd0abdb11f50c8c64e36">cpl_table_extract_selected()</a>.</p>

</div>
</div>
<a id="ga8bece2b610c28f279984da0b126939a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bece2b610c28f279984da0b126939a1">&#9670;&nbsp;</a></span>cpl_table_new_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_new_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty column in a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the new column. </td></tr>
    <tr><td class="paramname">type</td><td>Type of the new column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>type</em> is not supported.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the same <em>name</em> already exists in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>This function allocates memory for a new column of specified <em>type</em>, excluding <em>array</em> types (for creating a column of arrays use the function <code><a class="el" href="group__cpl__table.html#ga410ae9cc07353d506b811ea7982b268b" title="Create an empty column of arrays in a table.">cpl_table_new_column_array()</a></code>, where the column depth must also be specified). The new column name must be different from any other column name in the table. All the elements of the new column are marked as invalid. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#ga86dc059191d3a5b42832fcfcf8efbea2">cpl_table_copy_structure()</a>.</p>

</div>
</div>
<a id="ga410ae9cc07353d506b811ea7982b268b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga410ae9cc07353d506b811ea7982b268b">&#9670;&nbsp;</a></span>cpl_table_new_column_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_new_column_array </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#ga01345c598396c7cd159979734adfb57d">cpl_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty column of arrays in a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the new column. </td></tr>
    <tr><td class="paramname">type</td><td>Type of the new column. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of the new column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified <em>type</em> is not supported.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The specified <em>depth</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the same <em>name</em> already exists in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>This function allocates memory for a new column of specified array <em>type</em>, (for creating a column of simple scalars or character strings use the function <code><a class="el" href="group__cpl__table.html#ga8bece2b610c28f279984da0b126939a1" title="Create an empty column in a table.">cpl_table_new_column()</a></code> instead). It doesn't make any difference if a simple or an array <em>type</em> is specified, the corresponding array type will always be created (e.g., specifying a <em>type</em> <code>CPL_TYPE_INT</code> or a type <code>CPL_TYPE_INT</code> | <code>CPL_TYPE_POINTER</code> would always create a column of type <code>CPL_TYPE_INT</code> | <code>CPL_TYPE_POINTER</code>). The new column name must be different from any other column name in the table. All the elements of the new column are marked as invalid. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7907a24014a3a45aebe5ee1842f0c6f3">CPL_ERROR_INVALID_TYPE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a53e9a61e6c21933902298f9a9d1b2faf">CPL_TYPE_LONG</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#ga86dc059191d3a5b42832fcfcf8efbea2">cpl_table_copy_structure()</a>.</p>

</div>
</div>
<a id="ga57a8c87ae66b61e585dd75f55897d947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57a8c87ae66b61e585dd75f55897d947">&#9670;&nbsp;</a></span>cpl_table_not_selected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_not_selected </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select unselected table rows, and unselect selected ones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
</table>
</dd>
</dl>
<p>Select unselected table rows, and unselect selected ones. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gaf02a5b5398b7df6db4b1778a3b80b2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf02a5b5398b7df6db4b1778a3b80b2bc">&#9670;&nbsp;</a></span>cpl_table_or_selected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_or_selected </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from unselected table rows, by comparing the values of two numerical columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name1</td><td>Name of first table column. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">name2</td><td>Name of second table column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column names are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with any of the specified names is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">Invalid types for comparison.   </td></tr>
</table>
</dd>
</dl>
<p>Either both columns must be numerical, or they both must be strings. The comparison between strings is lexicographical. Comparison between complex types and array types are not supported.</p>
<p>Both columns must be numerical. For all the unselected table rows, the values of the specified columns are compared. The table rows fulfilling the comparison are selected. Invalid elements from either columns never fulfill any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, <code>CPL_NOT_LESS_THAN</code>. See also the function <code><a class="el" href="group__cpl__table.html#ga82421625cbea42334ac39706a35c78c7" title="Select from selected table rows, by comparing the values of two numerical columns.">cpl_table_and_selected()</a></code>. </p>

</div>
</div>
<a id="gad7eb7ef68e7fa7679be43b00c16130d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7eb7ef68e7fa7679be43b00c16130d6">&#9670;&nbsp;</a></span>cpl_table_or_selected_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_or_selected_double </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from unselected table rows, by comparing <em>double</em> column values with a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE</code>.   </td></tr>
</table>
</dd>
</dl>
<p>For all the unselected table rows, the values of the specified column are compared with the reference value. The table rows fulfilling the comparison are selected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, and <code>CPL_NOT_LESS_THAN</code>. If the table has no rows, no error is set, and 0 is returned. See also the description of the function <code><a class="el" href="group__cpl__table.html#gad6c70413f91b920b2d69222a55f0ec65" title="Select from selected table rows, by comparing double column values with a constant.">cpl_table_and_selected_double()</a></code>. </p>

</div>
</div>
<a id="ga6d1d701ac2a9b391ec772545c7d43394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d1d701ac2a9b391ec772545c7d43394">&#9670;&nbsp;</a></span>cpl_table_or_selected_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_or_selected_double_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from unselected table rows, by comparing <em>double</em> complex column values with a complex constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">Operator other than <code>CPL_EQUAL_TO</code> or <code>CPL_NOT_EQUAL_TO</code> was specified.   </td></tr>
</table>
</dd>
</dl>
<p>For all the unselected table rows, the values of the specified column are compared with the reference value. The table rows fulfilling the comparison are selected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code> and <code>CPL_NOT_EQUAL_TO</code>. If the table has no rows, no error is set, and 0 is returned. See also the description of the function <code><a class="el" href="group__cpl__table.html#gaf762d6b431bc22f1d1311d55a7856ac9" title="Select from selected table rows, by comparing double complex column values with a complex constant.">cpl_table_and_selected_double_complex()</a></code>. </p>

</div>
</div>
<a id="ga6d961efcfce7846951421618f42e02a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d961efcfce7846951421618f42e02a8">&#9670;&nbsp;</a></span>cpl_table_or_selected_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_or_selected_float </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from unselected table rows, by comparing <em>float</em> column values with a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>For all the unselected table rows, the values of the specified column are compared with the reference value. The table rows fulfilling the comparison are selected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, and <code>CPL_NOT_LESS_THAN</code>. If the table has no rows, no error is set, and 0 is returned. See also the description of the function <code><a class="el" href="group__cpl__table.html#gadddb1fec819fbf39abeda2e7c86a16ca" title="Select from selected table rows, by comparing float column values with a constant.">cpl_table_and_selected_float()</a></code>. </p>

</div>
</div>
<a id="ga4a1a4a9e8c9ed35fb50083a602ddd42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a1a4a9e8c9ed35fb50083a602ddd42a">&#9670;&nbsp;</a></span>cpl_table_or_selected_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_or_selected_float_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from unselected table rows, by comparing <em>float</em> complex column values with a complex constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT_COMPLEX</code>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">Operator other than <code>CPL_EQUAL_TO</code> or <code>CPL_NOT_EQUAL_TO</code> was specified.   </td></tr>
</table>
</dd>
</dl>
<p>For all the unselected table rows, the values of the specified column are compared with the reference value. The table rows fulfilling the comparison are selected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code> and <code>CPL_NOT_EQUAL_TO</code>. If the table has no rows, no error is set, and 0 is returned. See also the description of the function <code><a class="el" href="group__cpl__table.html#gabef99f98d4a4c50157790ca972c25b94" title="Select from selected table rows, by comparing float complex column values with a complex constant.">cpl_table_and_selected_float_complex()</a></code>. </p>

</div>
</div>
<a id="ga325bc450c8897b9c1ca9fd25ba32c81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga325bc450c8897b9c1ca9fd25ba32c81c">&#9670;&nbsp;</a></span>cpl_table_or_selected_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_or_selected_int </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from unselected table rows, by comparing <em>integer</em> column values with a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_INT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>For all the unselected table rows, the values of the specified column are compared with the reference value. The table rows fulfilling the comparison are selected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, and <code>CPL_NOT_LESS_THAN</code>. If the table has no rows, no error is set, and 0 is returned. See also the description of the function <code><a class="el" href="group__cpl__table.html#ga44c47b0c9a46d29d31e3bd6487d33587" title="Select from selected table rows, by comparing integer column values with a constant.">cpl_table_and_selected_int()</a></code>. </p>

</div>
</div>
<a id="gaaddaba04bfeb32e00823571b8e0d7256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaddaba04bfeb32e00823571b8e0d7256">&#9670;&nbsp;</a></span>cpl_table_or_selected_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_or_selected_invalid </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from unselected table rows all rows with an invalid value in a specified column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>For all the unselected table rows, all the rows containing invalid values at the specified column are selected. See also the function <code><a class="el" href="group__cpl__table.html#gaac4c8ccba7e895bacd6fd615e0d5e251" title="Select from selected table rows all rows with an invalid value in a specified column.">cpl_table_and_selected_invalid()</a></code>. </p>

</div>
</div>
<a id="ga4f979b45dd821ed7437c62f5c5cefc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f979b45dd821ed7437c62f5c5cefc5c">&#9670;&nbsp;</a></span>cpl_table_or_selected_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_or_selected_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from unselected table rows, by comparing <em>long</em> column values with a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>For all the unselected table rows, the values of the specified column are compared with the reference value. The table rows fulfilling the comparison are selected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, and <code>CPL_NOT_LESS_THAN</code>. If the table has no rows, no error is set, and 0 is returned. See also the description of the function <code><a class="el" href="group__cpl__table.html#ga16e29ec76ae16a1b3a331873b4039318" title="Select from selected table rows, by comparing long column values with a constant.">cpl_table_and_selected_long()</a></code>. </p>

</div>
</div>
<a id="ga0401fac11bbc042c15403849869eaca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0401fac11bbc042c15403849869eaca7">&#9670;&nbsp;</a></span>cpl_table_or_selected_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_or_selected_long_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from unselected table rows, by comparing <em>long</em> <em>long</em> column values with a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">value</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>For all the unselected table rows, the values of the specified column are compared with the reference value. The table rows fulfilling the comparison are selected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, and <code>CPL_NOT_LESS_THAN</code>. If the table has no rows, no error is set, and 0 is returned. See also the description of the function <code><a class="el" href="group__cpl__table.html#gac3b53b514f999ed23586e2ce5a279394" title="Select from selected table rows, by comparing long long column values with a constant.">cpl_table_and_selected_long_long()</a></code>. </p>

</div>
</div>
<a id="ga5e7669bb19a22ce09e8e956817b42ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e7669bb19a22ce09e8e956817b42ff6">&#9670;&nbsp;</a></span>cpl_table_or_selected_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_or_selected_string </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_table_select_operator&#160;</td>
          <td class="paramname"><em>operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from unselected table rows, by comparing column values with a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">operator</td><td>Relational operator. </td></tr>
    <tr><td class="paramname">string</td><td>Reference value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_STRING</code>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">Invalid regular expression.   </td></tr>
</table>
</dd>
</dl>
<p>For all the unselected table rows, the values of the specified column are compared with the reference value. The comparison function used is the C standard <code>strcmp()</code>, but in case the relational operators <code>CPL_EQUAL_TO</code> or <code>CPL_NOT_EQUAL_TO</code> are specified, the comparison string is treated as a regular expression. The table rows fulfilling the comparison are selected. An invalid element never fulfills any comparison by definition. Allowed relational operators are <code>CPL_EQUAL_TO</code>, <code>CPL_NOT_EQUAL_TO</code>, <code>CPL_GREATER_THAN</code>, <code>CPL_NOT_GREATER_THAN</code>, <code>CPL_LESS_THAN</code>, and <code>CPL_NOT_LESS_THAN</code>. If the table has no rows, no error is set, and 0 is returned. See also the description of the function <code><a class="el" href="group__cpl__table.html#ga44c357e82b40d5f78ae3ec5d1178ee47" title="Select from selected table rows, by comparing string column values with a character string.">cpl_table_and_selected_string()</a></code>. </p>

</div>
</div>
<a id="ga08c40efe7b94ea825c20a7e6f9cb65ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08c40efe7b94ea825c20a7e6f9cb65ed">&#9670;&nbsp;</a></span>cpl_table_or_selected_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_table_or_selected_window </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select from unselected rows only those within a table segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Table to handle. </td></tr>
    <tr><td class="paramname">start</td><td>First row of table segment. </td></tr>
    <tr><td class="paramname">count</td><td>Length of segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current number of selected rows, or a negative number in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
</table>
</dd>
</dl>
<p>All the unselected table rows that are within the specified interval are selected. If the sum of <em>start</em> and <em>count</em> goes beyond the end of the input table, rows are checked up to the end of the table. See also the function <code><a class="el" href="group__cpl__table.html#gaa2494c547d1e8a7e8933114517c90b2c" title="Select from selected rows only those within a table segment.">cpl_table_and_selected_window()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0d916ea6a7e198a74863ecd9ea03d733">CPL_ERROR_ACCESS_OUT_OF_RANGE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>, and <a class="el" href="group__cpl__table.html#ga70887311ad5f8204315c224517e50cab">cpl_table_select_all()</a>.</p>

</div>
</div>
<a id="gaf1e277e4307ddd1f7122204ce7f20f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1e277e4307ddd1f7122204ce7f20f80">&#9670;&nbsp;</a></span>cpl_table_power_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_power_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the power of numerical column values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of column of numerical type </td></tr>
    <tr><td class="paramname">exponent</td><td>Constant exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>pow(), cpow()</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is not numerical.   </td></tr>
</table>
</dd>
</dl>
<p>Each column element is replaced by its power to the specified exponent. For float and float complex the operation is performed in single precision, otherwise it is performed in double precision and then rounded if the column is of an integer type. Results that would or do cause domain errors or overflow are marked as invalid. </p>

</div>
</div>
<a id="ga70d7631c3956d7e811be1d5e5ab8fad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70d7631c3956d7e811be1d5e5ab8fad2">&#9670;&nbsp;</a></span>cpl_table_real_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_real_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the real part value of table column elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex.   </td></tr>
</table>
</dd>
</dl>
<p>Each column element is replaced by its real party value only. Invalid elements are not modified by this operation. If the column is complex, its type will be turned to real (CPL_TYPE_FLOAT_COMPLEX will be changed into CPL_TYPE_FLOAT, and CPL_TYPE_DOUBLE_COMPLEX will be changed into CPL_TYPE_DOUBLE), and any pointer retrieved by calling <code><a class="el" href="group__cpl__table.html#ga8917beee9df147a5173806902e45a5d0" title="Get a pointer to float complex column data.">cpl_table_get_data_float_complex()</a></code>, <code><a class="el" href="group__cpl__table.html#ga6735ebf8f078b00d846e954f6577c79a" title="Get a pointer to double complex column data.">cpl_table_get_data_double_complex()</a></code>, etc., should be discarded. </p>

</div>
</div>
<a id="ga0f74c8d7e280b0676d890f48a7b48977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f74c8d7e280b0676d890f48a7b48977">&#9670;&nbsp;</a></span>cpl_table_save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_save </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpl__propertylist.html#gab1629461e5d64dd8594cd505e3ea46ab">cpl_propertylist</a> *&#160;</td>
          <td class="paramname"><em>pheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpl__propertylist.html#gab1629461e5d64dd8594cd505e3ea46ab">cpl_propertylist</a> *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a <em>cpl_table</em> to a FITS file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Input table. </td></tr>
    <tr><td class="paramname">pheader</td><td>Primary header entries. </td></tr>
    <tr><td class="paramname">header</td><td>Table header entries. </td></tr>
    <tr><td class="paramname">filename</td><td>Name of output FITS file. </td></tr>
    <tr><td class="paramname">mode</td><td>Output mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>filename</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_UNSUPPORTED_MODE </td><td class="ecr">A saving mode other than <code>CPL_IO_CREATE</code> and <code>CPL_IO_EXTEND</code> was specified.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_FILE_NOT_FOUND </td><td class="ecr">While <em>mode</em> is set to <code>CPL_IO_EXTEND</code>, a file named as specified in <em>filename</em> is not found.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_BAD_FILE_FORMAT </td><td class="ecr">While <em>mode</em> is set to <code>CPL_IO_EXTEND</code>, the specified file is not in FITS format.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_FILE_NOT_CREATED </td><td class="ecr">The FITS file could not be created.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_FILE_IO </td><td class="ecr">The FITS file could only partially be created.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_UNSPECIFIED </td><td class="ecr">Generic error condition, that should be reported to the CPL Team.   </td></tr>
</table>
</dd>
</dl>
<p>This function can be used to convert a CPL table into a binary FITS table extension. If the <em>mode</em> is set to <code>CPL_IO_CREATE</code>, a new FITS file will be created containing an empty primary array, with just one FITS table extension. An existing (and writable) FITS file with the same name would be overwritten. If the <em>mode</em> flag is set to <code>CPL_IO_EXTEND</code>, a new table extension would be appended to an existing FITS file. If <em>mode</em> is set to <code>CPL_IO_APPEND</code> it is possible to add rows to the last FITS table extension of the output FITS file.</p>
<p>Note that the modes <code>CPL_IO_EXTEND</code> and <code>CPL_IO_APPEND</code> require that the target file must be writable (and do not take for granted that a file is writable just because it was created by the same application, as this depends on the system <em>umask</em>).</p>
<p>When using the mode <code>CPL_IO_APPEND</code> additional requirements must be fulfilled, which are that the column properties like type, format, units, etc. must match as the properties of the FITS table extension to which the rows should be added exactly. In particular this means that both tables use the same null value representation for integral type columns!</p>
<p>Two property lists may be passed to this function, both optionally. The first property list, <em>pheader</em>, is just used if the <em>mode</em> is set to <code>CPL_IO_CREATE</code>, and it is assumed to contain entries for the FITS file primary header. In <em>pheader</em> any property name related to the FITS convention, as SIMPLE, BITPIX, NAXIS, EXTEND, BLOCKED, and END, are ignored: such entries would be written anyway to the primary header and set to some standard values.</p>
<p>If a <code>NULL</code> <em>pheader</em> is passed, the primary array would be created with just such entries, that are mandatory in any regular FITS file. The second property list, <em>header</em>, is assumed to contain entries for the FITS table extension header. In this property list any property name related to the FITS convention, as XTENSION, BITPIX, NAXIS, PCOUNT, GCOUNT, and END, and to the table structure, as TFIELDS, TTYPEi, TUNITi, TDISPi, TNULLi, TFORMi, would be ignored: such entries are always computed internally, to guarantee their consistency with the actual table structure. A DATE keyword containing the date of table creation in ISO8601 format is also added automatically.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Invalid strings in columns of type <code>CPL_TYPE_STRING</code> are written to FITS as blanks.</li>
<li>Invalid values in columns of type <code>CPL_TYPE_FLOAT</code> or <code>CPL_TYPE_DOUBLE</code> will be written to the FITS file as a <code>NaN</code>.</li>
<li>Invalid values in columns of type <code>CPL_TYPE_INT</code> and <code>CPL_TYPE_LONG_LONG</code> are the only ones that need a specific code to be explicitly assigned to them. This can be realised by calling the functions <a class="el" href="group__cpl__table.html#ga0041fc2ebc6cf8c41693298b91a91551" title="Write a numerical value to invalid integer column elements.">cpl_table_fill_invalid_int()</a> and <a class="el" href="group__cpl__table.html#ga96bffe508ceab3b4b0c33cbb7475ad64" title="Write a numerical value to invalid long long column elements.">cpl_table_fill_invalid_long_long()</a>, respectively, for each table column of type <code>CPL_TYPE_INT</code> and <code>CPL_TYPE_LONG_LONG</code> containing invalid values, just before saving the table to FITS. The numerical values identifying invalid integer column elements are written to the FITS keywords TNULLn (where n is the column sequence number). Beware that if valid column elements have the value identical to the chosen null-code, they will also be considered invalid in the FITS convention.</li>
<li>Using the mode <code>CPL_IO_APPEND</code> requires that the column properties of the table to be appended are compared to the column properties of the target FITS extension for each call, which introduces a certain overhead. This means that appending a single table row at a time may not be efficient and is not recommended. Rather than writing one row at a time one should write table chunks containing a suitable number or rows. </li>
</ul>
</dd></dl>

<p class="reference">References <a class="el" href="group__cpl__io.html#ggaeaee6d6dbefbfc273111e19988b50d77a08a0f46257ed2737f42d20ae910bb407">CPL_IO_APPEND</a>.</p>

</div>
</div>
<a id="ga70887311ad5f8204315c224517e50cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70887311ad5f8204315c224517e50cab">&#9670;&nbsp;</a></span>cpl_table_select_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_select_all </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select all table rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
</table>
</dd>
</dl>
<p>The table selection flags are reset, meaning that they are all marked as selected. This is the initial state of any table. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#ga397f3c878f110930bfe64b537c5d417c">cpl_table_erase_invalid()</a>, <a class="el" href="group__cpl__table.html#ga5c318a3f2c02b47e8c1fb4ccc019af1b">cpl_table_erase_invalid_rows()</a>, <a class="el" href="group__cpl__table.html#gab9b708efb1c519be18d680f26c947d8d">cpl_table_erase_selected()</a>, <a class="el" href="group__cpl__table.html#ga8e3777a49d3efd72eeb137af1c47176e">cpl_table_erase_window()</a>, <a class="el" href="group__cpl__table.html#ga5a0a1d35143d200b5ad1202672e10332">cpl_table_insert_window()</a>, <a class="el" href="group__cpl__table.html#ga08c40efe7b94ea825c20a7e6f9cb65ed">cpl_table_or_selected_window()</a>, and <a class="el" href="group__cpl__table.html#gaa139114ea5112984ef62fb95e6da33ae">cpl_table_set_size()</a>.</p>

</div>
</div>
<a id="gaaaba2ece26c596b6c0084d2d38096ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaba2ece26c596b6c0084d2d38096ede">&#9670;&nbsp;</a></span>cpl_table_select_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_select_row </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag a table row as selected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">row</td><td>Row to select.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
</table>
</dd>
</dl>
<p>Flag a table row as selected. Any previous selection is kept. </p>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0d916ea6a7e198a74863ecd9ea03d733">CPL_ERROR_ACCESS_OUT_OF_RANGE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>.</p>

</div>
</div>
<a id="gaca7c44d01dd266c65057e7c43bb4b8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca7c44d01dd266c65057e7c43bb4b8ed">&#9670;&nbsp;</a></span>cpl_table_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a numerical table column element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is not numerical, or it is of type <em>array</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Write a value to a numerical column element. The value is cast to the accessed column type according to the C casting rules. The written value is automatically marked as valid. To invalidate a column value use <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code>. Table rows are counted starting from 0. </p>

</div>
</div>
<a id="ga506a2e3a103198edcb2fd5a79480a75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga506a2e3a103198edcb2fd5a79480a75a">&#9670;&nbsp;</a></span>cpl_table_set_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_array </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an array to an <em>array</em> table column element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position where to write the array. </td></tr>
    <tr><td class="paramname">array</td><td>Array to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <em>array</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INCOMPATIBLE_INPUT </td><td class="ecr">The size of the input <em>array</em> is different from the depth of the specified column.   </td></tr>
</table>
</dd>
</dl>
<p>Write an array to a table column of type <em>array</em>. The written value can also be a <code>NULL</code> pointer, that is equivalent to a call to <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code>. Note that the array is copied, therefore the original can be modified without affecting the table element. To "plug" an array directly into a table element, use the function <code><a class="el" href="group__cpl__table.html#gae7f05cb05cdfdf3723d786d9ce89c23e" title="Get a pointer to array column data.">cpl_table_get_data_array()</a></code>. Beware that the "plugged" array must have the same type and depth declared for the column. </p>

</div>
</div>
<a id="ga7df89d3fd9ce5aebdfd018d4d0e968eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7df89d3fd9ce5aebdfd018d4d0e968eb">&#9670;&nbsp;</a></span>cpl_table_set_column_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_column_depth </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify depth of a column of arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">depth</td><td>New column depth.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any input argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The specified new depth is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The column with the specified <em>name</em> is not an <em>array</em> type.   </td></tr>
</table>
</dd>
</dl>
<p>This function is applicable just to columns of arrays. The contents of the arrays in the specified column will be unchanged up to the lesser of the new and old depths. If the depth is increased, the extra array elements would be flagged as invalid. The pointers to array data may change, therefore pointers previously retrieved by calling <code><a class="el" href="group__cpl__array.html#gaef6ce495b8cff38332106ba3242a2c9f" title="Get a pointer to integer array data.">cpl_array_get_data_int()</a></code>, <code><a class="el" href="group__cpl__array.html#ga0e5d705ae246e2580532d51589f979c5" title="Get a pointer to string array data.">cpl_array_get_data_string()</a></code>, etc. should be discarded. </p>

</div>
</div>
<a id="ga058c918b739f1020af64ca02c6f5a9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga058c918b739f1020af64ca02c6f5a9be">&#9670;&nbsp;</a></span>cpl_table_set_column_dimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_column_dimensions </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_array *&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the dimensions of a table column of arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">dimensions</td><td>Integer array containing the sizes of the column dimensions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">Either the specified column is not of type <em>array</em>, or the <em>dimensions</em> array contains invalid elements.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The <em>dimensions</em> array is not of type <code>CPL_TYPE_INT</code>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INCOMPATIBLE_INPUT </td><td class="ecr">The specified dimensions are incompatible with the total number of elements in the column arrays.   </td></tr>
</table>
</dd>
</dl>
<p>Set the number of dimensions of a column. If the <em>dimensions</em> array has size less than 2, nothing is done and no error is returned. </p>

</div>
</div>
<a id="ga5916e21f121e842497d0f4df418a9768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5916e21f121e842497d0f4df418a9768">&#9670;&nbsp;</a></span>cpl_table_set_column_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_column_format </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give a new format to a table column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">format</td><td>New format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>The input format string is duplicated before being used as the column format. If <em>format</em> is a <code>NULL</code> pointer, "%%s" will be used if the column is of type <code>CPL_TYPE_STRING</code>, "% 1.5e" if the column is of type <code>CPL_TYPE_FLOAT</code> or <code>CPL_TYPE_DOUBLE</code>, and "% 7d" if it is of type <code>CPL_TYPE_INT</code>. The format associated to a column has no effect on any operation performed on columns, and it is used just in the <code>printf()</code> calls made while printing a table using the function <code><a class="el" href="group__cpl__table.html#gacd790a348822ac1e02165c1e2b9435c4" title="Print a table.">cpl_table_dump()</a></code>. This information is lost after saving the table in FITS format using <code><a class="el" href="group__cpl__table.html#ga0f74c8d7e280b0676d890f48a7b48977" title="Save a cpl_table to a FITS file.">cpl_table_save()</a></code>. </p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#ga86dc059191d3a5b42832fcfcf8efbea2">cpl_table_copy_structure()</a>.</p>

</div>
</div>
<a id="ga9b6b87265e160eb355a3e2bb6d423e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b6b87265e160eb355a3e2bb6d423e2d">&#9670;&nbsp;</a></span>cpl_table_set_column_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_column_invalid </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate a column segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">start</td><td>Position where to begin invalidation. </td></tr>
    <tr><td class="paramname">count</td><td>Number of column elements to invalidate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>start</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr"><em>count</em> is negative.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>All the column elements in the specified interval are invalidated. In the case of either a <em>string</em> or an <em>array</em> column, the corresponding strings or arrays are set free. If the sum of <em>start</em> and <em>count</em> exceeds the number of rows in the table, the column is invalidated up to its end. </p>

</div>
</div>
<a id="ga52cb75b79daab6a9356331ec3f60c2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52cb75b79daab6a9356331ec3f60c2a7">&#9670;&nbsp;</a></span>cpl_table_set_column_unit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_column_unit </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give a new unit to a table column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">unit</td><td>New unit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>The input unit string is duplicated before being used as the column unit. If <em>unit</em> is a <code>NULL</code> pointer, the column will be unitless. The unit associated to a column has no effect on any operation performed on columns, and it must be considered just an optional description of the content of a column. It is however saved to a FITS file when using <a class="el" href="group__cpl__table.html#ga0f74c8d7e280b0676d890f48a7b48977" title="Save a cpl_table to a FITS file.">cpl_table_save()</a>. </p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#ga86dc059191d3a5b42832fcfcf8efbea2">cpl_table_copy_structure()</a>.</p>

</div>
</div>
<a id="ga625940482a9c3316d02ee87702385d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga625940482a9c3316d02ee87702385d5f">&#9670;&nbsp;</a></span>cpl_table_set_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a complex value to a complex numerical table column element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is not complex, or it is of type <em>array</em>.   </td></tr>
</table>
</dd>
</dl>
<p>Write a value to a complex column element. The value is cast to the accessed column type according to the C casting rules. The written value is automatically marked as valid. To invalidate a column value use <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code>. Table rows are counted starting from 0. </p>

</div>
</div>
<a id="gaae6b30390dd403a7ea2a3a4cd1ce8f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae6b30390dd403a7ea2a3a4cd1ce8f4f">&#9670;&nbsp;</a></span>cpl_table_set_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_double </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>double</em> table column element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write a value to a table column of type <code>CPL_TYPE_DOUBLE</code>. The written value is automatically marked as valid. To invalidate a column value use <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code>. Table rows are counted starting from 0.</p>
<dl class="section note"><dt>Note</dt><dd>For automatic conversion to the column type, use the function <code><a class="el" href="group__cpl__table.html#gaca7c44d01dd266c65057e7c43bb4b8ed" title="Write a value to a numerical table column element.">cpl_table_set()</a></code>. </dd></dl>

</div>
</div>
<a id="ga6e12227fcd9e1cc3a99697dba99f5bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e12227fcd9e1cc3a99697dba99f5bd3">&#9670;&nbsp;</a></span>cpl_table_set_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_double_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>double</em> complex table column element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write a value to a table column of type <code>CPL_TYPE_DOUBLE_COMPLEX</code>. The written value is automatically marked as valid. To invalidate a column value use <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code>. Table rows are counted starting from 0.</p>
<dl class="section note"><dt>Note</dt><dd>For automatic conversion to the column type, use the function <code><a class="el" href="group__cpl__table.html#ga625940482a9c3316d02ee87702385d5f" title="Write a complex value to a complex numerical table column element.">cpl_table_set_complex()</a></code>. </dd></dl>

</div>
</div>
<a id="gaae498ebf22f6233c3c7e4e61e51fdf65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae498ebf22f6233c3c7e4e61e51fdf65">&#9670;&nbsp;</a></span>cpl_table_set_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_float </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>float</em> table column element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write a value to a table column of type <code>CPL_TYPE_FLOAT</code>. The written value is automatically marked as valid. To invalidate a column value use <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code>. Table rows are counted starting from 0.</p>
<dl class="section note"><dt>Note</dt><dd>For automatic conversion to the column type, use the function <code><a class="el" href="group__cpl__table.html#gaca7c44d01dd266c65057e7c43bb4b8ed" title="Write a value to a numerical table column element.">cpl_table_set()</a></code>. </dd></dl>

</div>
</div>
<a id="ga1dca7192d34f1695b637a8548a34969d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dca7192d34f1695b637a8548a34969d">&#9670;&nbsp;</a></span>cpl_table_set_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_float_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a <em>float</em> complex table column element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_FLOAT_COMPLEX</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write a value to a table column of type <code>CPL_TYPE_FLOAT_COMPLEX</code>. The written value is automatically marked as valid. To invalidate a column value use <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code>. Table rows are counted starting from 0.</p>
<dl class="section note"><dt>Note</dt><dd>For automatic conversion to the column type, use the function <code><a class="el" href="group__cpl__table.html#ga625940482a9c3316d02ee87702385d5f" title="Write a complex value to a complex numerical table column element.">cpl_table_set_complex()</a></code>. </dd></dl>

</div>
</div>
<a id="ga2661451495142c1893c377351ce86ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2661451495142c1893c377351ce86ce0">&#9670;&nbsp;</a></span>cpl_table_set_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_int </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to an <em>integer</em> table column element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_INT</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write a value to a table column of type <code>CPL_TYPE_INT</code>. The written value is automatically marked as valid. To invalidate a column value use <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code>. Table rows are counted starting from 0.</p>
<dl class="section note"><dt>Note</dt><dd>For automatic conversion to the column type, use the function <code><a class="el" href="group__cpl__table.html#gaca7c44d01dd266c65057e7c43bb4b8ed" title="Write a value to a numerical table column element.">cpl_table_set()</a></code>. </dd></dl>

</div>
</div>
<a id="gab1c5943ee40c3c71fb2e3634124e970b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1c5943ee40c3c71fb2e3634124e970b">&#9670;&nbsp;</a></span>cpl_table_set_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_invalid </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag a column element as invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Row where to write a <em>null</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>In the case of either a <em>string</em> or an <em>array</em> column, the corresponding string or array is set free and its pointer is set to <code>NULL</code>. For other data types, the corresponding table element is flagged internally as invalid. </p>

</div>
</div>
<a id="gadf41fbef5f14437f50279b0cad416250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf41fbef5f14437f50279b0cad416250">&#9670;&nbsp;</a></span>cpl_table_set_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to an <em>long</em> table column element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write a value to a table column of type <code>CPL_TYPE_LONG</code>. The written value is automatically marked as valid. To invalidate a column value use <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code>. Table rows are counted starting from 0.</p>
<dl class="section note"><dt>Note</dt><dd>For automatic conversion to the column type, use the function <code><a class="el" href="group__cpl__table.html#gaca7c44d01dd266c65057e7c43bb4b8ed" title="Write a value to a numerical table column element.">cpl_table_set()</a></code>. </dd></dl>

</div>
</div>
<a id="ga9a0be2532142967c89f2b6e424e205a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a0be2532142967c89f2b6e424e205a3">&#9670;&nbsp;</a></span>cpl_table_set_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_long_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to an <em>long</em> <em>long</em> table column element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position where to write value. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_LONG_LONG</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write a value to a table column of type <code>CPL_TYPE_LONG_LONG</code>. The written value is automatically marked as valid. To invalidate a column value use <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code>. Table rows are counted starting from 0.</p>
<dl class="section note"><dt>Note</dt><dd>For automatic conversion to the column type, use the function <code><a class="el" href="group__cpl__table.html#gaca7c44d01dd266c65057e7c43bb4b8ed" title="Write a value to a numerical table column element.">cpl_table_set()</a></code>. </dd></dl>

</div>
</div>
<a id="gaa139114ea5112984ef62fb95e6da33ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa139114ea5112984ef62fb95e6da33ae">&#9670;&nbsp;</a></span>cpl_table_set_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_size </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>new_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a table to a new number of rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">new_length</td><td>New number of rows in table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The specified new length is negative.   </td></tr>
</table>
</dd>
</dl>
<p>The contents of the columns will be unchanged up to the lesser of the new and old sizes. If the table is expanded, the extra table rows would just contain invalid elements. The table selection flags are set back to "all selected". The pointer to column data may change, therefore pointers previously retrieved by calling <code><a class="el" href="group__cpl__table.html#gaff3998d07c6cbf88d0297648bce6f6f4" title="Get a pointer to integer column data.">cpl_table_get_data_int()</a></code>, <code><a class="el" href="group__cpl__table.html#ga48cf0bd4ad1b6e820699ab1edb1318e6" title="Get a pointer to string column data.">cpl_table_get_data_string()</a></code>, etc. should be discarded. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__table.html#gaec958c1ed4794abf6b4a814a7063dfb0">cpl_table_get_ncol()</a>, and <a class="el" href="group__cpl__table.html#ga70887311ad5f8204315c224517e50cab">cpl_table_select_all()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__table.html#gab9b708efb1c519be18d680f26c947d8d">cpl_table_erase_selected()</a>.</p>

</div>
</div>
<a id="gaf67725799ee9368dfb58f9650713a867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf67725799ee9368dfb58f9650713a867">&#9670;&nbsp;</a></span>cpl_table_set_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_set_string </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a character string to a <em>string</em> table column element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to access. </td></tr>
    <tr><td class="paramname">row</td><td>Position where to write the character string. </td></tr>
    <tr><td class="paramname">value</td><td>Character string to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The specified column is not of type <code>CPL_TYPE_STRING</code>.   </td></tr>
</table>
</dd>
</dl>
<p>Write a string to a table column of type <code>CPL_TYPE_STRING</code>. The written value can also be a <code>NULL</code> pointer, that is equivalent to a call to <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code>. Note that the character string is copied, therefore the original can be modified without affecting the table element. To "plug" a character string directly into a table element, use the function <code><a class="el" href="group__cpl__table.html#ga48cf0bd4ad1b6e820699ab1edb1318e6" title="Get a pointer to string column data.">cpl_table_get_data_string()</a></code>. </p>

</div>
</div>
<a id="gab92d31d871ee1a0b4d5326eabe1e2479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab92d31d871ee1a0b4d5326eabe1e2479">&#9670;&nbsp;</a></span>cpl_table_shift_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_shift_column </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift the position of numeric or complex column values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of table column to shift. </td></tr>
    <tr><td class="paramname">shift</td><td>Shift column values by so many rows.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The absolute value of <em>shift</em> is greater than the column length.   </td></tr>
</table>
</dd>
</dl>
<p>The position of all column values is shifted by the specified amount. If <em>shift</em> is positive, all values will be moved toward the bottom of the column, otherwise toward its top. In either case as many column elements as the amount of the <em>shift</em> will be left undefined, either at the top or at the bottom of the column according to the direction of the shift. These column elements will be marked as invalid. This function is applicable just to numeric and complex columns, and not to strings and or array types. The selection flags are always set back to "all selected" after this operation. </p>

</div>
</div>
<a id="gae0ab7c9854c84aa8de64e2653d34d310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0ab7c9854c84aa8de64e2653d34d310">&#9670;&nbsp;</a></span>cpl_table_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_sort </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpl__propertylist.html#gab1629461e5d64dd8594cd505e3ea46ab">cpl_propertylist</a> *&#160;</td>
          <td class="paramname"><em>reflist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort table rows according to columns values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">reflist</td><td>Names of reference columns with corresponding sorting mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or <em>reflist</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">Any reference column specified in <em>reflist</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_INPUT </td><td class="ecr">The size of <em>reflist</em> exceeds the total number of columns in <em>table</em>, or <em>reflist</em> is empty.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_TYPE_MISMATCH </td><td class="ecr">The input <em>reflist</em> includes properties of type different from <code>CPL_TYPE_BOOL</code>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_UNSUPPORTED_MODE </td><td class="ecr">Any reference column specified in <em>reflist</em> is of type <em>array</em>.   </td></tr>
</table>
</dd>
</dl>
<p>The table rows are sorted according to the values of the specified reference columns. The reference column names are listed in the input <em>reflist</em>, that associates to each reference column a boolean value. If the associated value is <code>FALSE</code>, the table is sorted according to the ascending values of the specified column, otherwise if the associated value is <code>TRUE</code>, the table is sorted according to the descending values of that column. The sorting will be performed by comparing the values of the first reference column; if the compared values are equal, the values from the next column in the list are compared, and so on till the end of the reference columns list. An invalid table element is always treated as if it doesn't fulfill any comparison, i.e., sorting either by increasing or decreasing column values would accumulate invalid elements toward the top of the table. The sorting is made in-place, therefore pointers to data retrieved with calls to <code>cpl_table_get_data_&lt;TYPE&gt;()</code> remain valid. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__memory.html#gac884edcb0a592489c65239d0e5d08785">cpl_malloc()</a>, and <a class="el" href="group__cpl__propertylist.html#ga04b26b4c955d73cefa08fa11ceaacacb">cpl_propertylist_get_size()</a>.</p>

</div>
</div>
<a id="ga18a1cdd93f6fefd5a33e662f9e1df9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18a1cdd93f6fefd5a33e662f9e1df9ef">&#9670;&nbsp;</a></span>cpl_table_subtract_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_subtract_columns </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract two numeric or complex table columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">to_name</td><td>Name of target column. </td></tr>
    <tr><td class="paramname">from_name</td><td>Name of column to be subtracted from target column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or any column name are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with any specified name is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">Any specified column is neither numerical non complex, or it is an array column.   </td></tr>
</table>
</dd>
</dl>
<p>The columns are subtracted element by element, and the result of the subtraction is stored in the target column. See the documentation of the function <code><a class="el" href="group__cpl__table.html#gab781fd7d07eeeea0bf35caa742187e4b" title="Add the values of two numeric or complex table columns.">cpl_table_add_columns()</a></code> for further details. </p>

</div>
</div>
<a id="gafa947c64513c1e72bb7f9524c77b383d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa947c64513c1e72bb7f9524c77b383d">&#9670;&nbsp;</a></span>cpl_table_subtract_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_subtract_scalar </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract a constant value from a numerical or complex column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">value</td><td>Value to subtract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex, or it is an array column.   </td></tr>
</table>
</dd>
</dl>
<p>See the description of the function <code><a class="el" href="group__cpl__table.html#ga883d885ad00da7f95afeb6152b147a2d" title="Add a constant value to a numerical or complex column.">cpl_table_add_scalar()</a></code>. </p>

</div>
</div>
<a id="gaf1c1e241b7c3544d4785d6fc0f2318c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1c1e241b7c3544d4785d6fc0f2318c9">&#9670;&nbsp;</a></span>cpl_table_subtract_scalar_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_subtract_scalar_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract a constant complex value from a numerical or complex column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Column name. </td></tr>
    <tr><td class="paramname">value</td><td>Value to subtract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> or column <em>name</em> are <code>NULL</code> pointers.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the specified <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_INVALID_TYPE </td><td class="ecr">The specified column is neither numerical nor complex, or it is an array column.   </td></tr>
</table>
</dd>
</dl>
<p>See the description of the function <code><a class="el" href="group__cpl__table.html#gadb27b0082baf9ca6b1cdcf22446dbe3b" title="Add a constant complex value to a numerical or complex column.">cpl_table_add_scalar_complex()</a></code>. </p>

</div>
</div>
<a id="gae35f77711a7fcceb0648d879a4073ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae35f77711a7fcceb0648d879a4073ec1">&#9670;&nbsp;</a></span>cpl_table_unselect_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_unselect_all </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unselect all table rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
</table>
</dd>
</dl>
<p>The table selection flags are all unset, meaning that no table rows are selected. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>.</p>

</div>
</div>
<a id="ga1cb9aab012cd788cc30c2e742899fbdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cb9aab012cd788cc30c2e742899fbdb">&#9670;&nbsp;</a></span>cpl_table_unselect_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_unselect_row </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag a table row as unselected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">row</td><td>Row to unselect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ACCESS_OUT_OF_RANGE </td><td class="ecr">The input <em>table</em> has zero length, or <em>row</em> is outside the table boundaries.   </td></tr>
</table>
</dd>
</dl>
<p>Flag a table row as unselected. Any previous selection is kept. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0d916ea6a7e198a74863ecd9ea03d733">CPL_ERROR_ACCESS_OUT_OF_RANGE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>, and <a class="el" href="group__cpl__memory.html#gac884edcb0a592489c65239d0e5d08785">cpl_malloc()</a>.</p>

</div>
</div>
<a id="ga493cee1969a8fff7ee9cd80df40d29b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga493cee1969a8fff7ee9cd80df40d29b7">&#9670;&nbsp;</a></span>cpl_table_unwrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cpl_table_unwrap </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unwrap a table column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to internal data buffer, <code>NULL</code> in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_DATA_NOT_FOUND </td><td class="ecr">A column with the given <em>name</em> is not found in <em>table</em>.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_UNSUPPORTED_MODE </td><td class="ecr">The column with the given <em>name</em> is a column of arrays.   </td></tr>
</table>
</dd>
</dl>
<p>This function deallocates all the memory associated to a table column, with the exception of its data buffer. This type of destructor should be used on columns created with the <code>cpl_table_wrap_&lt;type&gt;()</code> constructors, if the data buffer specified then was not allocated using the functions of the <code>cpl_memory</code> module. In such a case, the data buffer should be deallocated separately. See the documentation of the functions <code>cpl_table_wrap_&lt;type&gt;()</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Columns of arrays cannot be unwrapped. Use the function <code><a class="el" href="group__cpl__table.html#gae7f05cb05cdfdf3723d786d9ce89c23e" title="Get a pointer to array column data.">cpl_table_get_data_array()</a></code> to directly access the column data buffer. </dd></dl>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a74ef8e37f3412e85cfc22840d13bdd0c">CPL_ERROR_UNSUPPORTED_MODE</a>, <a class="el" href="group__cpl__table.html#ga02d329749056a40390df1555c4021032">cpl_table_get_column_type()</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a>.</p>

</div>
</div>
<a id="gabbcd8712863836e78e6960722ae1ab96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbcd8712863836e78e6960722ae1ab96">&#9670;&nbsp;</a></span>cpl_table_where_selected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_array* cpl_table_where_selected </td>
          <td>(</td>
          <td class="paramtype">const cpl_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get array of indexes to selected table rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indexes to selected table rows, or NULL in case of error.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Input <em>table</em> is a <code>NULL</code> pointer.   </td></tr>
</table>
</dd>
</dl>
<p>Get array of indexes to selected table rows. If no rows are selected, an array of size zero is returned. The returned array must be deleted using <code><a class="el" href="group__cpl__array.html#ga6bffcca34e6751f1e5c2db6497be2074" title="Delete an array.">cpl_array_delete()</a></code>. </p>

<p class="reference">References <a class="el" href="group__cpl__array.html#ga83f215dd3642ac04434dc11f19cfb531">cpl_array_fill_window()</a>, <a class="el" href="group__cpl__array.html#gabb15b7dfc7335f0e3aa0758349ab01cb">cpl_array_get_data_cplsize()</a>, <a class="el" href="group__cpl__array.html#gaf7d187111491f2d3a8b50fff01fbad17">cpl_array_new()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a46fa44e4ea49bfa00a5c11f1a52228a6">CPL_TYPE_SIZE</a>.</p>

</div>
</div>
<a id="ga759812f0f8872e7c6ff978daa89c4697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga759812f0f8872e7c6ff978daa89c4697">&#9670;&nbsp;</a></span>cpl_table_wrap_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_wrap_double </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create in table a new <em>double</em> column obtained from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the new column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the same <em>name</em> already exists in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>This function creates a new column of type <code>CPL_TYPE_DOUBLE</code> that will encapsulate the given data. See the description of <code><a class="el" href="group__cpl__table.html#gacb3eaa902753fcfe2141e8fa58698cc6" title="Create in table a new integer column obtained from existing data.">cpl_table_wrap_int()</a></code> for further details. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gab25db3fd9b98bfd2e8927246678f9df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab25db3fd9b98bfd2e8927246678f9df7">&#9670;&nbsp;</a></span>cpl_table_wrap_double_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_wrap_double_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double complex *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create in table a new <em>double</em> complex column from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the new column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the same <em>name</em> already exists in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>This function creates a new column of type <code>CPL_TYPE_FLOAT_COMPLEX</code> that will encapsulate the given data. See the description of <code><a class="el" href="group__cpl__table.html#gacb3eaa902753fcfe2141e8fa58698cc6" title="Create in table a new integer column obtained from existing data.">cpl_table_wrap_int()</a></code> for further details. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gafff16f9ee7e1d009cad25a4f0e6a4609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafff16f9ee7e1d009cad25a4f0e6a4609">&#9670;&nbsp;</a></span>cpl_table_wrap_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_wrap_float </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create in table a new <em>float</em> column obtained from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the new column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the same <em>name</em> already exists in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>This function creates a new column of type <code>CPL_TYPE_FLOAT</code> that will encapsulate the given data. See the description of <code><a class="el" href="group__cpl__table.html#gacb3eaa902753fcfe2141e8fa58698cc6" title="Create in table a new integer column obtained from existing data.">cpl_table_wrap_int()</a></code> for further details. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga6f2fc0d2dce1a9a00efb67e23d123c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f2fc0d2dce1a9a00efb67e23d123c90">&#9670;&nbsp;</a></span>cpl_table_wrap_float_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_wrap_float_complex </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float complex *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create in table a new <em>float</em> complex column obtained from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the new column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the same <em>name</em> already exists in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>This function creates a new column of type <code>CPL_TYPE_FLOAT_COMPLEX</code> that will encapsulate the given data. See the description of <code><a class="el" href="group__cpl__table.html#gacb3eaa902753fcfe2141e8fa58698cc6" title="Create in table a new integer column obtained from existing data.">cpl_table_wrap_int()</a></code> for further details. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gacb3eaa902753fcfe2141e8fa58698cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb3eaa902753fcfe2141e8fa58698cc6">&#9670;&nbsp;</a></span>cpl_table_wrap_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_wrap_int </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create in table a new <em>integer</em> column obtained from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table where to create the new column. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the new column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the same <em>name</em> already exists in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>This function creates a new column of type <code>CPL_TYPE_INT</code> that will encapsulate the given data. The size of the input data array is not checked in any way, and it is expected to match the number of rows assigned to the given table. The pointed data values are all taken as valid: invalid values should be marked using the functions <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code> and <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code>. The data buffer is not copied, so it should not be deallocated while the table column is still in use: the functions <code><a class="el" href="group__cpl__table.html#gabdfca1c1b3478ce6bcc3f4340131adba" title="Delete a column from a table.">cpl_table_erase_column()</a></code> or <code><a class="el" href="group__cpl__table.html#ga7fa13d6c00a323556c31bd531d6dc00c" title="Delete a table.">cpl_table_delete()</a></code> would take care of deallocating it. To avoid problems with the memory managment, the specified data buffer should have been allocated using the functions of the <em>cpl_memory</em> module, and statically allocated data should be avoided too. If this is not possible, then the function <code><a class="el" href="group__cpl__table.html#ga493cee1969a8fff7ee9cd80df40d29b7" title="Unwrap a table column.">cpl_table_unwrap()</a></code> should be used on that column before destroying the table that contains it. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gac48f93a714c37cf86ad6cc6ae07f503a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac48f93a714c37cf86ad6cc6ae07f503a">&#9670;&nbsp;</a></span>cpl_table_wrap_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_wrap_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create in table a new <em>long</em> column obtained from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the new column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the same <em>name</em> already exists in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>This function creates a new column of type <code>CPL_TYPE_LONG</code> that will encapsulate the given data. See the description of <code><a class="el" href="group__cpl__table.html#gacb3eaa902753fcfe2141e8fa58698cc6" title="Create in table a new integer column obtained from existing data.">cpl_table_wrap_int()</a></code> for further details. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga4e6e8ba79efaabab49b3a45524b853fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e6e8ba79efaabab49b3a45524b853fc">&#9670;&nbsp;</a></span>cpl_table_wrap_long_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_wrap_long_long </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create in table a new <em>long</em> <em>long</em> column obtained from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the new column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the same <em>name</em> already exists in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>This function creates a new column of type <code>CPL_TYPE_LONG_LONG</code> that will encapsulate the given data. See the description of <code><a class="el" href="group__cpl__table.html#gacb3eaa902753fcfe2141e8fa58698cc6" title="Create in table a new integer column obtained from existing data.">cpl_table_wrap_int()</a></code> for further details. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga02ba1a4fd4162e31a05d6f737dbf44c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02ba1a4fd4162e31a05d6f737dbf44c6">&#9670;&nbsp;</a></span>cpl_table_wrap_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_table_wrap_string </td>
          <td>(</td>
          <td class="paramtype">cpl_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create in table a new <em>string</em> column obtained from existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the new column. </td></tr>
    <tr><td class="paramname">data</td><td>Existing data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<dl class="exception">
<dt><b>Errors</b></dt>
<dd></dd>
<dt></dt>
<dd><table class="ec" align="center">
<tr>
<td class="ecl">CPL_ERROR_NULL_INPUT </td><td class="ecr">Any argument is a <code>NULL</code> pointer.   </td></tr>
<tr>
<td class="ecl">CPL_ERROR_ILLEGAL_OUTPUT </td><td class="ecr">A column with the same <em>name</em> already exists in <em>table</em>.   </td></tr>
</table>
</dd>
</dl>
<p>This function creates a new column of type <code>CPL_TYPE_STRING</code> that will encapsulate the given data. See the description of <code><a class="el" href="group__cpl__table.html#gacb3eaa902753fcfe2141e8fa58698cc6" title="Create in table a new integer column obtained from existing data.">cpl_table_wrap_int()</a></code> for further details, especially with regard to memory managment. In the specific case of <em>string</em> columns the described restrictions applies also to the single column elements (strings). To deallocate specific column elements the functions <code><a class="el" href="group__cpl__table.html#gab1c5943ee40c3c71fb2e3634124e970b" title="Flag a column element as invalid.">cpl_table_set_invalid()</a></code> and <code><a class="el" href="group__cpl__table.html#ga9b6b87265e160eb355a3e2bb6d423e2d" title="Invalidate a column segment.">cpl_table_set_column_invalid()</a></code> should be used. </p>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__cpl__type_html_gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7"><div class="ttname"><a href="group__cpl__type.html#gga3f03371e201544e9115b40065e47f086a8b734828e10ea57ac0d7fefea32838b7">CPL_TYPE_POINTER</a></div><div class="ttdeci">@ CPL_TYPE_POINTER</div><div class="ttdef"><b>Definition:</b> cpl_type.h:139</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
