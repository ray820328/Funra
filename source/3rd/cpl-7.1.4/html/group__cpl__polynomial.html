<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Common Pipeline Library Reference Manual: Polynomials</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cpl.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Common Pipeline Library Reference Manual
   &#160;<span id="projectnumber">7.1.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Polynomials</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7d2f8e83cf135808812d4408a0b80225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga7d2f8e83cf135808812d4408a0b80225">cpl_polynomial_add</a> (cpl_polynomial *self, const cpl_polynomial *first, const cpl_polynomial *second)</td></tr>
<tr class="memdesc:ga7d2f8e83cf135808812d4408a0b80225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two polynomials of the same dimension.  <a href="group__cpl__polynomial.html#ga7d2f8e83cf135808812d4408a0b80225">More...</a><br /></td></tr>
<tr class="separator:ga7d2f8e83cf135808812d4408a0b80225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78b3928dafc354d9a1c7ccee583ae433"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga78b3928dafc354d9a1c7ccee583ae433">cpl_polynomial_compare</a> (const cpl_polynomial *self, const cpl_polynomial *other, double tol)</td></tr>
<tr class="memdesc:ga78b3928dafc354d9a1c7ccee583ae433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the coefficients of two polynomials.  <a href="group__cpl__polynomial.html#ga78b3928dafc354d9a1c7ccee583ae433">More...</a><br /></td></tr>
<tr class="separator:ga78b3928dafc354d9a1c7ccee583ae433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcf2af4bb98cf8d7a92165e22f1506f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gabcf2af4bb98cf8d7a92165e22f1506f1">cpl_polynomial_copy</a> (cpl_polynomial *self, const cpl_polynomial *other)</td></tr>
<tr class="memdesc:gabcf2af4bb98cf8d7a92165e22f1506f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of one polynomial into another one.  <a href="group__cpl__polynomial.html#gabcf2af4bb98cf8d7a92165e22f1506f1">More...</a><br /></td></tr>
<tr class="separator:gabcf2af4bb98cf8d7a92165e22f1506f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5935b00f6cae387d265df6d2ac80398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gab5935b00f6cae387d265df6d2ac80398">cpl_polynomial_delete</a> (cpl_polynomial *self)</td></tr>
<tr class="memdesc:gab5935b00f6cae387d265df6d2ac80398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a cpl_polynomial.  <a href="group__cpl__polynomial.html#gab5935b00f6cae387d265df6d2ac80398">More...</a><br /></td></tr>
<tr class="separator:gab5935b00f6cae387d265df6d2ac80398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2efdebaaf27c73481a42622d45f02b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga2efdebaaf27c73481a42622d45f02b4a">cpl_polynomial_derivative</a> (cpl_polynomial *self, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> dim)</td></tr>
<tr class="memdesc:ga2efdebaaf27c73481a42622d45f02b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a first order partial derivative.  <a href="group__cpl__polynomial.html#ga2efdebaaf27c73481a42622d45f02b4a">More...</a><br /></td></tr>
<tr class="separator:ga2efdebaaf27c73481a42622d45f02b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace55f4a423d9f2ad266575c5f9d64aff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gace55f4a423d9f2ad266575c5f9d64aff">cpl_polynomial_dump</a> (const cpl_polynomial *self, FILE *stream)</td></tr>
<tr class="memdesc:gace55f4a423d9f2ad266575c5f9d64aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a polynomial as ASCII to a stream, fail on zero-polynomial(s)  <a href="group__cpl__polynomial.html#gace55f4a423d9f2ad266575c5f9d64aff">More...</a><br /></td></tr>
<tr class="separator:gace55f4a423d9f2ad266575c5f9d64aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacce4193c15e0f57238399da04f7c8e9b"><td class="memItemLeft" align="right" valign="top">cpl_polynomial *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gacce4193c15e0f57238399da04f7c8e9b">cpl_polynomial_duplicate</a> (const cpl_polynomial *self)</td></tr>
<tr class="memdesc:gacce4193c15e0f57238399da04f7c8e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a polynomial.  <a href="group__cpl__polynomial.html#gacce4193c15e0f57238399da04f7c8e9b">More...</a><br /></td></tr>
<tr class="separator:gacce4193c15e0f57238399da04f7c8e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c6c39100fdbafaefe9474a06f53f8ff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga0c6c39100fdbafaefe9474a06f53f8ff">cpl_polynomial_eval</a> (const cpl_polynomial *self, const cpl_vector *x)</td></tr>
<tr class="memdesc:ga0c6c39100fdbafaefe9474a06f53f8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the polynomial at the given point using Horners rule.  <a href="group__cpl__polynomial.html#ga0c6c39100fdbafaefe9474a06f53f8ff">More...</a><br /></td></tr>
<tr class="separator:ga0c6c39100fdbafaefe9474a06f53f8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab002089746a121023e072d2f5d8b057d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gab002089746a121023e072d2f5d8b057d">cpl_polynomial_eval_1d</a> (const cpl_polynomial *self, double x, double *pd)</td></tr>
<tr class="memdesc:gab002089746a121023e072d2f5d8b057d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a univariate (1D) polynomial using Horners rule.  <a href="group__cpl__polynomial.html#gab002089746a121023e072d2f5d8b057d">More...</a><br /></td></tr>
<tr class="separator:gab002089746a121023e072d2f5d8b057d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a1224f9ecbc2a9984e27ba2a156c9b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gad5a1224f9ecbc2a9984e27ba2a156c9b">cpl_polynomial_eval_1d_diff</a> (const cpl_polynomial *self, double a, double b, double *ppa)</td></tr>
<tr class="memdesc:gad5a1224f9ecbc2a9984e27ba2a156c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate p(a) - p(b) using Horners rule.  <a href="group__cpl__polynomial.html#gad5a1224f9ecbc2a9984e27ba2a156c9b">More...</a><br /></td></tr>
<tr class="separator:gad5a1224f9ecbc2a9984e27ba2a156c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15adba8bfa7344bf4c87c35c77c7ae5a"><td class="memItemLeft" align="right" valign="top">cpl_polynomial *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga15adba8bfa7344bf4c87c35c77c7ae5a">cpl_polynomial_extract</a> (const cpl_polynomial *self, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> dim, const cpl_polynomial *other)</td></tr>
<tr class="memdesc:ga15adba8bfa7344bf4c87c35c77c7ae5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse one dimension of a multi-variate polynomial by composition.  <a href="group__cpl__polynomial.html#ga15adba8bfa7344bf4c87c35c77c7ae5a">More...</a><br /></td></tr>
<tr class="separator:ga15adba8bfa7344bf4c87c35c77c7ae5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4cdbbf2a50f568d9768cf793b53b187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187">cpl_polynomial_fit</a> (cpl_polynomial *self, const cpl_matrix *samppos, const cpl_boolean *sampsym, const cpl_vector *fitvals, const cpl_vector *fitsigm, cpl_boolean dimdeg, const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *mindeg, const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *maxdeg)</td></tr>
<tr class="memdesc:gaa4cdbbf2a50f568d9768cf793b53b187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a polynomial to a set of samples in a least squares sense.  <a href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187">More...</a><br /></td></tr>
<tr class="separator:gaa4cdbbf2a50f568d9768cf793b53b187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c9bc963e746ad10248c2795723288e"><td class="memItemLeft" align="right" valign="top">cpl_polynomial *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga43c9bc963e746ad10248c2795723288e">cpl_polynomial_fit_1d_create</a> (const cpl_vector *x_pos, const cpl_vector *values, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> degree, double *pmse)</td></tr>
<tr class="memdesc:ga43c9bc963e746ad10248c2795723288e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a 1D-polynomial to a 1D-signal in a least squares sense.  <a href="group__cpl__polynomial.html#ga43c9bc963e746ad10248c2795723288e">More...</a><br /></td></tr>
<tr class="separator:ga43c9bc963e746ad10248c2795723288e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab95f220cd97acdc6fa7b8d885709a18"><td class="memItemLeft" align="right" valign="top">cpl_polynomial *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gaab95f220cd97acdc6fa7b8d885709a18">cpl_polynomial_fit_2d_create</a> (const cpl_bivector *xy_pos, const cpl_vector *values, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> degree, double *pmse)</td></tr>
<tr class="memdesc:gaab95f220cd97acdc6fa7b8d885709a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a 2D-polynomial to a 2D-surface in a least squares sense.  <a href="group__cpl__polynomial.html#gaab95f220cd97acdc6fa7b8d885709a18">More...</a><br /></td></tr>
<tr class="separator:gaab95f220cd97acdc6fa7b8d885709a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9734114647bfd84ec8bf596b21c7ae9c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga9734114647bfd84ec8bf596b21c7ae9c">cpl_polynomial_get_coeff</a> (const cpl_polynomial *self, const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *pows)</td></tr>
<tr class="memdesc:ga9734114647bfd84ec8bf596b21c7ae9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a coefficient of the polynomial.  <a href="group__cpl__polynomial.html#ga9734114647bfd84ec8bf596b21c7ae9c">More...</a><br /></td></tr>
<tr class="separator:ga9734114647bfd84ec8bf596b21c7ae9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90f5c211dfda04ebb9c3c58a93a3fbb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga90f5c211dfda04ebb9c3c58a93a3fbb1">cpl_polynomial_get_degree</a> (const cpl_polynomial *self)</td></tr>
<tr class="memdesc:ga90f5c211dfda04ebb9c3c58a93a3fbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The degree of the polynomial.  <a href="group__cpl__polynomial.html#ga90f5c211dfda04ebb9c3c58a93a3fbb1">More...</a><br /></td></tr>
<tr class="separator:ga90f5c211dfda04ebb9c3c58a93a3fbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e423274dca56ac7fdeaabacf2ec64e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gac2e423274dca56ac7fdeaabacf2ec64e">cpl_polynomial_get_dimension</a> (const cpl_polynomial *self)</td></tr>
<tr class="memdesc:gac2e423274dca56ac7fdeaabacf2ec64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension of the polynomial.  <a href="group__cpl__polynomial.html#gac2e423274dca56ac7fdeaabacf2ec64e">More...</a><br /></td></tr>
<tr class="separator:gac2e423274dca56ac7fdeaabacf2ec64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac80bb037e6be560ebbdc0b849680e962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gac80bb037e6be560ebbdc0b849680e962">cpl_polynomial_multiply</a> (cpl_polynomial *self, const cpl_polynomial *first, const cpl_polynomial *second)</td></tr>
<tr class="memdesc:gac80bb037e6be560ebbdc0b849680e962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two polynomials of the same dimension.  <a href="group__cpl__polynomial.html#gac80bb037e6be560ebbdc0b849680e962">More...</a><br /></td></tr>
<tr class="separator:gac80bb037e6be560ebbdc0b849680e962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4ca8b8cf27c0b9b1dde7cfdf4315d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gaa4ca8b8cf27c0b9b1dde7cfdf4315d91">cpl_polynomial_multiply_scalar</a> (cpl_polynomial *self, const cpl_polynomial *other, double factor)</td></tr>
<tr class="memdesc:gaa4ca8b8cf27c0b9b1dde7cfdf4315d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a polynomial with a scalar.  <a href="group__cpl__polynomial.html#gaa4ca8b8cf27c0b9b1dde7cfdf4315d91">More...</a><br /></td></tr>
<tr class="separator:gaa4ca8b8cf27c0b9b1dde7cfdf4315d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54a57b6d455f675637bb1f18479c27bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga54a57b6d455f675637bb1f18479c27bd">cpl_polynomial_set_coeff</a> (cpl_polynomial *self, const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *pows, double value)</td></tr>
<tr class="memdesc:ga54a57b6d455f675637bb1f18479c27bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a coefficient of the polynomial.  <a href="group__cpl__polynomial.html#ga54a57b6d455f675637bb1f18479c27bd">More...</a><br /></td></tr>
<tr class="separator:ga54a57b6d455f675637bb1f18479c27bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad445a939e63d62bc91455b5ef7924559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#gad445a939e63d62bc91455b5ef7924559">cpl_polynomial_shift_1d</a> (cpl_polynomial *p, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> i, double u)</td></tr>
<tr class="memdesc:gad445a939e63d62bc91455b5ef7924559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify p, p(x0, x1, ..., xi, ...) := (x0, x1, ..., xi+u, ...)  <a href="group__cpl__polynomial.html#gad445a939e63d62bc91455b5ef7924559">More...</a><br /></td></tr>
<tr class="separator:gad445a939e63d62bc91455b5ef7924559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a44da11383b2d44cd23cc0708611530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga9a44da11383b2d44cd23cc0708611530">cpl_polynomial_solve_1d</a> (const cpl_polynomial *p, double x0, double *px, <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> mul)</td></tr>
<tr class="memdesc:ga9a44da11383b2d44cd23cc0708611530"><td class="mdescLeft">&#160;</td><td class="mdescRight">A real solution to p(x) = 0 using Newton-Raphsons method.  <a href="group__cpl__polynomial.html#ga9a44da11383b2d44cd23cc0708611530">More...</a><br /></td></tr>
<tr class="separator:ga9a44da11383b2d44cd23cc0708611530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga457ef230f6dcc5ce6517386ea832aaa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga457ef230f6dcc5ce6517386ea832aaa5">cpl_polynomial_subtract</a> (cpl_polynomial *self, const cpl_polynomial *first, const cpl_polynomial *second)</td></tr>
<tr class="memdesc:ga457ef230f6dcc5ce6517386ea832aaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two polynomials of the same dimension.  <a href="group__cpl__polynomial.html#ga457ef230f6dcc5ce6517386ea832aaa5">More...</a><br /></td></tr>
<tr class="separator:ga457ef230f6dcc5ce6517386ea832aaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09473199544ac51406f4952dad5b8665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga09473199544ac51406f4952dad5b8665">cpl_vector_fill_polynomial</a> (cpl_vector *v, const cpl_polynomial *p, double x0, double d)</td></tr>
<tr class="memdesc:ga09473199544ac51406f4952dad5b8665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a 1D-polynomial on equidistant points using Horners rule.  <a href="group__cpl__polynomial.html#ga09473199544ac51406f4952dad5b8665">More...</a><br /></td></tr>
<tr class="separator:ga09473199544ac51406f4952dad5b8665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d23d4b42c4d98bb6e50e53e67350aa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cpl__polynomial.html#ga7d23d4b42c4d98bb6e50e53e67350aa0">cpl_vector_fill_polynomial_fit_residual</a> (cpl_vector *self, const cpl_vector *fitvals, const cpl_vector *fitsigm, const cpl_polynomial *fit, const cpl_matrix *samppos, double *rechisq)</td></tr>
<tr class="memdesc:ga7d23d4b42c4d98bb6e50e53e67350aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the residual of a polynomial fit.  <a href="group__cpl__polynomial.html#ga7d23d4b42c4d98bb6e50e53e67350aa0">More...</a><br /></td></tr>
<tr class="separator:ga7d23d4b42c4d98bb6e50e53e67350aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module provides functions to handle uni- and multivariate polynomials.</p>
<p>Comparing the two polynomials </p><pre class="fragment">* P1(x) = p0 + p1.x + p4.x^2
* </pre><p> and </p><pre class="fragment">* P2(x,y) = p0 + p1.x + p2.y + p3.x.y + p4.x^2 + p5.y^2
* </pre><p> P1(x) may evaluate to more accurate results than P2(x,0), especially around the roots.</p>
<p>Note that a polynomial like P3(z) = p0 + p1.z + p2.z^2 + p3.z^3, z=x^4 is preferable to p4(x) = p0 + p1.x^4 + p2.x^8 + p3.x^12.</p>
<p>Polynomials are evaluated using Horner's method. For multivariate polynomials the evaluation is performed one dimension at a time, starting with the lowest dimension and proceeding upwards through the higher dimensions.</p>
<p>Access to a coefficient of an N-dimensional polynomial has complexity O(N). </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7d2f8e83cf135808812d4408a0b80225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d2f8e83cf135808812d4408a0b80225">&#9670;&nbsp;</a></span>cpl_polynomial_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_add </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two polynomials of the same dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to hold the result </td></tr>
    <tr><td class="paramname">first</td><td>The 1st polynomial to add </td></tr>
    <tr><td class="paramname">second</td><td>The 2nd polynomial to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant CPL error code </dd></dl>
<dl class="section note"><dt>Note</dt><dd>self may be passed also as first and/or second</dd></dl>
<p>Possible CPL error code set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if the polynomials do not have identical dimensions </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#ga79968a56c1b2ee25b12747ad7e1b3478">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__polynomial.html#gac2e423274dca56ac7fdeaabacf2ec64e">cpl_polynomial_get_dimension()</a>.</p>

</div>
</div>
<a id="ga78b3928dafc354d9a1c7ccee583ae433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78b3928dafc354d9a1c7ccee583ae433">&#9670;&nbsp;</a></span>cpl_polynomial_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cpl_polynomial_compare </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the coefficients of two polynomials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The 1st polynomial </td></tr>
    <tr><td class="paramname">other</td><td>The 2nd polynomial </td></tr>
    <tr><td class="paramname">tol</td><td>The absolute (non-negative) tolerance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when equal, positive when different, negative on error.</dd></dl>
<p>The two polynomials are considered equal iff they have identical dimensions and the absolute difference between their coefficients does not exceed the given tolerance.</p>
<p>This means that the following two polynomials per definition are considered different: P1(x1) = 3*x1 different from P2(x1,x2) = 3*x1.</p>
<p>If all input parameters are valid and self and other point to the same polynomial the function returns 0.</p>
<p>If two polynomials have different dimensions, the return value is this (positive) difference.</p>
<p>If two 1D-polynomials differ, the return value is 1 plus the degree of the lowest order differing coefficient.</p>
<p>If for a higher dimension they differ, it is 1 plus the degree of a differing coefficient.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_ILLEGAL_INPUT if tol is negative </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#gac0ec1b4810f247e844f4ca01cf8f0348">cpl_ensure</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gabcf2af4bb98cf8d7a92165e22f1506f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcf2af4bb98cf8d7a92165e22f1506f1">&#9670;&nbsp;</a></span>cpl_polynomial_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_copy </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of one polynomial into another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Pre-allocated output polynomial </td></tr>
    <tr><td class="paramname">other</td><td>Input polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE on success or else the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a></dd></dl>
<p>self and other must point to different polynomials.</p>
<p>If self already contains coefficients, then they are overwritten.</p>
<p>This is the only function that can modify the dimension of a polynomial.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if in and out point to the same polynomial </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#ga79968a56c1b2ee25b12747ad7e1b3478">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="gab5935b00f6cae387d265df6d2ac80398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5935b00f6cae387d265df6d2ac80398">&#9670;&nbsp;</a></span>cpl_polynomial_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cpl_polynomial_delete </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a cpl_polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Polynomial to deallocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section see"><dt>See also</dt><dd>cpl_polynomial_new() </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <em>self</em> is <code>NULL</code>, nothing is done and no error is set.</dd></dl>
<p>The function deallocates the memory used by the polynomial <em>self</em>. </p>

<p class="reference">Referenced by <a class="el" href="group__cpl__image.html#ga9da9342bdd22b4db42abd6cdf32dd5c3">cpl_image_fill_jacobian_polynomial()</a>, <a class="el" href="group__cpl__polynomial.html#ga43c9bc963e746ad10248c2795723288e">cpl_polynomial_fit_1d_create()</a>, and <a class="el" href="group__cpl__polynomial.html#gaab95f220cd97acdc6fa7b8d885709a18">cpl_polynomial_fit_2d_create()</a>.</p>

</div>
</div>
<a id="ga2efdebaaf27c73481a42622d45f02b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2efdebaaf27c73481a42622d45f02b4a">&#9670;&nbsp;</a></span>cpl_polynomial_derivative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_derivative </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a first order partial derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to be modified in place </td></tr>
    <tr><td class="paramname">dim</td><td>The dimension to differentiate (zero for first dimension) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a></dd></dl>
<p>The dimension of the polynomial is preserved, even if the operation may cause the polynomial to become independent of the dimension dim of the variable.</p>
<p>The call requires n FLOPs, where n is the number of (non-zero) polynomial coefficients whose power in dimension dim is at least 1.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_ILLEGAL_INPUT if dim is negative.</li>
<li>CPL_ERROR_ACCESS_OUT_OF_RANGE if dim exceeds the dimension of self. </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#ga79968a56c1b2ee25b12747ad7e1b3478">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0d916ea6a7e198a74863ecd9ea03d733">CPL_ERROR_ACCESS_OUT_OF_RANGE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__image.html#ga9da9342bdd22b4db42abd6cdf32dd5c3">cpl_image_fill_jacobian_polynomial()</a>.</p>

</div>
</div>
<a id="gace55f4a423d9f2ad266575c5f9d64aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace55f4a423d9f2ad266575c5f9d64aff">&#9670;&nbsp;</a></span>cpl_polynomial_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_dump </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a polynomial as ASCII to a stream, fail on zero-polynomial(s) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to process </td></tr>
    <tr><td class="paramname">stream</td><td>Output stream eq. <code>stdout</code> or <code>stderr</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since this function is mostly for testing during development, it checks for illegal sub-zero-polynomials and sets a CPL error if one is found</dd></dl>
<p>Each coefficient is preceded by its integer power(s) and written on a single line. If the polynomial has non-zero coefficients, only those are printed, otherwise the (zero-valued) constant term is printed.</p>
<p>For an N-dimensional polynomial each line thus consists of N power(s) and their coefficient.</p>
<p>Comment lines start with the hash character.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_FILE_IO if the write operation fails </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#ga79968a56c1b2ee25b12747ad7e1b3478">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900aa54303ad2fb0efc3f8c57c788b342c81">CPL_ERROR_FILE_IO</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__type.html#ga4f6c44a14bbc3aea87b1f47acf8dfd02">CPL_SIZE_FORMAT</a>.</p>

</div>
</div>
<a id="gacce4193c15e0f57238399da04f7c8e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacce4193c15e0f57238399da04f7c8e9b">&#9670;&nbsp;</a></span>cpl_polynomial_duplicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_polynomial* cpl_polynomial_duplicate </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The non-NULL polynomial to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated cpl_polynomial or NULL on error </dd></dl>
<dl class="section see"><dt>See also</dt><dd>cpl_polynomial_new()</dd></dl>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#gac0ec1b4810f247e844f4ca01cf8f0348">cpl_ensure</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__image.html#ga9da9342bdd22b4db42abd6cdf32dd5c3">cpl_image_fill_jacobian_polynomial()</a>.</p>

</div>
</div>
<a id="ga0c6c39100fdbafaefe9474a06f53f8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c6c39100fdbafaefe9474a06f53f8ff">&#9670;&nbsp;</a></span>cpl_polynomial_eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_polynomial_eval </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the polynomial at the given point using Horners rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to access </td></tr>
    <tr><td class="paramname">x</td><td>Point of evaluation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The length of x must match the polynomial dimension. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The computed value or undefined on error.</dd></dl>
<p>A polynomial with no non-zero coefficients evaluates as 0.</p>
<p>With n coefficients the complexity is about 2n FLOPs.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if the length of x differs from the dimension of the polynomial </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#gac0ec1b4810f247e844f4ca01cf8f0348">cpl_ensure</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__image.html#ga9da9342bdd22b4db42abd6cdf32dd5c3">cpl_image_fill_jacobian_polynomial()</a>, and <a class="el" href="group__cpl__polynomial.html#gaab95f220cd97acdc6fa7b8d885709a18">cpl_polynomial_fit_2d_create()</a>.</p>

</div>
</div>
<a id="gab002089746a121023e072d2f5d8b057d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab002089746a121023e072d2f5d8b057d">&#9670;&nbsp;</a></span>cpl_polynomial_eval_1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_polynomial_eval_1d </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a univariate (1D) polynomial using Horners rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The 1D-polynomial </td></tr>
    <tr><td class="paramname">x</td><td>The point of evaluation </td></tr>
    <tr><td class="paramname">pd</td><td>Iff pd is non-NULL, the derivative evaluated at x </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result or undefined on error. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__polynomial.html#ga0c6c39100fdbafaefe9474a06f53f8ff" title="Evaluate the polynomial at the given point using Horners rule.">cpl_polynomial_eval()</a></dd></dl>
<p>A polynomial with no non-zero coefficents evaluates to 0 with a derivative that does likewise.</p>
<p>The result is computed as p_0 + x * ( p_1 + x * ( p_2 + ... x * p_n )) and requires 2n FLOPs where n+1 is the number of coefficients.</p>
<p>If the derivative is requested it is computed using a nested Horner rule. This requires about 4n FLOPs.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INVALID_TYPE if the polynomial is not (1D) univariate </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#gac0ec1b4810f247e844f4ca01cf8f0348">cpl_ensure</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7907a24014a3a45aebe5ee1842f0c6f3">CPL_ERROR_INVALID_TYPE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__wlcalib.html#gad86e86dc2041eae1283afcce1e6b7353">cpl_wlcalib_find_best_1d()</a>.</p>

</div>
</div>
<a id="gad5a1224f9ecbc2a9984e27ba2a156c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5a1224f9ecbc2a9984e27ba2a156c9b">&#9670;&nbsp;</a></span>cpl_polynomial_eval_1d_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_polynomial_eval_1d_diff </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ppa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate p(a) - p(b) using Horners rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The 1D-polynomial </td></tr>
    <tr><td class="paramname">a</td><td>The evaluation point of the minuend </td></tr>
    <tr><td class="paramname">b</td><td>The evaluation point of the subtrahend </td></tr>
    <tr><td class="paramname">ppa</td><td>Iff ppa is not NULL, p(a) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference or undefined on error</dd></dl>
<p>The call requires about 4n FLOPs where n is the number of coefficients in self, which is the same as that required for two separate polynomial evaluations. <a class="el" href="group__cpl__polynomial.html#gad5a1224f9ecbc2a9984e27ba2a156c9b" title="Evaluate p(a) - p(b) using Horners rule.">cpl_polynomial_eval_1d_diff()</a> is however more accurate.</p>
<p>ppa may be NULL. If it is not, *ppa is set to self(a), which is calculated at no extra cost.</p>
<p>The underlying algorithm is the same as that used in <a class="el" href="group__cpl__polynomial.html#gab002089746a121023e072d2f5d8b057d" title="Evaluate a univariate (1D) polynomial using Horners rule.">cpl_polynomial_eval_1d()</a> when the derivative is also requested.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INVALID_TYPE if the polynomial has the wrong dimension </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#gac0ec1b4810f247e844f4ca01cf8f0348">cpl_ensure</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7907a24014a3a45aebe5ee1842f0c6f3">CPL_ERROR_INVALID_TYPE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga15adba8bfa7344bf4c87c35c77c7ae5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15adba8bfa7344bf4c87c35c77c7ae5a">&#9670;&nbsp;</a></span>cpl_polynomial_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_polynomial* cpl_polynomial_extract </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collapse one dimension of a multi-variate polynomial by composition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The multi-variate polynomial </td></tr>
    <tr><td class="paramname">dim</td><td>The dimension to collapse (zero for first dimension) </td></tr>
    <tr><td class="paramname">other</td><td>The polynomial to replace dimension dim of self </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The collapsed polynomial or NULL on error </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__polynomial.html#ga0c6c39100fdbafaefe9474a06f53f8ff" title="Evaluate the polynomial at the given point using Horners rule.">cpl_polynomial_eval()</a></dd></dl>
<p>The dimension of the polynomial self must be one greater than that of the other polynomial. Given these two polynomials the dimension dim of self is collapsed by creating a new polynomial from self(x0, x1, ..., x{dim-1}, other(x0, x1, ..., x{dim-1}, x{dim+1}, x{dim+2}, ..., x{n-1}), x{dim+1}, x{dim+2}, ..., x{n-1}).</p>
<p>The created polynomial thus has a dimension which is one less than the polynomial self and which is equal to that of the other polynomial. Collapsing one dimension of a 1D-polynomial is equivalent to evaluating it, which can be done with <a class="el" href="group__cpl__polynomial.html#gab002089746a121023e072d2f5d8b057d" title="Evaluate a univariate (1D) polynomial using Horners rule.">cpl_polynomial_eval_1d()</a>.</p>
<p>FIXME: The other polynomial must currently have a degree of zero, i.e. it must be a constant.</p>
<p>The collapse uses Horner's rule and requires for n coefficients requires about 2n FLOPs.</p>
<p>The returned object is a newly allocated cpl_polynomial that must be deallocated by the caller using <a class="el" href="group__cpl__polynomial.html#gab5935b00f6cae387d265df6d2ac80398" title="Delete a cpl_polynomial.">cpl_polynomial_delete()</a>.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INVALID_TYPE if the polynomial is uni-variate.</li>
<li>CPL_ERROR_ILLEGAL_INPUT if dim is negative.</li>
<li>CPL_ERROR_ACCESS_OUT_OF_RANGE if dim exceeds the dimension of self.</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if other has the wrong dimension.</li>
<li>CPL_ERROR_UNSUPPORTED_MODE if other is not of degree 0. </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__memory.html#gab672473d6f7d0d933e06c2e8c456bd3b">cpl_calloc()</a>, <a class="el" href="group__cpl__error.html#gac0ec1b4810f247e844f4ca01cf8f0348">cpl_ensure</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0d916ea6a7e198a74863ecd9ea03d733">CPL_ERROR_ACCESS_OUT_OF_RANGE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7907a24014a3a45aebe5ee1842f0c6f3">CPL_ERROR_INVALID_TYPE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a74ef8e37f3412e85cfc22840d13bdd0c">CPL_ERROR_UNSUPPORTED_MODE</a>, <a class="el" href="group__cpl__memory.html#ga9cd2b64cbbe05ec9f34fda048184b4d1">cpl_free()</a>, <a class="el" href="group__cpl__polynomial.html#ga9734114647bfd84ec8bf596b21c7ae9c">cpl_polynomial_get_coeff()</a>, and <a class="el" href="group__cpl__polynomial.html#ga90f5c211dfda04ebb9c3c58a93a3fbb1">cpl_polynomial_get_degree()</a>.</p>

</div>
</div>
<a id="gaa4cdbbf2a50f568d9768cf793b53b187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4cdbbf2a50f568d9768cf793b53b187">&#9670;&nbsp;</a></span>cpl_polynomial_fit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_fit </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_matrix *&#160;</td>
          <td class="paramname"><em>samppos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_boolean *&#160;</td>
          <td class="paramname"><em>sampsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>fitvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>fitsigm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpl_boolean&#160;</td>
          <td class="paramname"><em>dimdeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>mindeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>maxdeg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit a polynomial to a set of samples in a least squares sense. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Polynomial of dimension d to hold the coefficients </td></tr>
    <tr><td class="paramname">samppos</td><td>Matrix of p sample positions, with d rows and p columns </td></tr>
    <tr><td class="paramname">sampsym</td><td>NULL, or d booleans, true iff the sampling is symmetric </td></tr>
    <tr><td class="paramname">fitvals</td><td>Vector of the p values to fit </td></tr>
    <tr><td class="paramname">fitsigm</td><td>Uncertainties of the sampled values, or NULL for all ones </td></tr>
    <tr><td class="paramname">dimdeg</td><td>True iff there is a fitting degree per dimension </td></tr>
    <tr><td class="paramname">mindeg</td><td>Pointer to 1 or d minimum fitting degree(s), or NULL </td></tr>
    <tr><td class="paramname">maxdeg</td><td>Pointer to 1 or d maximum fitting degree(s), at least mindeg </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE on success, else the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently only uni- and bi-variate polynomials are supported, fitsigm must be NULL. For all but uni-variate polynomials mindeg must be zero. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__polynomial.html#ga7d23d4b42c4d98bb6e50e53e67350aa0" title="Compute the residual of a polynomial fit.">cpl_vector_fill_polynomial_fit_residual()</a></dd></dl>
<p>Any pre-set non-zero coefficients in self are overwritten or reset by the fit.</p>
<p>For 1D-polynomials N = 1 + maxdeg - mindeg coefficients are fitted. A non-zero mindeg ensures that the fitted polynomial has a fix-point at zero.</p>
<p>For multi-variate polynomials the fit depends on dimdeg:</p>
<p>If dimdeg is false, an n-degree coefficient is fitted iff mindeg &lt;= n &lt;= maxdeg. For a 2D-polynomial this means that N * (N + 1) / 2 coefficients are fitted.</p>
<p>If dimdeg is true, nci = 1 + maxdeg[i] + mindeg[i] coefficients are fitted for dimension i, i.e. for a 2D-polynomial N = nc1 * nc2 coefficients are fitted.</p>
<p>The number of distinct samples should exceed the number of coefficients to fit. The number of distinct samples may also equal the number of coefficients to fit, but in this case the fit has another meaning (any non-zero residual is due to rounding errors, not a fitting error). It is an error to try to fit more coefficients than there are distinct samples.</p>
<p>If the relative uncertainties of the sampled values are known, they may be passed via fitsigm. NULL means that all uncertainties equals one.</p>
<p>sampsym is ignored if mindeg is nonzero, otherwise the caller may use sampsym to indicate an a priori knowledge that the sampling positions are symmetric. NULL indicates no knowledge of such symmetry. sampsym[i] may be set to true iff the sampling is symmetric around u_i, where u_i is the mean of the sampling positions in dimension i.</p>
<p>In 1D this implies that the sampling points as pairs average u_0 (with an odd number of samples one sample must equal u_0). E.g. both x = (1, 2, 4, 6, 7) and x = (1, 6, 4, 2, 7) have sampling symmetry, while x = (1, 2, 4, 6) does not.</p>
<p>In 2D this implies that the sampling points are symmetric in the 2D-plane. For the first dimension sampling symmetry means that the sampling is line- symmetric around y = u_1, while for the second dimension, sampling symmetry implies line-symmetry around x = u_2. Point symmetry around (x,y) = (u_1, u_2) means that both sampsym[0] and sampsym[1] may be set to true.</p>
<p>Knowledge of symmetric sampling allows the fit to be both faster and eliminates certain round-off errors.</p>
<p>For higher order fitting the fitting problem known as "Runge's phenomenon" is minimized using the socalled "Chebyshev nodes" as sampling points. For Chebyshev nodes sampsym can be set to CPL_TRUE.</p>
<p>Warning: An increase in the polynomial degree will normally reduce the fitting error. However, due to rounding errors and the limited accuracy of the solver of the normal equations, an increase in the polynomial degree may at some point cause the fitting error to <em>increase</em>. In some cases this happens with an increase of the polynomial degree from 8 to 9.</p>
<p>The fit is done in the following steps: 1) If mindeg is zero, the sampling positions are first transformed into Xhat_i = X_i - mean(X_i), i=1, .., dimension. 2) The Vandermonde matrix is formed from Xhat. 3) The normal equations of the Vandermonde matrix is solved. 4) If mindeg is zero, the resulting polynomial in Xhat is transformed back to X.</p>
<p>For a univariate (1D) fit the call requires 6MN + N^3/3 + 7/2N^2 + O(M) FLOPs where M is the number of data points and where N is the number of polynomial coefficients to fit, N = 1 + maxdeg - mindeg.</p>
<p>For a bivariate fit the call requires MN^2 + N^3/3 + O(MN) FLOPs where M is the number of data points and where N is the number of polynomial coefficients to fit.</p>
<p>Examples of usage: </p><div class="fragment"><div class="line">cpl_polynomial  * fit1d     = cpl_polynomial_new(1);</div>
<div class="line">cpl_matrix      * samppos1d = my_sampling_points_1d(); <span class="comment">// 1-row matrix</span></div>
<div class="line">cpl_vector      * fitvals   = my_sampling_values();</div>
<div class="line"><span class="keyword">const</span> cpl_boolean sampsym   = CPL_TRUE;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>    maxdeg1d  = 4; <span class="comment">// Fit 5 coefficients</span></div>
<div class="line"><a class="code" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>    error1d</div>
<div class="line">    = <a class="code" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187">cpl_polynomial_fit</a>(fit1d, samppos1d, &amp;sampsym, fitvals, NULL,</div>
<div class="line">                         CPL_FALSE, NULL, &amp;maxdeg1d);</div>
</div><!-- fragment --><div class="fragment"><div class="line">cpl_polynomial  * fit2d      = cpl_polynomial_new(2);</div>
<div class="line">cpl_matrix      * samppos2d  = my_sampling_points_2d(); <span class="comment">// 2-row matrix</span></div>
<div class="line">cpl_vector      * fitvals    = my_sampling_values();</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>    maxdeg2d[] = {2, 1}; <span class="comment">// Fit 6 coefficients</span></div>
<div class="line"><a class="code" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a>    error2d</div>
<div class="line">    = <a class="code" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187">cpl_polynomial_fit</a>(fit2d, samppos2d, NULL, fitvals, NULL, CPL_FALSE,</div>
<div class="line">                         NULL, maxdeg2d);</div>
</div><!-- fragment --><p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_ILLEGAL_INPUT if a mindeg value is negative, or if a maxdeg value is less than the corresponding mindeg value.</li>
<li>CPL_ERROR_DATA_NOT_FOUND if the number of columns in samppos is less than the number of coefficients to be determined.</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if samppos, fitvals or fitsigm have incompatible sizes, or if samppos, self or sampsym have incompatible sizes.</li>
<li>CPL_ERROR_SINGULAR_MATRIX if samppos contains too few distinct values</li>
<li>CPL_ERROR_DIVISION_BY_ZERO if an element in fitsigm is zero</li>
<li>CPL_ERROR_UNSUPPORTED_MODE if the polynomial dimension exceeds two </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#ga79968a56c1b2ee25b12747ad7e1b3478">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__matrix.html#ga4bade56f31c3e0f69ca513a557c1d4fd">cpl_matrix_get_ncol()</a>, <a class="el" href="group__cpl__matrix.html#gaba2be6537f0aacb0dfea437f186627c9">cpl_matrix_get_nrow()</a>, <a class="el" href="group__cpl__polynomial.html#gac2e423274dca56ac7fdeaabacf2ec64e">cpl_polynomial_get_dimension()</a>, <a class="el" href="group__cpl__type.html#ga4f6c44a14bbc3aea87b1f47acf8dfd02">CPL_SIZE_FORMAT</a>, and <a class="el" href="group__cpl__vector.html#gac72d7e38ce2f5ac2e0863e2a11e9af1d">cpl_vector_get_size()</a>.</p>

</div>
</div>
<a id="ga43c9bc963e746ad10248c2795723288e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43c9bc963e746ad10248c2795723288e">&#9670;&nbsp;</a></span>cpl_polynomial_fit_1d_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_polynomial* cpl_polynomial_fit_1d_create </td>
          <td>(</td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>x_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pmse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit a 1D-polynomial to a 1D-signal in a least squares sense. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_pos</td><td>Vector of positions of the signal to fit. </td></tr>
    <tr><td class="paramname">values</td><td>Vector of values of the signal to fit. </td></tr>
    <tr><td class="paramname">degree</td><td>Non-negative polynomial degree. </td></tr>
    <tr><td class="paramname">pmse</td><td>Iff pmse is not null, the mean squared error on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fitted polynomial or NULL on error </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187" title="Fit a polynomial to a set of samples in a least squares sense.">cpl_polynomial_fit()</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Replace this call with <a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187" title="Fit a polynomial to a set of samples in a least squares sense.">cpl_polynomial_fit()</a> and optionally <a class="el" href="group__cpl__polynomial.html#ga7d23d4b42c4d98bb6e50e53e67350aa0" title="Compute the residual of a polynomial fit.">cpl_vector_fill_polynomial_fit_residual()</a>.</dd></dl>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, and <a class="el" href="group__cpl__polynomial.html#gab5935b00f6cae387d265df6d2ac80398">cpl_polynomial_delete()</a>.</p>

</div>
</div>
<a id="gaab95f220cd97acdc6fa7b8d885709a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab95f220cd97acdc6fa7b8d885709a18">&#9670;&nbsp;</a></span>cpl_polynomial_fit_2d_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_polynomial* cpl_polynomial_fit_2d_create </td>
          <td>(</td>
          <td class="paramtype">const cpl_bivector *&#160;</td>
          <td class="paramname"><em>xy_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pmse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit a 2D-polynomial to a 2D-surface in a least squares sense. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xy_pos</td><td>Bivector positions of the surface to fit. </td></tr>
    <tr><td class="paramname">values</td><td>Vector of values of the surface to fit. </td></tr>
    <tr><td class="paramname">degree</td><td>Non-negative polynomial degree. </td></tr>
    <tr><td class="paramname">pmse</td><td>Iff pmse is not null, the mean squared error on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fitted polynomial or NULL on error </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187" title="Fit a polynomial to a set of samples in a least squares sense.">cpl_polynomial_fit()</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Replace this call with <a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187" title="Fit a polynomial to a set of samples in a least squares sense.">cpl_polynomial_fit()</a> and optionally <a class="el" href="group__cpl__polynomial.html#ga7d23d4b42c4d98bb6e50e53e67350aa0" title="Compute the residual of a polynomial fit.">cpl_vector_fill_polynomial_fit_residual()</a>.</dd></dl>

<p class="reference">References <a class="el" href="group__cpl__bivector.html#gaa7b11c49923e2538d454306ed39a34a9">cpl_bivector_get_x_const()</a>, <a class="el" href="group__cpl__bivector.html#ga314efce3125658f6e39b02a21d78a374">cpl_bivector_get_y_const()</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>, <a class="el" href="group__cpl__polynomial.html#gab5935b00f6cae387d265df6d2ac80398">cpl_polynomial_delete()</a>, <a class="el" href="group__cpl__polynomial.html#ga0c6c39100fdbafaefe9474a06f53f8ff">cpl_polynomial_eval()</a>, <a class="el" href="group__cpl__vector.html#ga991ded30622122c78bb34191f7c7a7c6">cpl_vector_get_data_const()</a>, <a class="el" href="group__cpl__vector.html#gac72d7e38ce2f5ac2e0863e2a11e9af1d">cpl_vector_get_size()</a>, <a class="el" href="group__cpl__vector.html#ga3d022e443df6e51ae2c005285d978957">cpl_vector_unwrap()</a>, and <a class="el" href="group__cpl__vector.html#ga1f52028a78be1cab17567cf15c483fcc">cpl_vector_wrap()</a>.</p>

</div>
</div>
<a id="ga9734114647bfd84ec8bf596b21c7ae9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9734114647bfd84ec8bf596b21c7ae9c">&#9670;&nbsp;</a></span>cpl_polynomial_get_coeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cpl_polynomial_get_coeff </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>pows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a coefficient of the polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to process </td></tr>
    <tr><td class="paramname">pows</td><td>The non-negative power(s) of the variable(s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coefficient or undefined on error </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For an N-dimensional polynomial the complexity is O(N) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__polynomial.html#ga54a57b6d455f675637bb1f18479c27bd" title="Set a coefficient of the polynomial.">cpl_polynomial_set_coeff</a></dd></dl>
<p>Requesting the value of a coefficient that has not been set is allowed, in this case zero is returned.</p>
<p>Example of usage: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> power       = 3;</div>
<div class="line"><span class="keywordtype">double</span>         coefficient = <a class="code" href="group__cpl__polynomial.html#ga9734114647bfd84ec8bf596b21c7ae9c">cpl_polynomial_get_coeff</a>(poly1d, &amp;power);</div>
</div><!-- fragment --><p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_ILLEGAL_INPUT if pows contains negative values </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#gac0ec1b4810f247e844f4ca01cf8f0348">cpl_ensure</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__type.html#ga4f6c44a14bbc3aea87b1f47acf8dfd02">CPL_SIZE_FORMAT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__polynomial.html#ga15adba8bfa7344bf4c87c35c77c7ae5a">cpl_polynomial_extract()</a>.</p>

</div>
</div>
<a id="ga90f5c211dfda04ebb9c3c58a93a3fbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90f5c211dfda04ebb9c3c58a93a3fbb1">&#9670;&nbsp;</a></span>cpl_polynomial_get_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_polynomial_get_degree </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The degree of the polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The degree or negative on error</dd></dl>
<p>The degree is the highest sum of exponents (with a non-zero coefficient).</p>
<p>If there are no non-zero coefficients the degree is zero.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#gac0ec1b4810f247e844f4ca01cf8f0348">cpl_ensure</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__polynomial.html#ga15adba8bfa7344bf4c87c35c77c7ae5a">cpl_polynomial_extract()</a>, and <a class="el" href="group__cpl__wlcalib.html#gad86e86dc2041eae1283afcce1e6b7353">cpl_wlcalib_find_best_1d()</a>.</p>

</div>
</div>
<a id="gac2e423274dca56ac7fdeaabacf2ec64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e423274dca56ac7fdeaabacf2ec64e">&#9670;&nbsp;</a></span>cpl_polynomial_get_dimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> cpl_polynomial_get_dimension </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The dimension of the polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dimension or negative on error</dd></dl>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#gac0ec1b4810f247e844f4ca01cf8f0348">cpl_ensure</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__image.html#ga9da9342bdd22b4db42abd6cdf32dd5c3">cpl_image_fill_jacobian_polynomial()</a>, <a class="el" href="group__cpl__image.html#ga3e46978badb07da8a75caf267452bf5d">cpl_image_fill_polynomial()</a>, <a class="el" href="group__cpl__image.html#ga34b80ed421f88c5bdad3f0127d251975">cpl_image_warp_polynomial()</a>, <a class="el" href="group__cpl__polynomial.html#ga7d2f8e83cf135808812d4408a0b80225">cpl_polynomial_add()</a>, <a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187">cpl_polynomial_fit()</a>, <a class="el" href="group__cpl__polynomial.html#gac80bb037e6be560ebbdc0b849680e962">cpl_polynomial_multiply()</a>, <a class="el" href="group__cpl__polynomial.html#gaa4ca8b8cf27c0b9b1dde7cfdf4315d91">cpl_polynomial_multiply_scalar()</a>, <a class="el" href="group__cpl__polynomial.html#gad445a939e63d62bc91455b5ef7924559">cpl_polynomial_shift_1d()</a>, <a class="el" href="group__cpl__polynomial.html#ga457ef230f6dcc5ce6517386ea832aaa5">cpl_polynomial_subtract()</a>, <a class="el" href="group__cpl__polynomial.html#ga7d23d4b42c4d98bb6e50e53e67350aa0">cpl_vector_fill_polynomial_fit_residual()</a>, and <a class="el" href="group__cpl__wlcalib.html#gad86e86dc2041eae1283afcce1e6b7353">cpl_wlcalib_find_best_1d()</a>.</p>

</div>
</div>
<a id="gac80bb037e6be560ebbdc0b849680e962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac80bb037e6be560ebbdc0b849680e962">&#9670;&nbsp;</a></span>cpl_polynomial_multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_multiply </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two polynomials of the same dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to hold the result </td></tr>
    <tr><td class="paramname">first</td><td>The polynomial to multiply </td></tr>
    <tr><td class="paramname">second</td><td>The polynomial to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant CPL error code </dd></dl>
<dl class="section note"><dt>Note</dt><dd>self may be passed also as first and/or second </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__polynomial.html#ga7d2f8e83cf135808812d4408a0b80225" title="Add two polynomials of the same dimension.">cpl_polynomial_add()</a></dd></dl>
<p>Possible CPL error code set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if the polynomials do not have identical dimensions </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#ga79968a56c1b2ee25b12747ad7e1b3478">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__polynomial.html#gac2e423274dca56ac7fdeaabacf2ec64e">cpl_polynomial_get_dimension()</a>.</p>

</div>
</div>
<a id="gaa4ca8b8cf27c0b9b1dde7cfdf4315d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4ca8b8cf27c0b9b1dde7cfdf4315d91">&#9670;&nbsp;</a></span>cpl_polynomial_multiply_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_multiply_scalar </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a polynomial with a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to hold the result </td></tr>
    <tr><td class="paramname">other</td><td>The polynomial to scale of same dimension, may equal self </td></tr>
    <tr><td class="paramname">factor</td><td>The factor to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant CPL error code </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If factor is zero all coefficients are reset, if it is 1 all are copied</dd></dl>
<p>Possible CPL error code set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if the two dimensions do not match </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#ga79968a56c1b2ee25b12747ad7e1b3478">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__polynomial.html#gac2e423274dca56ac7fdeaabacf2ec64e">cpl_polynomial_get_dimension()</a>.</p>

</div>
</div>
<a id="ga54a57b6d455f675637bb1f18479c27bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54a57b6d455f675637bb1f18479c27bd">&#9670;&nbsp;</a></span>cpl_polynomial_set_coeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_set_coeff </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> *&#160;</td>
          <td class="paramname"><em>pows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a coefficient of the polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to modify </td></tr>
    <tr><td class="paramname">pows</td><td>The non-negative power(s) of the variable(s) </td></tr>
    <tr><td class="paramname">value</td><td>The coefficient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE on success or else the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For an N-dimensional polynomial the complexity is O(N) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__polynomial.html#ga9734114647bfd84ec8bf596b21c7ae9c" title="Get a coefficient of the polynomial.">cpl_polynomial_get_coeff</a></dd></dl>
<p>The array pows is assumed to have the size of the polynomial dimension.</p>
<p>If the coefficient is already there, it is overwritten, if not, a new coefficient is added to the polynomial. This may cause the degree of the polynomial to be increased, or if the new coefficient is zero, to decrease.</p>
<p>Setting the coefficient of x1^4 * x3^2 in the 4-dimensional polynomial poly4d to 12.3 would be performed by:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> pows[] = {4, 0, 2, 0};</div>
<div class="line"><a class="code" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> error  = <a class="code" href="group__cpl__polynomial.html#ga54a57b6d455f675637bb1f18479c27bd">cpl_polynomial_set_coeff</a>(poly4d, pows, 12.3);</div>
</div><!-- fragment --><p>Setting the coefficient of x^3 in the 1-dimensional polynomial poly1d to 12.3 would be performed by: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a> power = 3;</div>
<div class="line"><a class="code" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> error = <a class="code" href="group__cpl__polynomial.html#ga54a57b6d455f675637bb1f18479c27bd">cpl_polynomial_set_coeff</a>(poly1d, &amp;power, 12.3);</div>
</div><!-- fragment --><p>For efficiency reasons, multiple coefficients are best inserted with the of the highest powers first.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_ILLEGAL_INPUT if pows contains negative values </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#ga79968a56c1b2ee25b12747ad7e1b3478">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__type.html#ga4f6c44a14bbc3aea87b1f47acf8dfd02">CPL_SIZE_FORMAT</a>.</p>

</div>
</div>
<a id="gad445a939e63d62bc91455b5ef7924559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad445a939e63d62bc91455b5ef7924559">&#9670;&nbsp;</a></span>cpl_polynomial_shift_1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_shift_1d </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify p, p(x0, x1, ..., xi, ...) := (x0, x1, ..., xi+u, ...) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The polynomial to be modified in place </td></tr>
    <tr><td class="paramname">i</td><td>The dimension to shift (0 for first) </td></tr>
    <tr><td class="paramname">u</td><td>The shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a></dd></dl>
<p>Shifting the polynomial p(x) = x^n with u = 1 will generate the binomial coefficients for n.</p>
<p>Shifting the coordinate system to (x,y) for the 2D-polynomium poly2d:</p>
<div class="fragment"><div class="line"><a class="code" href="group__cpl__polynomial.html#gad445a939e63d62bc91455b5ef7924559">cpl_polynomial_shift_1d</a>(poly2d, 0, x);</div>
<div class="line"><a class="code" href="group__cpl__polynomial.html#gad445a939e63d62bc91455b5ef7924559">cpl_polynomial_shift_1d</a>(poly2d, 1, y);</div>
</div><!-- fragment --><p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_ILLEGAL_INPUT if i is negative</li>
<li>CPL_ERROR_ACCESS_OUT_OF_RANGE if i exceeds the dimension of p </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#ga79968a56c1b2ee25b12747ad7e1b3478">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0d916ea6a7e198a74863ecd9ea03d733">CPL_ERROR_ACCESS_OUT_OF_RANGE</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900ae6ab32df318c1af9afcddcb8249cad51">CPL_ERROR_ILLEGAL_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__polynomial.html#gac2e423274dca56ac7fdeaabacf2ec64e">cpl_polynomial_get_dimension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__cpl__wlcalib.html#gad86e86dc2041eae1283afcce1e6b7353">cpl_wlcalib_find_best_1d()</a>.</p>

</div>
</div>
<a id="ga9a44da11383b2d44cd23cc0708611530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a44da11383b2d44cd23cc0708611530">&#9670;&nbsp;</a></span>cpl_polynomial_solve_1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_solve_1d </td>
          <td>(</td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a>&#160;</td>
          <td class="paramname"><em>mul</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A real solution to p(x) = 0 using Newton-Raphsons method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The 1D-polynomial </td></tr>
    <tr><td class="paramname">x0</td><td>First guess of the solution </td></tr>
    <tr><td class="paramname">px</td><td>The solution, on error see below </td></tr>
    <tr><td class="paramname">mul</td><td>The root multiplicity (or 1 if unknown) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a></dd></dl>
<p>Even if a real solution exists, it may not be found if the first guess is too far from the solution. But a solution is guaranteed to be found if all roots of p are real. If the constant term is zero, the solution 0 will be returned regardless of the first guess.</p>
<p>No solution is found when the iterative process stops because: 1) It can not proceed because p`(x) = 0 (CPL_ERROR_DIVISION_BY_ZERO). 2) Only a finite number of iterations are allowed (CPL_ERROR_CONTINUE). Both cases may be due to lack of a real solution or a bad first guess. In these two cases *px is set to the value where the error occurred. In case of other errors *px is unmodified.</p>
<p>The accuracy and robustness deteriorates with increasing multiplicity of the solution. This is also the case with numerical multiplicity, i.e. when multiple solutions are located close together.</p>
<p>mul is assumed to be the multiplicity of the solution. Knowledge of the root multiplicity often improves the robustness and accuracy. If there is no knowledge of the root multiplicity mul should be 1. Setting mul to a too high value should be avoided.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INVALID_TYPE if the polynomial has the wrong dimension</li>
<li>CPL_ERROR_ILLEGAL_INPUT if the multiplicity is non-positive</li>
<li>CPL_ERROR_DIVISION_BY_ZERO if a division by zero occurs</li>
<li>CPL_ERROR_CONTINUE if the algorithm does not converge </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a0239c1c63e9d21e98e45221a3ad60406">CPL_ERROR_NONE</a>.</p>

</div>
</div>
<a id="ga457ef230f6dcc5ce6517386ea832aaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga457ef230f6dcc5ce6517386ea832aaa5">&#9670;&nbsp;</a></span>cpl_polynomial_subtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_polynomial_subtract </td>
          <td>(</td>
          <td class="paramtype">cpl_polynomial *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract two polynomials of the same dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The polynomial to hold the result </td></tr>
    <tr><td class="paramname">first</td><td>The polynomial to subtract from, or NULL </td></tr>
    <tr><td class="paramname">second</td><td>The polynomial to subtract, or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant CPL error code </dd></dl>
<dl class="section note"><dt>Note</dt><dd>self may be passed also as first and/or second</dd></dl>
<p>Possible CPL error code set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if the polynomials do not have identical dimensions </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#ga79968a56c1b2ee25b12747ad7e1b3478">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, and <a class="el" href="group__cpl__polynomial.html#gac2e423274dca56ac7fdeaabacf2ec64e">cpl_polynomial_get_dimension()</a>.</p>

</div>
</div>
<a id="ga09473199544ac51406f4952dad5b8665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09473199544ac51406f4952dad5b8665">&#9670;&nbsp;</a></span>cpl_vector_fill_polynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_vector_fill_polynomial </td>
          <td>(</td>
          <td class="paramtype">cpl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a 1D-polynomial on equidistant points using Horners rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Preallocated vector to contain the result </td></tr>
    <tr><td class="paramname">p</td><td>The 1D-polynomial </td></tr>
    <tr><td class="paramname">x0</td><td>The first point of evaluation </td></tr>
    <tr><td class="paramname">d</td><td>The increment between points of evaluation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE or the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__vector.html#ga72cfd50426a679a370e154f54a5fed4d" title="Fill a cpl_vector.">cpl_vector_fill</a></dd></dl>
<p>The evaluation points are x_i = x0 + i * d, i=0, 1, ..., n-1, where n is the length of the vector.</p>
<p>If d is zero it is preferable to simply use cpl_vector_fill(v, cpl_polynomial_eval_1d(p, x0, NULL)).</p>
<p>The call requires about 2nm FLOPs, where m+1 is the number of coefficients in p.</p>
<p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer is NULL</li>
<li>CPL_ERROR_INVALID_TYPE if the polynomial has the wrong dimension </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#ga79968a56c1b2ee25b12747ad7e1b3478">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7907a24014a3a45aebe5ee1842f0c6f3">CPL_ERROR_INVALID_TYPE</a>, and <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>.</p>

</div>
</div>
<a id="ga7d23d4b42c4d98bb6e50e53e67350aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d23d4b42c4d98bb6e50e53e67350aa0">&#9670;&nbsp;</a></span>cpl_vector_fill_polynomial_fit_residual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a> cpl_vector_fill_polynomial_fit_residual </td>
          <td>(</td>
          <td class="paramtype">cpl_vector *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>fitvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_vector *&#160;</td>
          <td class="paramname"><em>fitsigm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_polynomial *&#160;</td>
          <td class="paramname"><em>fit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpl_matrix *&#160;</td>
          <td class="paramname"><em>samppos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rechisq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the residual of a polynomial fit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Vector to hold the fitting residuals, fitvals may be used </td></tr>
    <tr><td class="paramname">fitvals</td><td>Vector of the p fitted values </td></tr>
    <tr><td class="paramname">fitsigm</td><td>Uncertainties of the sampled values or NULL for a uniform uncertainty </td></tr>
    <tr><td class="paramname">fit</td><td>The fitted polynomial </td></tr>
    <tr><td class="paramname">samppos</td><td>Matrix of p sample positions, with d rows and p columns </td></tr>
    <tr><td class="paramname">rechisq</td><td>If non-NULL, the reduced chi square of the fit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPL_ERROR_NONE on success, else the relevant <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If necessary, self is resized to the length of fitvals. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187" title="Fit a polynomial to a set of samples in a least squares sense.">cpl_polynomial_fit()</a></dd></dl>
<p>It is allowed to pass the same vector as both fitvals and as self, in which case fitvals is overwritten with the residuals.</p>
<p>If the relative uncertainties of the sampled values are known, they may be passed via fitsigm. NULL means that all uncertainties equal one. The uncertainties are taken into account when computing the reduced chi square value.</p>
<p>If rechisq is non-NULL, the reduced chi square of the fit is computed as well.</p>
<p>The mean square error, which was computed directly by the former CPL functions <a class="el" href="group__cpl__polynomial.html#ga43c9bc963e746ad10248c2795723288e" title="Fit a 1D-polynomial to a 1D-signal in a least squares sense.">cpl_polynomial_fit_1d_create()</a> and <a class="el" href="group__cpl__polynomial.html#gaab95f220cd97acdc6fa7b8d885709a18" title="Fit a 2D-polynomial to a 2D-surface in a least squares sense.">cpl_polynomial_fit_2d_create()</a> can be computed from the fitting residual like this:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> mse = <a class="code" href="group__cpl__vector.html#ga09ea2aa6ee2fe7350dacb9d4d5b0d9f6">cpl_vector_product</a>(fitresidual, fitresidual)</div>
<div class="line">                 / <a class="code" href="group__cpl__vector.html#gac72d7e38ce2f5ac2e0863e2a11e9af1d">cpl_vector_get_size</a>(fitresidual);</div>
</div><!-- fragment --><p>Possible <a class="el" href="group__cpl__error.html#ga49a0c316d52d2afbfd9fd94b95344900" title="Available error codes.">_cpl_error_code_</a> set in this function:</p><ul>
<li>CPL_ERROR_NULL_INPUT if an input pointer (other than fitsigm) is NULL</li>
<li>CPL_ERROR_INCOMPATIBLE_INPUT if samppos, fitvals, fitsigm or fit have incompatible sizes</li>
<li>CPL_ERROR_DIVISION_BY_ZERO if an element in fitsigm is zero</li>
<li>CPL_ERROR_DATA_NOT_FOUND if the number of columns in samppos is less than the number of coefficients in the fitted polynomial. </li>
</ul>

<p class="reference">References <a class="el" href="group__cpl__error.html#ga79968a56c1b2ee25b12747ad7e1b3478">cpl_ensure_code</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a5b82c7780a2a8a79dfafcac70717b830">CPL_ERROR_DATA_NOT_FOUND</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a67b9f44eb1db1ab12f0575dbb878c0fd">CPL_ERROR_INCOMPATIBLE_INPUT</a>, <a class="el" href="group__cpl__error.html#gga49a0c316d52d2afbfd9fd94b95344900a7b054cf7927d1bd0a9b3693a6715be84">CPL_ERROR_NULL_INPUT</a>, <a class="el" href="group__cpl__matrix.html#ga8cca30a90b99acbd643748ada726f2c9">cpl_matrix_get_data_const()</a>, <a class="el" href="group__cpl__matrix.html#ga4bade56f31c3e0f69ca513a557c1d4fd">cpl_matrix_get_ncol()</a>, <a class="el" href="group__cpl__matrix.html#gaba2be6537f0aacb0dfea437f186627c9">cpl_matrix_get_nrow()</a>, <a class="el" href="group__cpl__polynomial.html#gac2e423274dca56ac7fdeaabacf2ec64e">cpl_polynomial_get_dimension()</a>, <a class="el" href="group__cpl__vector.html#ga991ded30622122c78bb34191f7c7a7c6">cpl_vector_get_data_const()</a>, <a class="el" href="group__cpl__vector.html#gac72d7e38ce2f5ac2e0863e2a11e9af1d">cpl_vector_get_size()</a>, and <a class="el" href="group__cpl__vector.html#ga82def4430dfa77393ae974bbc915d360">cpl_vector_set_size()</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__cpl__polynomial_html_gad445a939e63d62bc91455b5ef7924559"><div class="ttname"><a href="group__cpl__polynomial.html#gad445a939e63d62bc91455b5ef7924559">cpl_polynomial_shift_1d</a></div><div class="ttdeci">cpl_error_code cpl_polynomial_shift_1d(cpl_polynomial *p, cpl_size i, double u)</div><div class="ttdoc">Modify p, p(x0, x1, ..., xi, ...) := (x0, x1, ..., xi+u, ...)</div><div class="ttdef"><b>Definition:</b> cpl_polynomial.c:1600</div></div>
<div class="ttc" id="agroup__cpl__error_html_ga44b4287e8a7a22122b94c220a1dd9459"><div class="ttname"><a href="group__cpl__error.html#ga44b4287e8a7a22122b94c220a1dd9459">cpl_error_code</a></div><div class="ttdeci">enum _cpl_error_code_ cpl_error_code</div><div class="ttdoc">The cpl_error_code type definition.</div><div class="ttdef"><b>Definition:</b> cpl_error.h:445</div></div>
<div class="ttc" id="agroup__cpl__polynomial_html_ga9734114647bfd84ec8bf596b21c7ae9c"><div class="ttname"><a href="group__cpl__polynomial.html#ga9734114647bfd84ec8bf596b21c7ae9c">cpl_polynomial_get_coeff</a></div><div class="ttdeci">double cpl_polynomial_get_coeff(const cpl_polynomial *self, const cpl_size *pows)</div><div class="ttdoc">Get a coefficient of the polynomial.</div><div class="ttdef"><b>Definition:</b> cpl_polynomial.c:816</div></div>
<div class="ttc" id="agroup__cpl__vector_html_gac72d7e38ce2f5ac2e0863e2a11e9af1d"><div class="ttname"><a href="group__cpl__vector.html#gac72d7e38ce2f5ac2e0863e2a11e9af1d">cpl_vector_get_size</a></div><div class="ttdeci">cpl_size cpl_vector_get_size(const cpl_vector *in)</div><div class="ttdoc">Get the size of the vector.</div><div class="ttdef"><b>Definition:</b> cpl_vector.c:718</div></div>
<div class="ttc" id="agroup__cpl__type_html_gacc431432a4fedf19ec6f7668dda3fbf0"><div class="ttname"><a href="group__cpl__type.html#gacc431432a4fedf19ec6f7668dda3fbf0">cpl_size</a></div><div class="ttdeci">long long cpl_size</div><div class="ttdoc">The type used for sizes and indices in CPL.</div><div class="ttdef"><b>Definition:</b> cpl_type.h:208</div></div>
<div class="ttc" id="agroup__cpl__polynomial_html_ga54a57b6d455f675637bb1f18479c27bd"><div class="ttname"><a href="group__cpl__polynomial.html#ga54a57b6d455f675637bb1f18479c27bd">cpl_polynomial_set_coeff</a></div><div class="ttdeci">cpl_error_code cpl_polynomial_set_coeff(cpl_polynomial *self, const cpl_size *pows, double value)</div><div class="ttdoc">Set a coefficient of the polynomial.</div><div class="ttdef"><b>Definition:</b> cpl_polynomial.c:879</div></div>
<div class="ttc" id="agroup__cpl__vector_html_ga09ea2aa6ee2fe7350dacb9d4d5b0d9f6"><div class="ttname"><a href="group__cpl__vector.html#ga09ea2aa6ee2fe7350dacb9d4d5b0d9f6">cpl_vector_product</a></div><div class="ttdeci">double cpl_vector_product(const cpl_vector *v1, const cpl_vector *v2)</div><div class="ttdoc">Compute the vector dot product.</div><div class="ttdef"><b>Definition:</b> cpl_vector.c:1206</div></div>
<div class="ttc" id="agroup__cpl__polynomial_html_gaa4cdbbf2a50f568d9768cf793b53b187"><div class="ttname"><a href="group__cpl__polynomial.html#gaa4cdbbf2a50f568d9768cf793b53b187">cpl_polynomial_fit</a></div><div class="ttdeci">cpl_error_code cpl_polynomial_fit(cpl_polynomial *self, const cpl_matrix *samppos, const cpl_boolean *sampsym, const cpl_vector *fitvals, const cpl_vector *fitsigm, cpl_boolean dimdeg, const cpl_size *mindeg, const cpl_size *maxdeg)</div><div class="ttdoc">Fit a polynomial to a set of samples in a least squares sense.</div><div class="ttdef"><b>Definition:</b> cpl_polynomial.c:1366</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
